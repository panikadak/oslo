(function(){class t extends THREE.Loader{constructor(t){super(t),this.littleEndian=!0}load(t,e,i,n){const s=this,r=new THREE.FileLoader(s.manager);r.setPath(s.path),r.setResponseType("arraybuffer"),r.setRequestHeader(s.requestHeader),r.setWithCredentials(s.withCredentials),r.load(t,(function(i){try{e(s.parse(i,t))}catch(r){n?n(r):console.error(r),s.manager.itemError(t)}}),i,n)}parse(t,e){function i(t,e){const i=t.length,n=new Uint8Array(e);let s,r,o,l=0,a=0;do{if(s=t[l++],s<32){if(s++,a+s>e)throw new Error("Output buffer is not large enough");if(l+s>i)throw new Error("Invalid compressed data");do{n[a++]=t[l++]}while(--s)}else{if(r=s>>5,o=a-((31&s)<<8)-1,l>=i)throw new Error("Invalid compressed data");if(7===r&&(r+=t[l++],l>=i))throw new Error("Invalid compressed data");if(o-=t[l++],a+r+2>e)throw new Error("Output buffer is not large enough");if(o<0)throw new Error("Invalid compressed data");if(o>=a)throw new Error("Invalid compressed data");do{n[a++]=n[o++]}while(2+--r)}}while(l<i);return n}function n(t){const e={},i=t.search(/[\r\n]DATA\s(\S*)\s/i),n=/[\r\n]DATA\s(\S*)\s/i.exec(t.substr(i-1));if(e.data=n[1],e.headerLen=n[0].length+i,e.str=t.substr(0,e.headerLen),e.str=e.str.replace(/\#.*/gi,""),e.version=/VERSION (.*)/i.exec(e.str),e.fields=/FIELDS (.*)/i.exec(e.str),e.size=/SIZE (.*)/i.exec(e.str),e.type=/TYPE (.*)/i.exec(e.str),e.count=/COUNT (.*)/i.exec(e.str),e.width=/WIDTH (.*)/i.exec(e.str),e.height=/HEIGHT (.*)/i.exec(e.str),e.viewpoint=/VIEWPOINT (.*)/i.exec(e.str),e.points=/POINTS (.*)/i.exec(e.str),null!==e.version&&(e.version=parseFloat(e.version[1])),null!==e.fields&&(e.fields=e.fields[1].split(" ")),null!==e.type&&(e.type=e.type[1].split(" ")),null!==e.width&&(e.width=parseInt(e.width[1])),null!==e.height&&(e.height=parseInt(e.height[1])),null!==e.viewpoint&&(e.viewpoint=e.viewpoint[1]),null!==e.points&&(e.points=parseInt(e.points[1],10)),null===e.points&&(e.points=e.width*e.height),null!==e.size&&(e.size=e.size[1].split(" ").map((function(t){return parseInt(t,10)}))),null!==e.count)e.count=e.count[1].split(" ").map((function(t){return parseInt(t,10)}));else{e.count=[];for(let t=0,i=e.fields.length;t<i;t++)e.count.push(1)}e.offset={};let s=0;for(let r=0,o=e.fields.length;r<o;r++)"ascii"===e.data?e.offset[e.fields[r]]=r:(e.offset[e.fields[r]]=s,s+=e.size[r]*e.count[r]);return e.rowSize=s,e}const s=THREE.LoaderUtils.decodeText(new Uint8Array(t)),r=n(s),o=[],l=[],a=[];if("ascii"===r.data){const t=r.offset,e=s.substr(r.headerLen),i=e.split("\n");for(let n=0,s=i.length;n<s;n++){if(""===i[n])continue;const e=i[n].split(" ");if(void 0!==t.x&&(o.push(parseFloat(e[t.x])),o.push(parseFloat(e[t.y])),o.push(parseFloat(e[t.z]))),void 0!==t.rgb){const i=parseFloat(e[t.rgb]),n=i>>16&255,s=i>>8&255,r=i>>0&255;a.push(n/255,s/255,r/255)}void 0!==t.normal_x&&(l.push(parseFloat(e[t.normal_x])),l.push(parseFloat(e[t.normal_y])),l.push(parseFloat(e[t.normal_z])))}}if("binary_compressed"===r.data){const e=new Uint32Array(t.slice(r.headerLen,r.headerLen+8)),n=e[0],s=e[1],p=i(new Uint8Array(t,r.headerLen+8,n),s),h=new DataView(p.buffer),u=r.offset;for(let t=0;t<r.points;t++)void 0!==u.x&&(o.push(h.getFloat32(r.points*u.x+r.size[0]*t,this.littleEndian)),o.push(h.getFloat32(r.points*u.y+r.size[1]*t,this.littleEndian)),o.push(h.getFloat32(r.points*u.z+r.size[2]*t,this.littleEndian))),void 0!==u.rgb&&(a.push(h.getUint8(r.points*u.rgb+r.size[3]*t+0)/255),a.push(h.getUint8(r.points*u.rgb+r.size[3]*t+1)/255),a.push(h.getUint8(r.points*u.rgb+r.size[3]*t+2)/255)),void 0!==u.normal_x&&(l.push(h.getFloat32(r.points*u.normal_x+r.size[4]*t,this.littleEndian)),l.push(h.getFloat32(r.points*u.normal_y+r.size[5]*t,this.littleEndian)),l.push(h.getFloat32(r.points*u.normal_z+r.size[6]*t,this.littleEndian)))}if("binary"===r.data){const e=new DataView(t,r.headerLen),i=r.offset;for(let t=0,n=0;t<r.points;t++,n+=r.rowSize)void 0!==i.x&&(o.push(e.getFloat32(n+i.x,this.littleEndian)),o.push(e.getFloat32(n+i.y,this.littleEndian)),o.push(e.getFloat32(n+i.z,this.littleEndian))),void 0!==i.rgb&&(a.push(e.getUint8(n+i.rgb+2)/255),a.push(e.getUint8(n+i.rgb+1)/255),a.push(e.getUint8(n+i.rgb+0)/255)),void 0!==i.normal_x&&(l.push(e.getFloat32(n+i.normal_x,this.littleEndian)),l.push(e.getFloat32(n+i.normal_y,this.littleEndian)),l.push(e.getFloat32(n+i.normal_z,this.littleEndian)))}const p=new THREE.BufferGeometry;o.length>0&&p.setAttribute("position",new THREE.Float32BufferAttribute(o,3)),l.length>0&&p.setAttribute("normal",new THREE.Float32BufferAttribute(l,3)),a.length>0&&p.setAttribute("color",new THREE.Float32BufferAttribute(a,3)),p.computeBoundingSphere();const h=new THREE.PointsMaterial({size:.005});a.length>0?h.vertexColors=!0:h.color.setHex(16777215*Math.random());const u=new THREE.Points(p,h);let d=e.split("").reverse().join("");return d=/([^\/]*)/.exec(d),d=d[1].split("").reverse().join(""),u.name=d,u}}THREE.PCDLoader=t})();