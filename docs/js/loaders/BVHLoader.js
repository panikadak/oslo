(function(){class e extends THREE.Loader{constructor(e){super(e),this.animateBonePositions=!0,this.animateBoneRotations=!0}load(e,t,o,n){const r=this,s=new THREE.FileLoader(r.manager);s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(e,(function(o){try{t(r.parse(o))}catch(s){n?n(s):console.error(s),r.manager.itemError(e)}}),o,n)}parse(e){function t(e){"HIERARCHY"!==a(e)&&console.error("THREE.BVHLoader: HIERARCHY expected.");const t=[],r=n(e,a(e),t);"MOTION"!==a(e)&&console.error("THREE.BVHLoader: MOTION expected.");let s=a(e).split(/[\s]+/);const i=parseInt(s[1]);isNaN(i)&&console.error("THREE.BVHLoader: Failed to read number of frames."),s=a(e).split(/[\s]+/);const l=parseFloat(s[2]);isNaN(l)&&console.error("THREE.BVHLoader: Failed to read frame time.");for(let n=0;n<i;n++)s=a(e).split(/[\s]+/),o(s,n*l,r);return t}function o(e,t,n){if("ENDSITE"===n.type)return;const r={time:t,position:new THREE.Vector3,rotation:new THREE.Quaternion};n.frames.push(r);const s=new THREE.Quaternion,a=new THREE.Vector3(1,0,0),i=new THREE.Vector3(0,1,0),l=new THREE.Vector3(0,0,1);for(let o=0;o<n.channels.length;o++)switch(n.channels[o]){case"Xposition":r.position.x=parseFloat(e.shift().trim());break;case"Yposition":r.position.y=parseFloat(e.shift().trim());break;case"Zposition":r.position.z=parseFloat(e.shift().trim());break;case"Xrotation":s.setFromAxisAngle(a,parseFloat(e.shift().trim())*Math.PI/180),r.rotation.multiply(s);break;case"Yrotation":s.setFromAxisAngle(i,parseFloat(e.shift().trim())*Math.PI/180),r.rotation.multiply(s);break;case"Zrotation":s.setFromAxisAngle(l,parseFloat(e.shift().trim())*Math.PI/180),r.rotation.multiply(s);break;default:console.warn("THREE.BVHLoader: Invalid channel type.")}for(let p=0;p<n.children.length;p++)o(e,t,n.children[p])}function n(e,t,o){const r={name:"",type:"",frames:[]};o.push(r);let s=t.split(/[\s]+/);"END"===s[0].toUpperCase()&&"SITE"===s[1].toUpperCase()?(r.type="ENDSITE",r.name="ENDSITE"):(r.name=s[1],r.type=s[0].toUpperCase()),"{"!==a(e)&&console.error("THREE.BVHLoader: Expected opening { after type & name"),s=a(e).split(/[\s]+/),"OFFSET"!==s[0]&&console.error("THREE.BVHLoader: Expected OFFSET but got: "+s[0]),4!==s.length&&console.error("THREE.BVHLoader: Invalid number of values for OFFSET.");const i=new THREE.Vector3(parseFloat(s[1]),parseFloat(s[2]),parseFloat(s[3]));if((isNaN(i.x)||isNaN(i.y)||isNaN(i.z))&&console.error("THREE.BVHLoader: Invalid values of OFFSET."),r.offset=i,"ENDSITE"!==r.type){s=a(e).split(/[\s]+/),"CHANNELS"!==s[0]&&console.error("THREE.BVHLoader: Expected CHANNELS definition.");const t=parseInt(s[1]);r.channels=s.splice(2,t),r.children=[]}while(1){const t=a(e);if("}"===t)return r;r.children.push(n(e,t,o))}}function r(e,t){const o=new THREE.Bone;if(t.push(o),o.position.add(e.offset),o.name=e.name,"ENDSITE"!==e.type)for(let n=0;n<e.children.length;n++)o.add(r(e.children[n],t));return o}function s(e){const t=[];for(let o=0;o<e.length;o++){const n=e[o];if("ENDSITE"===n.type)continue;const r=[],s=[],a=[];for(let e=0;e<n.frames.length;e++){const t=n.frames[e];r.push(t.time),s.push(t.position.x+n.offset.x),s.push(t.position.y+n.offset.y),s.push(t.position.z+n.offset.z),a.push(t.rotation.x),a.push(t.rotation.y),a.push(t.rotation.z),a.push(t.rotation.w)}i.animateBonePositions&&t.push(new THREE.VectorKeyframeTrack(".bones["+n.name+"].position",r,s)),i.animateBoneRotations&&t.push(new THREE.QuaternionKeyframeTrack(".bones["+n.name+"].quaternion",r,a))}return new THREE.AnimationClip("animation",-1,t)}function a(e){let t;while(0===(t=e.shift().trim()).length);return t}const i=this,l=e.split(/[\r\n]+/g),p=t(l),E=[];r(p[0],E);const c=s(p);return{skeleton:new THREE.Skeleton(E),clip:c}}}THREE.BVHLoader=e})();