(function(){const t=o(),n=new THREE.Mesh(new THREE.PlaneGeometry(2,2),t),e=new THREE.OrthographicCamera(0,1,0,1,0,1);let r=null,a=null;class s{constructor(t){a=t,a.compile(n,e)}generateMipmaps(s){if("roughnessMap"in s===!1)return;const{roughnessMap:o,normalMap:i}=s;if(null===o||null===i||!o.generateMipmaps||s.userData.roughnessUpdated)return;s.userData.roughnessUpdated=!0;let u=Math.max(o.image.width,i.image.width),l=Math.max(o.image.height,i.image.height);if(!THREE.MathUtils.isPowerOfTwo(u)||!THREE.MathUtils.isPowerOfTwo(l))return;const g=a.getRenderTarget(),v=a.autoClear;a.autoClear=!1,null!==r&&r.width===u&&r.height===l||(null!==r&&r.dispose(),r=new THREE.WebGLRenderTarget(u,l,{depthBuffer:!1}),r.scissorTest=!0);const p=new THREE.FramebufferTexture(u,l,o.format);p.wrapS=o.wrapS,p.wrapT=o.wrapT,p.minFilter=o.minFilter,p.magFilter=o.magFilter,s.roughnessMap=p,s.metalnessMap==o&&(s.metalnessMap=s.roughnessMap),s.aoMap==o&&(s.aoMap=s.roughnessMap),s.roughnessMap.offset.copy(o.offset),s.roughnessMap.repeat.copy(o.repeat),s.roughnessMap.center.copy(o.center),s.roughnessMap.rotation=o.rotation,s.roughnessMap.image=o.image,s.roughnessMap.matrixAutoUpdate=o.matrixAutoUpdate,s.roughnessMap.matrix.copy(o.matrix),t.uniforms.roughnessMap.value=o,t.uniforms.normalMap.value=i;const h=new THREE.Vector2(0,0),c=t.uniforms.texelSize.value;for(let m=0;u>=1&&l>=1;++m,u/=2,l/=2)c.set(1/u,1/l),0==m&&c.set(0,0),r.viewport.set(h.x,h.y,u,l),r.scissor.set(h.x,h.y,u,l),a.setRenderTarget(r),a.render(n,e),a.copyFramebufferToTexture(h,s.roughnessMap,m),t.uniforms.roughnessMap.value=s.roughnessMap;o.dispose(),a.setRenderTarget(g),a.autoClear=v}dispose(){t.dispose(),n.geometry.dispose(),null!=r&&r.dispose()}}function o(){const t=new THREE.RawShaderMaterial({uniforms:{roughnessMap:{value:null},normalMap:{value:null},texelSize:{value:new THREE.Vector2(1,1)}},vertexShader:"\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tattribute vec3 position;\n\t\t\tattribute vec2 uv;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tvoid main() {\n\n\t\t\t\tvUv = uv;\n\n\t\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t\t}\n\t\t",fragmentShader:"\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tuniform sampler2D roughnessMap;\n\t\t\tuniform sampler2D normalMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\n\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tfloat roughnessToVariance( float roughness ) {\n\n\t\t\t\tfloat variance = 0.0;\n\n\t\t\t\tif ( roughness >= r1 ) {\n\n\t\t\t\t\tvariance = ( r0 - roughness ) * ( v1 - v0 ) / ( r0 - r1 ) + v0;\n\n\t\t\t\t} else if ( roughness >= r4 ) {\n\n\t\t\t\t\tvariance = ( r1 - roughness ) * ( v4 - v1 ) / ( r1 - r4 ) + v1;\n\n\t\t\t\t} else if ( roughness >= r5 ) {\n\n\t\t\t\t\tvariance = ( r4 - roughness ) * ( v5 - v4 ) / ( r4 - r5 ) + v4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfloat roughness2 = roughness * roughness;\n\n\t\t\t\t\tvariance = 1.79 * roughness2 * roughness2;\n\n\t\t\t\t}\n\n\t\t\t\treturn variance;\n\n\t\t\t}\n\n\t\t\tfloat varianceToRoughness( float variance ) {\n\n\t\t\t\tfloat roughness = 0.0;\n\n\t\t\t\tif ( variance >= v1 ) {\n\n\t\t\t\t\troughness = ( v0 - variance ) * ( r1 - r0 ) / ( v0 - v1 ) + r0;\n\n\t\t\t\t} else if ( variance >= v4 ) {\n\n\t\t\t\t\troughness = ( v1 - variance ) * ( r4 - r1 ) / ( v1 - v4 ) + r1;\n\n\t\t\t\t} else if ( variance >= v5 ) {\n\n\t\t\t\t\troughness = ( v4 - variance ) * ( r5 - r4 ) / ( v4 - v5 ) + r4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\troughness = pow( 0.559 * variance, 0.25 ); // 0.559 = 1.0 / 1.79\n\n\t\t\t\t}\n\n\t\t\t\treturn roughness;\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = texture2D( roughnessMap, vUv, - 1.0 );\n\n\t\t\t\tif ( texelSize.x == 0.0 ) return;\n\n\t\t\t\tfloat roughness = gl_FragColor.g;\n\n\t\t\t\tfloat variance = roughnessToVariance( roughness );\n\n\t\t\t\tvec3 avgNormal;\n\n\t\t\t\tfor ( float x = - 1.0; x < 2.0; x += 2.0 ) {\n\n\t\t\t\t\tfor ( float y = - 1.0; y < 2.0; y += 2.0 ) {\n\n\t\t\t\t\t\tvec2 uv = vUv + vec2( x, y ) * 0.25 * texelSize;\n\n\t\t\t\t\t\tavgNormal += normalize( texture2D( normalMap, uv, - 1.0 ).xyz - 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvariance += 1.0 - 0.25 * length( avgNormal );\n\n\t\t\t\tgl_FragColor.g = varianceToRoughness( variance );\n\n\t\t\t}\n\t\t",blending:THREE.NoBlending,depthTest:!1,depthWrite:!1});return t.type="RoughnessMipmapper",t}THREE.RoughnessMipmapper=s})();