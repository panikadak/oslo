(function(){class t{parse(t,e={}){const o=void 0!==e.binary&&e.binary,r=[];let n,s=0;t.traverse((function(t){if(t.isMesh){const e=t.geometry;if(!0!==e.isBufferGeometry)throw new Error("THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.");const o=e.index,n=e.getAttribute("position");s+=null!==o?o.count/3:n.count/3,r.push({object3d:t,geometry:e})}}));let i=80;if(!0===o){const t=2*s+3*s*4*4+80+4,e=new ArrayBuffer(t);n=new DataView(e),n.setUint32(i,s,!0),i+=4}else n="",n+="solid exported\n";const f=new THREE.Vector3,c=new THREE.Vector3,l=new THREE.Vector3,a=new THREE.Vector3,u=new THREE.Vector3,E=new THREE.Vector3;for(let x=0,d=r.length;x<d;x++){const t=r[x].object3d,e=r[x].geometry,o=e.index,n=e.getAttribute("position");if(null!==o)for(let r=0;r<o.count;r+=3){const e=o.getX(r+0),s=o.getX(r+1),i=o.getX(r+2);m(e,s,i,n,t)}else for(let r=0;r<n.count;r+=3){const e=r+0,o=r+1,s=r+2;m(e,o,s,n,t)}}return!1===o&&(n+="endsolid exported\n"),n;function m(t,e,r,s,a){f.fromBufferAttribute(s,t),c.fromBufferAttribute(s,e),l.fromBufferAttribute(s,r),!0===a.isSkinnedMesh&&(a.boneTransform(t,f),a.boneTransform(e,c),a.boneTransform(r,l)),f.applyMatrix4(a.matrixWorld),c.applyMatrix4(a.matrixWorld),l.applyMatrix4(a.matrixWorld),p(f,c,l),y(f),y(c),y(l),!0===o?(n.setUint16(i,0,!0),i+=2):(n+="\t\tendloop\n",n+="\tendfacet\n")}function p(t,e,r){a.subVectors(r,e),u.subVectors(t,e),a.cross(u).normalize(),E.copy(a).normalize(),!0===o?(n.setFloat32(i,E.x,!0),i+=4,n.setFloat32(i,E.y,!0),i+=4,n.setFloat32(i,E.z,!0),i+=4):(n+="\tfacet normal "+E.x+" "+E.y+" "+E.z+"\n",n+="\t\touter loop\n")}function y(t){!0===o?(n.setFloat32(i,t.x,!0),i+=4,n.setFloat32(i,t.y,!0),i+=4,n.setFloat32(i,t.z,!0),i+=4):n+="\t\t\tvertex "+t.x+" "+t.y+" "+t.z+"\n"}}}THREE.STLExporter=t})();