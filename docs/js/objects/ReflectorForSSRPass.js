(function(){class t extends THREE.Mesh{constructor(e,r={}){super(e),this.type="ReflectorForSSRPass";const a=this,n=void 0!==r.color?new THREE.Color(r.color):new THREE.Color(8355711),i=r.textureWidth||512,o=r.textureHeight||512,l=r.clipBias||0,s=r.shader||t.ReflectorShader,u=!0===r.useDepthTexture,c=new THREE.Vector3(0,1,0),d=new THREE.Vector3,v=new THREE.Vector3;a.needsUpdate=!1,a.maxDistance=t.ReflectorShader.uniforms.maxDistance.value,a.opacity=t.ReflectorShader.uniforms.opacity.value,a.color=n,a.resolution=r.resolution||new THREE.Vector2(window.innerWidth,window.innerHeight),a._distanceAttenuation=t.ReflectorShader.defines.DISTANCE_ATTENUATION,Object.defineProperty(a,"distanceAttenuation",{get(){return a._distanceAttenuation},set(t){a._distanceAttenuation!==t&&(a._distanceAttenuation=t,a.material.defines.DISTANCE_ATTENUATION=t,a.material.needsUpdate=!0)}}),a._fresnel=t.ReflectorShader.defines.FRESNEL,Object.defineProperty(a,"fresnel",{get(){return a._fresnel},set(t){a._fresnel!==t&&(a._fresnel=t,a.material.defines.FRESNEL=t,a.material.needsUpdate=!0)}});const f=new THREE.Vector3,p=new THREE.Vector3,m=new THREE.Vector3,E=new THREE.Matrix4,x=new THREE.Vector3(0,0,-1),T=new THREE.Vector3,R=new THREE.Vector3,h=new THREE.Matrix4,w=new THREE.PerspectiveCamera;let g;u&&(g=new THREE.DepthTexture,g.type=THREE.UnsignedShortType,g.minFilter=THREE.NearestFilter,g.magFilter=THREE.NearestFilter);const M={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBFormat,depthTexture:u?g:null},b=new THREE.WebGLRenderTarget(i,o,M);THREE.MathUtils.isPowerOfTwo(i)&&THREE.MathUtils.isPowerOfTwo(o)||(b.texture.generateMipmaps=!1);const y=new THREE.ShaderMaterial({transparent:u,defines:Object.assign({},t.ReflectorShader.defines,{useDepthTexture:u}),uniforms:THREE.UniformsUtils.clone(s.uniforms),fragmentShader:s.fragmentShader,vertexShader:s.vertexShader});y.uniforms["tDiffuse"].value=b.texture,y.uniforms["color"].value=a.color,y.uniforms["textureMatrix"].value=h,u&&(y.uniforms["tDepth"].value=b.depthTexture),this.material=y;const H=new THREE.Plane(new THREE.Vector3(0,1,0),l),C=[H];this.doRender=function(t,e,r){if(y.uniforms["maxDistance"].value=a.maxDistance,y.uniforms["color"].value=a.color,y.uniforms["opacity"].value=a.opacity,d.copy(r.position).normalize(),v.copy(d).reflect(c),y.uniforms["fresnelCoe"].value=(d.dot(v)+1)/2,p.setFromMatrixPosition(a.matrixWorld),m.setFromMatrixPosition(r.matrixWorld),E.extractRotation(a.matrixWorld),f.set(0,0,1),f.applyMatrix4(E),T.subVectors(p,m),T.dot(f)>0)return;T.reflect(f).negate(),T.add(p),E.extractRotation(r.matrixWorld),x.set(0,0,-1),x.applyMatrix4(E),x.add(m),R.subVectors(p,x),R.reflect(f).negate(),R.add(p),w.position.copy(T),w.up.set(0,1,0),w.up.applyMatrix4(E),w.up.reflect(f),w.lookAt(R),w.far=r.far,w.updateMatrixWorld(),w.projectionMatrix.copy(r.projectionMatrix),y.uniforms["virtualCameraNear"].value=r.near,y.uniforms["virtualCameraFar"].value=r.far,y.uniforms["virtualCameraMatrixWorld"].value=w.matrixWorld,y.uniforms["virtualCameraProjectionMatrix"].value=r.projectionMatrix,y.uniforms["virtualCameraProjectionMatrixInverse"].value=r.projectionMatrixInverse,y.uniforms["resolution"].value=a.resolution,h.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),h.multiply(w.projectionMatrix),h.multiply(w.matrixWorldInverse),h.multiply(a.matrixWorld),b.texture.encoding=t.outputEncoding;const n=t.getRenderTarget(),i=t.xr.enabled,o=t.shadowMap.autoUpdate,l=t.clippingPlanes;t.xr.enabled=!1,t.shadowMap.autoUpdate=!1,t.clippingPlanes=C,t.setRenderTarget(b),t.state.buffers.depth.setMask(!0),!1===t.autoClear&&t.clear(),t.render(e,w),t.xr.enabled=i,t.shadowMap.autoUpdate=o,t.clippingPlanes=l,t.setRenderTarget(n);const s=r.viewport;void 0!==s&&t.state.viewport(s)},this.getRenderTarget=function(){return b}}}t.prototype.isReflectorForSSRPass=!0,t.ReflectorShader={defines:{DISTANCE_ATTENUATION:!0,FRESNEL:!0},uniforms:{color:{value:null},tDiffuse:{value:null},tDepth:{value:null},textureMatrix:{value:new THREE.Matrix4},maxDistance:{value:180},opacity:{value:.5},fresnelCoe:{value:null},virtualCameraNear:{value:null},virtualCameraFar:{value:null},virtualCameraProjectionMatrix:{value:new THREE.Matrix4},virtualCameraMatrixWorld:{value:new THREE.Matrix4},virtualCameraProjectionMatrixInverse:{value:new THREE.Matrix4},resolution:{value:new THREE.Vector2}},vertexShader:"\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnelCoe;\n\t\tuniform float virtualCameraNear;\n\t\tuniform float virtualCameraFar;\n\t\tuniform mat4 virtualCameraProjectionMatrix;\n\t\tuniform mat4 virtualCameraProjectionMatrixInverse;\n\t\tuniform mat4 virtualCameraMatrixWorld;\n\t\tuniform vec2 resolution;\n\t\tvarying vec4 vUv;\n\t\t#include <packing>\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\n\t\t\t\tuv.x=1.-uv.x;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\t\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\n\t\t\t\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\n\t\t\t\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\n\t\t\t\tif(worldPosition.y>maxDistance) discard;\n\t\t\t\tfloat op=opacity;\n\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\tfloat ratio=1.-(worldPosition.y/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t"},THREE.ReflectorForSSRPass=t})();