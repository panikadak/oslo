(function(){const t=new THREE.Vector3,e=new THREE.Vector3,n=new THREE.Vector4,r=new THREE.Vector4,a=new THREE.Vector4,i=new THREE.Vector3,o=new THREE.Matrix4,s=new THREE.Line3,c=new THREE.Vector3,l=new THREE.Box3,u=new THREE.Sphere,p=new THREE.Vector4;function E(t,e,n,r){return p.set(0,0,-e,1).applyMatrix4(t.projectionMatrix),p.multiplyScalar(1/p.w),p.x=n/r.width,p.y=n/r.height,p.applyMatrix4(t.projectionMatrixInverse),p.multiplyScalar(1/p.w),Math.abs(Math.max(p.x,p.y))}class m extends THREE.Mesh{constructor(t=new THREE.LineSegmentsGeometry,e=new THREE.LineMaterial({color:16777215*Math.random()})){super(t,e),this.type="LineSegments2"}computeLineDistances(){const n=this.geometry,r=n.attributes.instanceStart,a=n.attributes.instanceEnd,i=new Float32Array(2*r.count);for(let s=0,c=0,l=r.count;s<l;s++,c+=2)t.fromBufferAttribute(r,s),e.fromBufferAttribute(a,s),i[c]=0===c?0:i[c-1],i[c+1]=i[c]+t.distanceTo(e);const o=new THREE.InstancedInterleavedBuffer(i,2,1);return n.setAttribute("instanceDistanceStart",new THREE.InterleavedBufferAttribute(o,1,0)),n.setAttribute("instanceDistanceEnd",new THREE.InterleavedBufferAttribute(o,1,1)),this}raycast(t,e){null===t.camera&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.');const p=void 0!==t.params.Line2&&t.params.Line2.threshold||0,m=t.ray,y=t.camera,x=y.projectionMatrix,d=this.matrixWorld,f=this.geometry,w=this.material,T=w.resolution,h=w.linewidth+p,M=f.attributes.instanceStart,R=f.attributes.instanceEnd,H=-y.near;null===f.boundingSphere&&f.computeBoundingSphere(),u.copy(f.boundingSphere).applyMatrix4(d);const b=Math.max(y.near,u.distanceToPoint(m.origin)),S=E(y,b,h,T);if(u.radius+=S,!1===t.ray.intersectsSphere(u))return;null===f.boundingBox&&f.computeBoundingBox(),l.copy(f.boundingBox).applyMatrix4(d);const g=Math.max(y.near,l.distanceToPoint(m.origin)),z=E(y,g,h,T);if(l.max.x+=z,l.max.y+=z,l.max.z+=z,l.min.x-=z,l.min.y-=z,l.min.z-=z,!1!==t.ray.intersectsBox(l)){m.at(1,a),a.w=1,a.applyMatrix4(y.matrixWorldInverse),a.applyMatrix4(x),a.multiplyScalar(1/a.w),a.x*=T.x/2,a.y*=T.y/2,a.z=0,i.copy(a),o.multiplyMatrices(y.matrixWorldInverse,d);for(let t=0,a=M.count;t<a;t++){n.fromBufferAttribute(M,t),r.fromBufferAttribute(R,t),n.w=1,r.w=1,n.applyMatrix4(o),r.applyMatrix4(o);var B=n.z>H&&r.z>H;if(B)continue;if(n.z>H){const t=n.z-r.z,e=(n.z-H)/t;n.lerp(r,e)}else if(r.z>H){const t=r.z-n.z,e=(r.z-H)/t;r.lerp(n,e)}n.applyMatrix4(x),r.applyMatrix4(x),n.multiplyScalar(1/n.w),r.multiplyScalar(1/r.w),n.x*=T.x/2,n.y*=T.y/2,r.x*=T.x/2,r.y*=T.y/2,s.start.copy(n),s.start.z=0,s.end.copy(r),s.end.z=0;const a=s.closestPointToPointParameter(i,!0);s.at(a,c);const l=THREE.MathUtils.lerp(n.z,r.z,a),u=l>=-1&&l<=1,p=i.distanceTo(c)<.5*h;if(u&&p){s.start.fromBufferAttribute(M,t),s.end.fromBufferAttribute(R,t),s.start.applyMatrix4(d),s.end.applyMatrix4(d);const n=new THREE.Vector3,r=new THREE.Vector3;m.distanceSqToSegment(s.start,s.end,r,n),e.push({point:r,pointOnLine:n,distance:m.origin.distanceTo(r),object:this,face:null,faceIndex:t,uv:null,uv2:null})}}}}}m.prototype.isLineSegments2=!0,THREE.LineSegments2=m})();