(function(){const t=new THREE.Vector3,e=new THREE.Vector3,r=new THREE.Vector3;class o{modify(o,n,i=!0){function l(){g=new Float32Array(3*E.length);for(let o=0;o<E.length;o+=3){let n=E[o];t.set(p[3*n],p[3*n+1],p[3*n+2]),n=E[o+1],e.set(p[3*n],p[3*n+1],p[3*n+2]),n=E[o+2],r.set(p[3*n],p[3*n+1],p[3*n+2]),r.sub(e),t.sub(e);const i=r.cross(t).normalize();for(let t=0;t<3;t++)g[3*(o+t)]=i.x,g[3*(o+t)+1]=i.y,g[3*(o+t)+2]=i.z}}function s(){m=Array(p.length/3);for(let t=0;t<E.length;t++){const e=E[t];null==m[e]&&(m[e]=[]),m[e].push(t)}}function u(r,o,n){t.set(g[3*n],g[3*n+1],g[3*n+2]).normalize();const i={splitGroup:[],currentGroup:[n]};for(const l of r)l!==n&&(e.set(g[3*l],g[3*l+1],g[3*l+2]).normalize(),e.dot(t)<o?i.splitGroup.push(l):i.currentGroup.push(l));return i}function f(t,e,r=null){if(0===t.length)return;const o=[];for(const i of t)o.push(u(t,e,i));let n=o[0];for(const i of o)i.currentGroup.length>n.currentGroup.length&&(n=i);null!=r&&h.push({original:r,indexes:n.currentGroup}),n.splitGroup.length&&f(n.splitGroup,e,r||n.currentGroup[0])}if(!0===o.isGeometry)return void console.error("THREE.EdgeSplitModifier no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");let c=!1,a=null;if(o.attributes.normal&&(c=!0,o=o.clone(),!0===i&&null!==o.index&&(a=o.attributes.normal.array),o.deleteAttribute("normal")),null==o.index){if(void 0===THREE.BufferGeometryUtils)throw"THREE.EdgeSplitModifier relies on THREE.BufferGeometryUtils";o=THREE.BufferGeometryUtils.mergeVertices(o)}const E=o.index.array,p=o.getAttribute("position").array;let g,m;l(),s();const h=[];for(const t of m)f(t,Math.cos(n)-.001);const y={};for(const t of Object.keys(o.attributes)){const e=o.attributes[t],r=new e.array.constructor((E.length+h.length)*e.itemSize);r.set(e.array),y[t]=new THREE.BufferAttribute(r,e.itemSize,e.normalized)}const d=new Uint32Array(E.length);d.set(E);for(let t=0;t<h.length;t++){const e=h[t],r=E[e.original];for(const o of Object.values(y))for(let e=0;e<o.itemSize;e++)o.array[(E.length+t)*o.itemSize+e]=o.array[r*o.itemSize+e];for(const o of e.indexes)d[o]=E.length+t}o=new THREE.BufferGeometry,o.setIndex(new THREE.BufferAttribute(d,1));for(const t of Object.keys(y))o.setAttribute(t,y[t]);if(c&&(o.computeVertexNormals(),null!==a)){const t=new Array(a.length/3).fill(!1);for(const e of h)t[e.original]=!0;for(let e=0;e<t.length;e++)if(!1===t[e])for(let t=0;t<3;t++)o.attributes.normal.array[3*e+t]=a[3*e+t]}return o}}THREE.EdgeSplitModifier=o})();