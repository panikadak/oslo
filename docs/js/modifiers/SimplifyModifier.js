(function(){const e=new THREE.Vector3,t=new THREE.Vector3;class o{constructor(){if(void 0===THREE.BufferGeometryUtils)throw"THREE.SimplifyModifier relies on THREE.BufferGeometryUtils"}modify(e,t){if(!0===e.isGeometry)return void console.error("THREE.SimplifyModifier no longer supports Geometry. Use THREE.BufferGeometry instead.");e=e.clone();const o=e.attributes;for(const r in o)"position"!==r&&e.deleteAttribute(r);e=THREE.BufferGeometryUtils.mergeVertices(e);const s=[],i=[],n=e.getAttribute("position");for(let r=0;r<n.count;r++){const e=(new THREE.Vector3).fromBufferAttribute(n,r),t=new u(e);s.push(t)}let h,l=e.getIndex();if(null!==l)for(let r=0;r<l.count;r+=3){const e=l.getX(r),t=l.getX(r+1),o=l.getX(r+2),n=new a(s[e],s[t],s[o],e,t,o);i.push(n)}else for(let r=0;r<n.count;r+=3){const e=r,t=r+1,o=r+2,n=new a(s[e],s[t],s[o],e,t,o);i.push(n)}for(let c=0,f=s.length;c<f;c++)r(s[c]);let g=t;while(g--){if(h=f(s),!h){console.log("THREE.SimplifyModifier: No next vertex");break}c(s,i,h,h.collapseNeighbor)}const v=new THREE.BufferGeometry,b=[];l=[];for(let r=0;r<s.length;r++){const e=s[r].position;b.push(e.x,e.y,e.z),s[r].id=r}for(let r=0;r<i.length;r++){const e=i[r];l.push(e.v1.id,e.v2.id,e.v3.id)}return v.setAttribute("position",new THREE.Float32BufferAttribute(b,3)),v.setIndex(l),v}}function s(e,t){-1===e.indexOf(t)&&e.push(t)}function i(e,t){var o=e.indexOf(t);o>-1&&e.splice(o,1)}function n(e,t){const o=t.position.distanceTo(e.position);let s=0;const i=[];for(let h=0,l=e.faces.length;h<l;h++){const o=e.faces[h];o.hasVertex(t)&&i.push(o)}for(let h=0,l=e.faces.length;h<l;h++){let t=1;const o=e.faces[h];for(let e=0;e<i.length;e++){const s=i[e],n=o.normal.dot(s.normal);t=Math.min(t,(1.001-n)/2)}s=Math.max(s,t)}const n=0;i.length<2&&(s=1);const r=o*s+n;return r}function r(e){if(0===e.neighbors.length)return e.collapseNeighbor=null,void(e.collapseCost=-.01);e.collapseCost=1e5,e.collapseNeighbor=null;for(let t=0;t<e.neighbors.length;t++){const o=n(e,e.neighbors[t]);e.collapseNeighbor||(e.collapseNeighbor=e.neighbors[t],e.collapseCost=o,e.minCost=o,e.totalCost=0,e.costCount=0),e.costCount++,e.totalCost+=o,o<e.minCost&&(e.collapseNeighbor=e.neighbors[t],e.minCost=o)}e.collapseCost=e.totalCost/e.costCount}function h(e,t){console.assert(0===e.faces.length);while(e.neighbors.length){const t=e.neighbors.pop();i(t.neighbors,e)}i(t,e)}function l(e,t){i(t,e),e.v1&&i(e.v1.faces,e),e.v2&&i(e.v2.faces,e),e.v3&&i(e.v3.faces,e);const o=[e.v1,e.v2,e.v3];for(let s=0;s<3;s++){const e=o[s],t=o[(s+1)%3];e&&t&&(e.removeIfNonNeighbor(t),t.removeIfNonNeighbor(e))}}function c(e,t,o,s){if(!s)return void h(o,e);const i=[];for(let n=0;n<o.neighbors.length;n++)i.push(o.neighbors[n]);for(let n=o.faces.length-1;n>=0;n--)o.faces[n].hasVertex(s)&&l(o.faces[n],t);for(let n=o.faces.length-1;n>=0;n--)o.faces[n].replaceVertex(o,s);h(o,e);for(let n=0;n<i.length;n++)r(i[n])}function f(e){let t=e[0];for(let o=0;o<e.length;o++)e[o].collapseCost<t.collapseCost&&(t=e[o]);return t}class a{constructor(e,t,o,s,i,n){this.a=s,this.b=i,this.c=n,this.v1=e,this.v2=t,this.v3=o,this.normal=new THREE.Vector3,this.computeNormal(),e.faces.push(this),e.addUniqueNeighbor(t),e.addUniqueNeighbor(o),t.faces.push(this),t.addUniqueNeighbor(e),t.addUniqueNeighbor(o),o.faces.push(this),o.addUniqueNeighbor(e),o.addUniqueNeighbor(t)}computeNormal(){const o=this.v1.position,s=this.v2.position,i=this.v3.position;e.subVectors(i,s),t.subVectors(o,s),e.cross(t).normalize(),this.normal.copy(e)}hasVertex(e){return e===this.v1||e===this.v2||e===this.v3}replaceVertex(e,t){e===this.v1?this.v1=t:e===this.v2?this.v2=t:e===this.v3&&(this.v3=t),i(e.faces,this),t.faces.push(this),e.removeIfNonNeighbor(this.v1),this.v1.removeIfNonNeighbor(e),e.removeIfNonNeighbor(this.v2),this.v2.removeIfNonNeighbor(e),e.removeIfNonNeighbor(this.v3),this.v3.removeIfNonNeighbor(e),this.v1.addUniqueNeighbor(this.v2),this.v1.addUniqueNeighbor(this.v3),this.v2.addUniqueNeighbor(this.v1),this.v2.addUniqueNeighbor(this.v3),this.v3.addUniqueNeighbor(this.v1),this.v3.addUniqueNeighbor(this.v2),this.computeNormal()}}class u{constructor(e){this.position=e,this.id=-1,this.faces=[],this.neighbors=[],this.collapseCost=0,this.collapseNeighbor=null}addUniqueNeighbor(e){s(this.neighbors,e)}removeIfNonNeighbor(e){const t=this.neighbors,o=this.faces,s=t.indexOf(e);if(-1!==s){for(let t=0;t<o.length;t++)if(o[t].hasVertex(e))return;t.splice(s,1)}}}THREE.SimplifyModifier=o})();