(function(){class e{constructor(){this.id=0,this.object=null,this.z=0,this.renderOrder=0}}class t{constructor(){this.id=0,this.v1=new r,this.v2=new r,this.v3=new r,this.normalModel=new THREE.Vector3,this.vertexNormalsModel=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3],this.vertexNormalsLength=0,this.color=new THREE.Color,this.material=null,this.uvs=[new THREE.Vector2,new THREE.Vector2,new THREE.Vector2],this.z=0,this.renderOrder=0}}class r{constructor(){this.position=new THREE.Vector3,this.positionWorld=new THREE.Vector3,this.positionScreen=new THREE.Vector4,this.visible=!0}copy(e){this.positionWorld.copy(e.positionWorld),this.positionScreen.copy(e.positionScreen)}}class o{constructor(){this.id=0,this.v1=new r,this.v2=new r,this.vertexColors=[new THREE.Color,new THREE.Color],this.material=null,this.z=0,this.renderOrder=0}}class i{constructor(){this.id=0,this.object=null,this.x=0,this.y=0,this.z=0,this.rotation=0,this.scale=new THREE.Vector2,this.material=null,this.renderOrder=0}}class n{constructor(){let n,s,l,c,a,p,u,h,f,d,m,E=0,y=0,x=0,g=0,w=0;const v={objects:[],lights:[],elements:[]},R=new THREE.Vector3,T=new THREE.Vector4,M=new THREE.Box3(new THREE.Vector3(-1,-1,-1),new THREE.Vector3(1,1,1)),H=new THREE.Box3,b=new Array(3),j=new THREE.Matrix4,S=new THREE.Matrix4,z=new THREE.Matrix4,V=new THREE.Frustum,O=[],C=[],G=[],P=[],W=[];function B(){const e=[],t=[],r=[];let o=null;const i=new THREE.Matrix3;function n(n){o=n,i.getNormalMatrix(o.matrixWorld),e.length=0,t.length=0,r.length=0}function s(e){const t=e.position,r=e.positionWorld,o=e.positionScreen;r.copy(t).applyMatrix4(m),o.copy(r).applyMatrix4(S);const i=1/o.w;o.x*=i,o.y*=i,o.z*=i,e.visible=o.x>=-1&&o.x<=1&&o.y>=-1&&o.y<=1&&o.z>=-1&&o.z<=1}function c(e,t,r){l=k(),l.position.set(e,t,r),s(l)}function p(t,r,o){e.push(t,r,o)}function h(e,r,o){t.push(e,r,o)}function f(e,t){r.push(e,t)}function d(e,t,r){return!0===e.visible||!0===t.visible||!0===r.visible||(b[0]=e.positionScreen,b[1]=t.positionScreen,b[2]=r.positionScreen,M.intersectsBox(H.setFromPoints(b)))}function E(e,t,r){return(r.positionScreen.x-e.positionScreen.x)*(t.positionScreen.y-e.positionScreen.y)-(r.positionScreen.y-e.positionScreen.y)*(t.positionScreen.x-e.positionScreen.x)<0}function y(e,r){const i=C[e],n=C[r];i.positionScreen.copy(i.position).applyMatrix4(z),n.positionScreen.copy(n.position).applyMatrix4(z),!0===D(i.positionScreen,n.positionScreen)&&(i.positionScreen.multiplyScalar(1/i.positionScreen.w),n.positionScreen.multiplyScalar(1/n.positionScreen.w),u=X(),u.id=o.id,u.v1.copy(i),u.v2.copy(n),u.z=Math.max(i.positionScreen.z,n.positionScreen.z),u.renderOrder=o.renderOrder,u.material=o.material,o.material.vertexColors&&(u.vertexColors[0].fromArray(t,3*e),u.vertexColors[1].fromArray(t,3*r)),v.elements.push(u))}function x(n,s,l,c){const p=C[n],u=C[s],h=C[l];if(!1!==d(p,u,h)&&(c.side===THREE.DoubleSide||!0===E(p,u,h))){a=I(),a.id=o.id,a.v1.copy(p),a.v2.copy(u),a.v3.copy(h),a.z=(p.positionScreen.z+u.positionScreen.z+h.positionScreen.z)/3,a.renderOrder=o.renderOrder,R.subVectors(h.position,u.position),T.subVectors(p.position,u.position),R.cross(T),a.normalModel.copy(R),a.normalModel.applyMatrix3(i).normalize();for(let t=0;t<3;t++){const o=a.vertexNormalsModel[t];o.fromArray(e,3*arguments[t]),o.applyMatrix3(i).normalize();const n=a.uvs[t];n.fromArray(r,2*arguments[t])}a.vertexNormalsLength=3,a.material=c,c.vertexColors&&a.color.fromArray(t,3*n),v.elements.push(a)}}return{setObject:n,projectVertex:s,checkTriangleVisibility:d,checkBackfaceCulling:E,pushVertex:c,pushNormal:p,pushColor:h,pushUv:f,pushLine:y,pushTriangle:x}}this.projectVector=function(e,t){console.warn("THREE.Projector: .projectVector() is now vector.project()."),e.project(t)},this.unprojectVector=function(e,t){console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."),e.unproject(t)},this.pickingRay=function(){console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")};const L=new B;function A(e){if(!1===e.visible)return;if(e.isLight)v.lights.push(e);else if(e.isMesh||e.isLine||e.isPoints){if(!1===e.material.visible)return;if(!0===e.frustumCulled&&!1===V.intersectsObject(e))return;N(e)}else if(e.isSprite){if(!1===e.material.visible)return;if(!0===e.frustumCulled&&!1===V.intersectsSprite(e))return;N(e)}const t=e.children;for(let r=0,o=t.length;r<o;r++)A(t[r])}function N(e){n=U(),n.id=e.id,n.object=e,R.setFromMatrixPosition(e.matrixWorld),R.applyMatrix4(S),n.z=R.z,n.renderOrder=e.renderOrder,v.objects.push(n)}function F(e,t,r){const o=1/e.w;e.z*=o,e.z>=-1&&e.z<=1&&(f=Y(),f.id=t.id,f.x=e.x*o,f.y=e.y*o,f.z=e.z,f.renderOrder=t.renderOrder,f.object=t,f.rotation=t.rotation,f.scale.x=t.scale.x*Math.abs(f.x-(e.x+r.projectionMatrix.elements[0])/(e.w+r.projectionMatrix.elements[12])),f.scale.y=t.scale.y*Math.abs(f.y-(e.y+r.projectionMatrix.elements[5])/(e.w+r.projectionMatrix.elements[13])),f.material=t.material,v.elements.push(f))}function U(){if(s===E){const t=new e;return O.push(t),E++,s++,t}return O[s++]}function k(){if(c===y){const e=new r;return C.push(e),y++,c++,e}return C[c++]}function I(){if(p===x){const e=new t;return G.push(e),x++,p++,e}return G[p++]}function X(){if(h===g){const e=new o;return P.push(e),g++,h++,e}return P[h++]}function Y(){if(d===w){const e=new i;return W.push(e),w++,d++,e}return W[d++]}function Z(e,t){return e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.z!==t.z?t.z-e.z:e.id!==t.id?e.id-t.id:0}function D(e,t){let r=0,o=1;const i=e.z+e.w,n=t.z+t.w,s=-e.z+e.w,l=-t.z+t.w;return i>=0&&n>=0&&s>=0&&l>=0||!(i<0&&n<0||s<0&&l<0)&&(i<0?r=Math.max(r,i/(i-n)):n<0&&(o=Math.min(o,i/(i-n))),s<0?r=Math.max(r,s/(s-l)):l<0&&(o=Math.min(o,s/(s-l))),!(o<r)&&(e.lerp(t,r),t.lerp(e,1-o),!0))}this.projectScene=function(e,t,r,o){p=0,h=0,d=0,v.elements.length=0,!0===e.autoUpdate&&e.updateMatrixWorld(),null===t.parent&&t.updateMatrixWorld(),j.copy(t.matrixWorldInverse),S.multiplyMatrices(t.projectionMatrix,j),V.setFromProjectionMatrix(S),s=0,v.objects.length=0,v.lights.length=0,A(e),!0===r&&v.objects.sort(Z);const i=v.objects;for(let n=0,s=i.length;n<s;n++){const e=i[n].object,r=e.geometry;if(L.setObject(e),m=e.matrixWorld,c=0,e.isMesh){if(r.isBufferGeometry){let t=e.material;const o=Array.isArray(t),i=r.attributes,n=r.groups;if(void 0===i.position)continue;const s=i.position.array;for(let l=0,c=s.length;l<c;l+=3){let t=s[l],o=s[l+1],i=s[l+2];const n=r.morphAttributes.position;if(void 0!==n){const c=r.morphTargetsRelative,a=e.morphTargetInfluences;for(let e=0,r=n.length;e<r;e++){const r=a[e];if(0===r)continue;const p=n[e];c?(t+=p.getX(l/3)*r,o+=p.getY(l/3)*r,i+=p.getZ(l/3)*r):(t+=(p.getX(l/3)-s[l])*r,o+=(p.getY(l/3)-s[l+1])*r,i+=(p.getZ(l/3)-s[l+2])*r)}}L.pushVertex(t,o,i)}if(void 0!==i.normal){const e=i.normal.array;for(let t=0,r=e.length;t<r;t+=3)L.pushNormal(e[t],e[t+1],e[t+2])}if(void 0!==i.color){const e=i.color.array;for(let t=0,r=e.length;t<r;t+=3)L.pushColor(e[t],e[t+1],e[t+2])}if(void 0!==i.uv){const e=i.uv.array;for(let t=0,r=e.length;t<r;t+=2)L.pushUv(e[t],e[t+1])}if(null!==r.index){const i=r.index.array;if(n.length>0)for(let r=0;r<n.length;r++){const s=n[r];if(t=!0===o?e.material[s.materialIndex]:e.material,void 0!==t)for(let e=s.start,r=s.start+s.count;e<r;e+=3)L.pushTriangle(i[e],i[e+1],i[e+2],t)}else for(let e=0,r=i.length;e<r;e+=3)L.pushTriangle(i[e],i[e+1],i[e+2],t)}else if(n.length>0)for(let r=0;r<n.length;r++){const i=n[r];if(t=!0===o?e.material[i.materialIndex]:e.material,void 0!==t)for(let e=i.start,r=i.start+i.count;e<r;e+=3)L.pushTriangle(e,e+1,e+2,t)}else for(let e=0,r=s.length/3;e<r;e+=3)L.pushTriangle(e,e+1,e+2,t)}else if(r.isGeometry)return void console.error("THREE.Projector no longer supports Geometry. Use THREE.BufferGeometry instead.")}else if(e.isLine){if(z.multiplyMatrices(S,m),r.isBufferGeometry){const t=r.attributes;if(void 0!==t.position){const o=t.position.array;for(let e=0,t=o.length;e<t;e+=3)L.pushVertex(o[e],o[e+1],o[e+2]);if(void 0!==t.color){const e=t.color.array;for(let t=0,r=e.length;t<r;t+=3)L.pushColor(e[t],e[t+1],e[t+2])}if(null!==r.index){const e=r.index.array;for(let t=0,r=e.length;t<r;t+=2)L.pushLine(e[t],e[t+1])}else{const t=e.isLineSegments?2:1;for(let e=0,r=o.length/3-1;e<r;e+=t)L.pushLine(e,e+1)}}}else if(r.isGeometry)return void console.error("THREE.Projector no longer supports Geometry. Use THREE.BufferGeometry instead.")}else if(e.isPoints){if(z.multiplyMatrices(S,m),r.isGeometry)return void console.error("THREE.Projector no longer supports Geometry. Use THREE.BufferGeometry instead.");if(r.isBufferGeometry){const o=r.attributes;if(void 0!==o.position){const r=o.position.array;for(let o=0,i=r.length;o<i;o+=3)T.set(r[o],r[o+1],r[o+2],1),T.applyMatrix4(z),F(T,e,t)}}}else e.isSprite&&(e.modelViewMatrix.multiplyMatrices(t.matrixWorldInverse,e.matrixWorld),T.set(m.elements[12],m.elements[13],m.elements[14],1),T.applyMatrix4(S),F(T,e,t))}return!0===o&&v.elements.sort(Z),v}}}THREE.Projector=n,THREE.RenderableFace=t,THREE.RenderableLine=o,THREE.RenderableObject=e,THREE.RenderableSprite=i,THREE.RenderableVertex=r})();