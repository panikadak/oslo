(function(){class r{constructor(r=.1,e=6){this.maxEdgeLength=r,this.maxIterations=e}modify(r){if(!0===r.isGeometry)return console.error("THREE.TessellateModifier no longer supports Geometry. Use THREE.BufferGeometry instead."),r;null!==r.index&&(r=r.toNonIndexed());const e=this.maxIterations,t=this.maxEdgeLength*this.maxEdgeLength,o=new THREE.Vector3,s=new THREE.Vector3,n=new THREE.Vector3,E=new THREE.Vector3,l=[o,s,n,E],u=new THREE.Vector3,a=new THREE.Vector3,c=new THREE.Vector3,i=new THREE.Vector3,f=[u,a,c,i],y=new THREE.Color,p=new THREE.Color,T=new THREE.Color,H=new THREE.Color,R=[y,p,T,H],m=new THREE.Vector2,V=new THREE.Vector2,w=new THREE.Vector2,h=new THREE.Vector2,A=[m,V,w,h],x=new THREE.Vector2,d=new THREE.Vector2,b=new THREE.Vector2,v=new THREE.Vector2,z=[x,d,b,v],g=r.attributes,B=void 0!==g.normal,C=void 0!==g.color,F=void 0!==g.uv,G=void 0!==g.uv2;let q=g.position.array,I=B?g.normal.array:null,L=C?g.color.array:null,S=F?g.uv.array:null,M=G?g.uv2.array:null,N=q,U=I,j=L,k=S,D=M,J=0,K=!0;function O(r,e,t){const o=l[r],s=l[e],n=l[t];if(N.push(o.x,o.y,o.z),N.push(s.x,s.y,s.z),N.push(n.x,n.y,n.z),B){const o=f[r],s=f[e],n=f[t];U.push(o.x,o.y,o.z),U.push(s.x,s.y,s.z),U.push(n.x,n.y,n.z)}if(C){const o=R[r],s=R[e],n=R[t];j.push(o.x,o.y,o.z),j.push(s.x,s.y,s.z),j.push(n.x,n.y,n.z)}if(F){const o=A[r],s=A[e],n=A[t];k.push(o.x,o.y),k.push(s.x,s.y),k.push(n.x,n.y)}if(G){const o=z[r],s=z[e],n=z[t];D.push(o.x,o.y),D.push(s.x,s.y),D.push(n.x,n.y)}}while(K&&J<e){J++,K=!1,q=N,N=[],B&&(I=U,U=[]),C&&(L=j,j=[]),F&&(S=k,k=[]),G&&(M=D,D=[]);for(let r=0,e=0,l=q.length;r<l;r+=9,e+=6){o.fromArray(q,r+0),s.fromArray(q,r+3),n.fromArray(q,r+6),B&&(u.fromArray(I,r+0),a.fromArray(I,r+3),c.fromArray(I,r+6)),C&&(y.fromArray(L,r+0),p.fromArray(L,r+3),T.fromArray(L,r+6)),F&&(m.fromArray(S,e+0),V.fromArray(S,e+2),w.fromArray(S,e+4)),G&&(x.fromArray(M,e+0),d.fromArray(M,e+2),b.fromArray(M,e+4));const l=o.distanceToSquared(s),f=s.distanceToSquared(n),R=o.distanceToSquared(n);l>t||f>t||R>t?(K=!0,l>=f&&l>=R?(E.lerpVectors(o,s,.5),B&&i.lerpVectors(u,a,.5),C&&H.lerpColors(y,p,.5),F&&h.lerpVectors(m,V,.5),G&&v.lerpVectors(x,d,.5),O(0,3,2),O(3,1,2)):f>=l&&f>=R?(E.lerpVectors(s,n,.5),B&&i.lerpVectors(a,c,.5),C&&H.lerpColors(p,T,.5),F&&h.lerpVectors(V,w,.5),G&&v.lerpVectors(d,b,.5),O(0,1,3),O(3,2,0)):(E.lerpVectors(o,n,.5),B&&i.lerpVectors(u,c,.5),C&&H.lerpColors(y,T,.5),F&&h.lerpVectors(m,w,.5),G&&v.lerpVectors(x,b,.5),O(0,1,3),O(3,1,2))):O(0,1,2)}}const P=new THREE.BufferGeometry;return P.setAttribute("position",new THREE.Float32BufferAttribute(N,3)),B&&P.setAttribute("normal",new THREE.Float32BufferAttribute(U,3)),C&&P.setAttribute("color",new THREE.Float32BufferAttribute(j,3)),F&&P.setAttribute("uv",new THREE.Float32BufferAttribute(k,2)),G&&P.setAttribute("uv2",new THREE.Float32BufferAttribute(D,2)),P}}THREE.TessellateModifier=r})();