(function(){const e=3,t=1024,n=4;function r(r=1){const s=new Float32Array(t*n*r*e),i=new THREE.DataTexture(s,t,n*r,THREE.RGBFormat,THREE.FloatType);return i.wrapS=THREE.RepeatWrapping,i.wrapY=THREE.RepeatWrapping,i.magFilter=THREE.NearestFilter,i.needsUpdate=!0,i}function s(e,r,s=0){const a=Math.floor(t*(n/4));r.arcLengthDivisions=a/2,r.updateArcLengths();const o=r.getSpacedPoints(a),f=r.computeFrenetFrames(a,!0);for(let c=0;c<a;c++){const r=Math.floor(c/t),a=c%t;let l=o[c];i(e,a,l.x,l.y,l.z,0+r+n*s),l=f.tangents[c],i(e,a,l.x,l.y,l.z,1+r+n*s),l=f.normals[c],i(e,a,l.x,l.y,l.z,2+r+n*s),l=f.binormals[c],i(e,a,l.x,l.y,l.z,3+r+n*s)}e.needsUpdate=!0}function i(n,r,s,i,a,o){const f=n.image,{data:c}=f,l=e*t*o;c[r*e+l+0]=s,c[r*e+l+1]=i,c[r*e+l+2]=a}function a(e){const t={spineTexture:{value:e},pathOffset:{type:"f",value:0},pathSegment:{type:"f",value:1},spineOffset:{type:"f",value:161},spineLength:{type:"f",value:400},flow:{type:"i",value:1}};return t}function o(e,t,r=1){e.__ok||(e.__ok=!0,e.onBeforeCompile=e=>{if(e.__modified)return;e.__modified=!0,Object.assign(e.uniforms,t);const s=`\n\t\tuniform sampler2D spineTexture;\n\t\tuniform float pathOffset;\n\t\tuniform float pathSegment;\n\t\tuniform float spineOffset;\n\t\tuniform float spineLength;\n\t\tuniform int flow;\n\n\t\tfloat textureLayers = ${n*r}.;\n\t\tfloat textureStacks = ${n/4}.;\n\n\t\t${e.vertexShader}\n\t\t`.replace("#include <beginnormal_vertex>","").replace("#include <defaultnormal_vertex>","").replace("#include <begin_vertex>","").replace(/void\s*main\s*\(\)\s*\{/,`\nvoid main() {\n#include <beginnormal_vertex>\n\nvec4 worldPos = modelMatrix * vec4(position, 1.);\n\nbool bend = flow > 0;\nfloat xWeight = bend ? 0. : 1.;\n\n#ifdef USE_INSTANCING\nfloat pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\nfloat spineLengthFromInstanceMatrix = instanceMatrix[3][0];\nfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\nfloat mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\n#else\nfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\nfloat mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\n#endif\n\nmt = mod(mt, textureStacks);\nfloat rowOffset = floor(mt);\n\n#ifdef USE_INSTANCING\nrowOffset += instanceMatrix[3][1] * ${n}.;\n#endif\n\nvec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\nmat3 basis = mat3(a, b, c);\n\nvec3 transformed = basis\n\t* vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n\t+ spinePos;\n\nvec3 transformedNormal = normalMatrix * (basis * objectNormal);\n\t\t\t`).replace("#include <project_vertex>","vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;");e.vertexShader=s})}class f{constructor(e,t=1){const n=e.clone(),s=r(t),i=a(s);n.traverse((function(e){(e instanceof THREE.Mesh||e instanceof THREE.InstancedMesh)&&(e.material=e.material.clone(),o(e.material,i,t))})),this.curveArray=new Array(t),this.curveLengthArray=new Array(t),this.object3D=n,this.splineTexure=s,this.uniforms=i}updateCurve(e,t){if(e>=this.curveArray.length)throw Error("Index out of range for Flow");const n=t.getLength();this.uniforms.spineLength.value=n,this.curveLengthArray[e]=n,this.curveArray[e]=t,s(this.splineTexure,t,e)}moveAlongCurve(e){this.uniforms.pathOffset.value+=e}}const c=new THREE.Matrix4;class l extends f{constructor(e,t,n,r){const s=new THREE.InstancedMesh(n,r,e);s.instanceMatrix.setUsage(THREE.DynamicDrawUsage),super(s,t),this.offsets=new Array(e).fill(0),this.whichCurve=new Array(e).fill(0)}writeChanges(e){c.makeTranslation(this.curveLengthArray[this.whichCurve[e]],this.whichCurve[e],this.offsets[e]),this.object3D.setMatrixAt(e,c),this.object3D.instanceMatrix.needsUpdate=!0}moveIndividualAlongCurve(e,t){this.offsets[e]+=t,this.writeChanges(e)}setCurve(e,t){if(isNaN(t))throw Error("curve index being set is Not a Number (NaN)");this.whichCurve[e]=t,this.writeChanges(e)}}THREE.Flow=f,THREE.InstancedFlow=l,THREE.getUniforms=a,THREE.initSplineTexture=r,THREE.modifyShader=o,THREE.updateSplineTexture=s})();