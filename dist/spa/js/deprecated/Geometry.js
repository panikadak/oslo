(function(){const e=new THREE.Matrix4,t=new THREE.Object3D,s=new THREE.Vector3;class o extends THREE.EventDispatcher{constructor(){super(),this.uuid=THREE.MathUtils.generateUUID(),this.name="",this.type="Geometry",this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.elementsNeedUpdate=!1,this.verticesNeedUpdate=!1,this.uvsNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.lineDistancesNeedUpdate=!1,this.groupsNeedUpdate=!1}applyMatrix4(e){const t=(new THREE.Matrix3).getNormalMatrix(e);for(let s=0,o=this.vertices.length;s<o;s++){const t=this.vertices[s];t.applyMatrix4(e)}for(let s=0,o=this.faces.length;s<o;s++){const e=this.faces[s];e.normal.applyMatrix3(t).normalize();for(let s=0,o=e.vertexNormals.length;s<o;s++)e.vertexNormals[s].applyMatrix3(t).normalize()}return null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this.verticesNeedUpdate=!0,this.normalsNeedUpdate=!0,this}rotateX(t){return e.makeRotationX(t),this.applyMatrix4(e),this}rotateY(t){return e.makeRotationY(t),this.applyMatrix4(e),this}rotateZ(t){return e.makeRotationZ(t),this.applyMatrix4(e),this}translate(t,s,o){return e.makeTranslation(t,s,o),this.applyMatrix4(e),this}scale(t,s,o){return e.makeScale(t,s,o),this.applyMatrix4(e),this}lookAt(e){return t.lookAt(e),t.updateMatrix(),this.applyMatrix4(t.matrix),this}fromBufferGeometry(e){const t=this,s=null!==e.index?e.index:void 0,o=e.attributes;if(void 0===o.position)return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),this;const r=o.position,i=o.normal,l=o.color,a=o.uv,c=o.uv2;void 0!==c&&(this.faceVertexUvs[1]=[]);for(let n=0;n<r.count;n++)t.vertices.push((new THREE.Vector3).fromBufferAttribute(r,n)),void 0!==l&&t.colors.push((new THREE.Color).fromBufferAttribute(l,n));function h(e,s,o,r){const h=void 0===l?[]:[t.colors[e].clone(),t.colors[s].clone(),t.colors[o].clone()],u=void 0===i?[]:[(new THREE.Vector3).fromBufferAttribute(i,e),(new THREE.Vector3).fromBufferAttribute(i,s),(new THREE.Vector3).fromBufferAttribute(i,o)],p=new n(e,s,o,u,h,r);t.faces.push(p),void 0!==a&&t.faceVertexUvs[0].push([(new THREE.Vector2).fromBufferAttribute(a,e),(new THREE.Vector2).fromBufferAttribute(a,s),(new THREE.Vector2).fromBufferAttribute(a,o)]),void 0!==c&&t.faceVertexUvs[1].push([(new THREE.Vector2).fromBufferAttribute(c,e),(new THREE.Vector2).fromBufferAttribute(c,s),(new THREE.Vector2).fromBufferAttribute(c,o)])}const u=e.groups;if(u.length>0)for(let n=0;n<u.length;n++){const e=u[n],t=e.start,o=e.count;for(let r=t,n=t+o;r<n;r+=3)void 0!==s?h(s.getX(r),s.getX(r+1),s.getX(r+2),e.materialIndex):h(r,r+1,r+2,e.materialIndex)}else if(void 0!==s)for(let n=0;n<s.count;n+=3)h(s.getX(n),s.getX(n+1),s.getX(n+2));else for(let n=0;n<r.count;n+=3)h(n,n+1,n+2);return this.computeFaceNormals(),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(s).negate(),this.translate(s.x,s.y,s.z),this}normalize(){this.computeBoundingSphere();const e=this.boundingSphere.center,t=this.boundingSphere.radius,s=0===t?1:1/t,o=new THREE.Matrix4;return o.set(s,0,0,-s*e.x,0,s,0,-s*e.y,0,0,s,-s*e.z,0,0,0,1),this.applyMatrix4(o),this}computeFaceNormals(){const e=new THREE.Vector3,t=new THREE.Vector3;for(let s=0,o=this.faces.length;s<o;s++){const o=this.faces[s],r=this.vertices[o.a],n=this.vertices[o.b],i=this.vertices[o.c];e.subVectors(i,n),t.subVectors(r,n),e.cross(t),e.normalize(),o.normal.copy(e)}}computeVertexNormals(e=!0){const t=new Array(this.vertices.length);for(let s=0,o=this.vertices.length;s<o;s++)t[s]=new THREE.Vector3;if(e){const e=new THREE.Vector3,s=new THREE.Vector3;for(let o=0,r=this.faces.length;o<r;o++){const r=this.faces[o],n=this.vertices[r.a],i=this.vertices[r.b],l=this.vertices[r.c];e.subVectors(l,i),s.subVectors(n,i),e.cross(s),t[r.a].add(e),t[r.b].add(e),t[r.c].add(e)}}else{this.computeFaceNormals();for(let e=0,s=this.faces.length;e<s;e++){const s=this.faces[e];t[s.a].add(s.normal),t[s.b].add(s.normal),t[s.c].add(s.normal)}}for(let s=0,o=this.vertices.length;s<o;s++)t[s].normalize();for(let s=0,o=this.faces.length;s<o;s++){const e=this.faces[s],o=e.vertexNormals;3===o.length?(o[0].copy(t[e.a]),o[1].copy(t[e.b]),o[2].copy(t[e.c])):(o[0]=t[e.a].clone(),o[1]=t[e.b].clone(),o[2]=t[e.c].clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)}computeFlatVertexNormals(){this.computeFaceNormals();for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e],s=t.vertexNormals;3===s.length?(s[0].copy(t.normal),s[1].copy(t.normal),s[2].copy(t.normal)):(s[0]=t.normal.clone(),s[1]=t.normal.clone(),s[2]=t.normal.clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)}computeMorphNormals(){for(let t=0,s=this.faces.length;t<s;t++){const e=this.faces[t];e.__originalFaceNormal?e.__originalFaceNormal.copy(e.normal):e.__originalFaceNormal=e.normal.clone(),e.__originalVertexNormals||(e.__originalVertexNormals=[]);for(let t=0,s=e.vertexNormals.length;t<s;t++)e.__originalVertexNormals[t]?e.__originalVertexNormals[t].copy(e.vertexNormals[t]):e.__originalVertexNormals[t]=e.vertexNormals[t].clone()}const e=new o;e.faces=this.faces;for(let t=0,s=this.morphTargets.length;t<s;t++){if(!this.morphNormals[t]){this.morphNormals[t]={},this.morphNormals[t].faceNormals=[],this.morphNormals[t].vertexNormals=[];const e=this.morphNormals[t].faceNormals,s=this.morphNormals[t].vertexNormals;for(let t=0,o=this.faces.length;t<o;t++){const t=new THREE.Vector3,o={a:new THREE.Vector3,b:new THREE.Vector3,c:new THREE.Vector3};e.push(t),s.push(o)}}const s=this.morphNormals[t];e.vertices=this.morphTargets[t].vertices,e.computeFaceNormals(),e.computeVertexNormals();for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e],o=s.faceNormals[e],r=s.vertexNormals[e];o.copy(t.normal),r.a.copy(t.vertexNormals[0]),r.b.copy(t.vertexNormals[1]),r.c.copy(t.vertexNormals[2])}}for(let t=0,s=this.faces.length;t<s;t++){const e=this.faces[t];e.normal=e.__originalFaceNormal,e.vertexNormals=e.__originalVertexNormals}}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new THREE.Box3),this.boundingBox.setFromPoints(this.vertices)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new THREE.Sphere),this.boundingSphere.setFromPoints(this.vertices)}merge(e,t,s=0){if(!e||!e.isGeometry)return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",e);let o;const r=this.vertices.length,i=this.vertices,l=e.vertices,a=this.faces,c=e.faces,h=this.colors,u=e.colors;void 0!==t&&(o=(new THREE.Matrix3).getNormalMatrix(t));for(let n=0,p=l.length;n<p;n++){const e=l[n],s=e.clone();void 0!==t&&s.applyMatrix4(t),i.push(s)}for(let n=0,p=u.length;n<p;n++)h.push(u[n].clone());for(let p=0,m=c.length;p<m;p++){const e=c[p];let t,i;const l=e.vertexNormals,h=e.vertexColors,u=new n(e.a+r,e.b+r,e.c+r);u.normal.copy(e.normal),void 0!==o&&u.normal.applyMatrix3(o).normalize();for(let s=0,r=l.length;s<r;s++)t=l[s].clone(),void 0!==o&&t.applyMatrix3(o).normalize(),u.vertexNormals.push(t);u.color.copy(e.color);for(let s=0,o=h.length;s<o;s++)i=h[s],u.vertexColors.push(i.clone());u.materialIndex=e.materialIndex+s,a.push(u)}for(let n=0,p=e.faceVertexUvs.length;n<p;n++){const t=e.faceVertexUvs[n];void 0===this.faceVertexUvs[n]&&(this.faceVertexUvs[n]=[]);for(let e=0,s=t.length;e<s;e++){const s=t[e],o=[];for(let e=0,t=s.length;e<t;e++)o.push(s[e].clone());this.faceVertexUvs[n].push(o)}}}mergeMesh(e){e&&e.isMesh?(e.matrixAutoUpdate&&e.updateMatrix(),this.merge(e.geometry,e.matrix)):console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",e)}mergeVertices(e=4){const t={},s=[],o=[],r=Math.pow(10,e);for(let l=0,a=this.vertices.length;l<a;l++){const e=this.vertices[l],n=Math.round(e.x*r)+"_"+Math.round(e.y*r)+"_"+Math.round(e.z*r);void 0===t[n]?(t[n]=l,s.push(this.vertices[l]),o[l]=s.length-1):o[l]=o[t[n]]}const n=[];for(let l=0,a=this.faces.length;l<a;l++){const e=this.faces[l];e.a=o[e.a],e.b=o[e.b],e.c=o[e.c];const t=[e.a,e.b,e.c];for(let s=0;s<3;s++)if(t[s]===t[(s+1)%3]){n.push(l);break}}for(let l=n.length-1;l>=0;l--){const e=n[l];this.faces.splice(e,1);for(let t=0,s=this.faceVertexUvs.length;t<s;t++)this.faceVertexUvs[t].splice(e,1)}const i=this.vertices.length-s.length;return this.vertices=s,i}setFromPoints(e){this.vertices=[];for(let t=0,s=e.length;t<s;t++){const s=e[t];this.vertices.push(new THREE.Vector3(s.x,s.y,s.z||0))}return this}sortFacesByMaterialIndex(){const e=this.faces,t=e.length;for(let l=0;l<t;l++)e[l]._id=l;function s(e,t){return e.materialIndex-t.materialIndex}e.sort(s);const o=this.faceVertexUvs[0],r=this.faceVertexUvs[1];let n,i;o&&o.length===t&&(n=[]),r&&r.length===t&&(i=[]);for(let l=0;l<t;l++){const t=e[l]._id;n&&n.push(o[t]),i&&i.push(r[t])}n&&(this.faceVertexUvs[0]=n),i&&(this.faceVertexUvs[1]=i)}toJSON(){const e={metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),void 0!==this.parameters){const t=this.parameters;for(const s in t)void 0!==t[s]&&(e[s]=t[s]);return e}const t=[];for(let m=0;m<this.vertices.length;m++){const e=this.vertices[m];t.push(e.x,e.y,e.z)}const s=[],o=[],r={},n=[],i={},l=[],a={};for(let m=0;m<this.faces.length;m++){const e=this.faces[m],t=!0,o=!1,r=void 0!==this.faceVertexUvs[0][m],n=e.normal.length()>0,i=e.vertexNormals.length>0,l=1!==e.color.r||1!==e.color.g||1!==e.color.b,a=e.vertexColors.length>0;let f=0;if(f=c(f,0,0),f=c(f,1,t),f=c(f,2,o),f=c(f,3,r),f=c(f,4,n),f=c(f,5,i),f=c(f,6,l),f=c(f,7,a),s.push(f),s.push(e.a,e.b,e.c),s.push(e.materialIndex),r){const e=this.faceVertexUvs[0][m];s.push(p(e[0]),p(e[1]),p(e[2]))}if(n&&s.push(h(e.normal)),i){const t=e.vertexNormals;s.push(h(t[0]),h(t[1]),h(t[2]))}if(l&&s.push(u(e.color)),a){const t=e.vertexColors;s.push(u(t[0]),u(t[1]),u(t[2]))}}function c(e,t,s){return s?e|1<<t:e&~(1<<t)}function h(e){const t=e.x.toString()+e.y.toString()+e.z.toString();return void 0!==r[t]||(r[t]=o.length/3,o.push(e.x,e.y,e.z)),r[t]}function u(e){const t=e.r.toString()+e.g.toString()+e.b.toString();return void 0!==i[t]||(i[t]=n.length,n.push(e.getHex())),i[t]}function p(e){const t=e.x.toString()+e.y.toString();return void 0!==a[t]||(a[t]=l.length/2,l.push(e.x,e.y)),a[t]}return e.data={},e.data.vertices=t,e.data.normals=o,n.length>0&&(e.data.colors=n),l.length>0&&(e.data.uvs=[l]),e.data.faces=s,e}clone(){return(new o).copy(this)}copy(e){this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.name=e.name;const t=e.vertices;for(let u=0,p=t.length;u<p;u++)this.vertices.push(t[u].clone());const s=e.colors;for(let u=0,p=s.length;u<p;u++)this.colors.push(s[u].clone());const o=e.faces;for(let u=0,p=o.length;u<p;u++)this.faces.push(o[u].clone());for(let u=0,p=e.faceVertexUvs.length;u<p;u++){const t=e.faceVertexUvs[u];void 0===this.faceVertexUvs[u]&&(this.faceVertexUvs[u]=[]);for(let e=0,s=t.length;e<s;e++){const s=t[e],o=[];for(let e=0,t=s.length;e<t;e++){const t=s[e];o.push(t.clone())}this.faceVertexUvs[u].push(o)}}const r=e.morphTargets;for(let u=0,p=r.length;u<p;u++){const e={};if(e.name=r[u].name,void 0!==r[u].vertices){e.vertices=[];for(let t=0,s=r[u].vertices.length;t<s;t++)e.vertices.push(r[u].vertices[t].clone())}if(void 0!==r[u].normals){e.normals=[];for(let t=0,s=r[u].normals.length;t<s;t++)e.normals.push(r[u].normals[t].clone())}this.morphTargets.push(e)}const n=e.morphNormals;for(let u=0,p=n.length;u<p;u++){const e={};if(void 0!==n[u].vertexNormals){e.vertexNormals=[];for(let t=0,s=n[u].vertexNormals.length;t<s;t++){const s=n[u].vertexNormals[t],o={};o.a=s.a.clone(),o.b=s.b.clone(),o.c=s.c.clone(),e.vertexNormals.push(o)}}if(void 0!==n[u].faceNormals){e.faceNormals=[];for(let t=0,s=n[u].faceNormals.length;t<s;t++)e.faceNormals.push(n[u].faceNormals[t].clone())}this.morphNormals.push(e)}const i=e.skinWeights;for(let u=0,p=i.length;u<p;u++)this.skinWeights.push(i[u].clone());const l=e.skinIndices;for(let u=0,p=l.length;u<p;u++)this.skinIndices.push(l[u].clone());const a=e.lineDistances;for(let u=0,p=a.length;u<p;u++)this.lineDistances.push(a[u]);const c=e.boundingBox;null!==c&&(this.boundingBox=c.clone());const h=e.boundingSphere;return null!==h&&(this.boundingSphere=h.clone()),this.elementsNeedUpdate=e.elementsNeedUpdate,this.verticesNeedUpdate=e.verticesNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.lineDistancesNeedUpdate=e.lineDistancesNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,this}toBufferGeometry(){const e=(new r).fromGeometry(this),t=new THREE.BufferGeometry,s=new Float32Array(3*e.vertices.length);if(t.setAttribute("position",new THREE.BufferAttribute(s,3).copyVector3sArray(e.vertices)),e.normals.length>0){const s=new Float32Array(3*e.normals.length);t.setAttribute("normal",new THREE.BufferAttribute(s,3).copyVector3sArray(e.normals))}if(e.colors.length>0){const s=new Float32Array(3*e.colors.length);t.setAttribute("color",new THREE.BufferAttribute(s,3).copyColorsArray(e.colors))}if(e.uvs.length>0){const s=new Float32Array(2*e.uvs.length);t.setAttribute("uv",new THREE.BufferAttribute(s,2).copyVector2sArray(e.uvs))}if(e.uvs2.length>0){const s=new Float32Array(2*e.uvs2.length);t.setAttribute("uv2",new THREE.BufferAttribute(s,2).copyVector2sArray(e.uvs2))}t.groups=e.groups;for(const o in e.morphTargets){const s=[],r=e.morphTargets[o];for(let e=0,t=r.length;e<t;e++){const t=r[e],o=new THREE.Float32BufferAttribute(3*t.data.length,3);o.name=t.name,s.push(o.copyVector3sArray(t.data))}t.morphAttributes[o]=s}if(e.skinIndices.length>0){const s=new THREE.Float32BufferAttribute(4*e.skinIndices.length,4);t.setAttribute("skinIndex",s.copyVector4sArray(e.skinIndices))}if(e.skinWeights.length>0){const s=new THREE.Float32BufferAttribute(4*e.skinWeights.length,4);t.setAttribute("skinWeight",s.copyVector4sArray(e.skinWeights))}return null!==e.boundingSphere&&(t.boundingSphere=e.boundingSphere.clone()),null!==e.boundingBox&&(t.boundingBox=e.boundingBox.clone()),t}computeTangents(){console.error("THREE.Geometry: .computeTangents() has been removed.")}computeLineDistances(){console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")}applyMatrix(e){return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}dispose(){this.dispatchEvent({type:"dispose"})}static createBufferGeometryFromObject(e){let t=new THREE.BufferGeometry;const s=e.geometry;if(e.isPoints||e.isLine){const e=new THREE.Float32BufferAttribute(3*s.vertices.length,3),o=new THREE.Float32BufferAttribute(3*s.colors.length,3);if(t.setAttribute("position",e.copyVector3sArray(s.vertices)),t.setAttribute("color",o.copyColorsArray(s.colors)),s.lineDistances&&s.lineDistances.length===s.vertices.length){const e=new THREE.Float32BufferAttribute(s.lineDistances.length,1);t.setAttribute("lineDistance",e.copyArray(s.lineDistances))}null!==s.boundingSphere&&(t.boundingSphere=s.boundingSphere.clone()),null!==s.boundingBox&&(t.boundingBox=s.boundingBox.clone())}else e.isMesh&&(t=s.toBufferGeometry());return t}}o.prototype.isGeometry=!0;class r{constructor(){this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.uvs2=[],this.groups=[],this.morphTargets={},this.skinWeights=[],this.skinIndices=[],this.boundingBox=null,this.boundingSphere=null,this.verticesNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.uvsNeedUpdate=!1,this.groupsNeedUpdate=!1}computeGroups(e){const t=[];let s,o,r;const n=e.faces;for(o=0;o<n.length;o++){const e=n[o];e.materialIndex!==r&&(r=e.materialIndex,void 0!==s&&(s.count=3*o-s.start,t.push(s)),s={start:3*o,materialIndex:r})}void 0!==s&&(s.count=3*o-s.start,t.push(s)),this.groups=t}fromGeometry(e){const t=e.faces,s=e.vertices,o=e.faceVertexUvs,r=o[0]&&o[0].length>0,n=o[1]&&o[1].length>0,i=e.morphTargets,l=i.length;let a;if(l>0){a=[];for(let e=0;e<l;e++)a[e]={name:i[e].name,data:[]};this.morphTargets.position=a}const c=e.morphNormals,h=c.length;let u;if(h>0){u=[];for(let e=0;e<h;e++)u[e]={name:c[e].name,data:[]};this.morphTargets.normal=u}const p=e.skinIndices,m=e.skinWeights,f=p.length===s.length,d=m.length===s.length;s.length>0&&0===t.length&&console.error("THREE.DirectGeometry: Faceless geometries are not supported.");for(let g=0;g<t.length;g++){const e=t[g];this.vertices.push(s[e.a],s[e.b],s[e.c]);const v=e.vertexNormals;if(3===v.length)this.normals.push(v[0],v[1],v[2]);else{const t=e.normal;this.normals.push(t,t,t)}const x=e.vertexColors;if(3===x.length)this.colors.push(x[0],x[1],x[2]);else{const t=e.color;this.colors.push(t,t,t)}if(!0===r){const e=o[0][g];void 0!==e?this.uvs.push(e[0],e[1],e[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",g),this.uvs.push(new THREE.Vector2,new THREE.Vector2,new THREE.Vector2))}if(!0===n){const e=o[1][g];void 0!==e?this.uvs2.push(e[0],e[1],e[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",g),this.uvs2.push(new THREE.Vector2,new THREE.Vector2,new THREE.Vector2))}for(let t=0;t<l;t++){const s=i[t].vertices;a[t].data.push(s[e.a],s[e.b],s[e.c])}for(let t=0;t<h;t++){const e=c[t].vertexNormals[g];u[t].data.push(e.a,e.b,e.c)}f&&this.skinIndices.push(p[e.a],p[e.b],p[e.c]),d&&this.skinWeights.push(m[e.a],m[e.b],m[e.c])}return this.computeGroups(e),this.verticesNeedUpdate=e.verticesNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),this}}class n{constructor(e,t,s,o,r,n=0){this.a=e,this.b=t,this.c=s,this.normal=o&&o.isVector3?o:new THREE.Vector3,this.vertexNormals=Array.isArray(o)?o:[],this.color=r&&r.isColor?r:new THREE.Color,this.vertexColors=Array.isArray(r)?r:[],this.materialIndex=n}clone(){return(new this.constructor).copy(this)}copy(e){this.a=e.a,this.b=e.b,this.c=e.c,this.normal.copy(e.normal),this.color.copy(e.color),this.materialIndex=e.materialIndex;for(let t=0,s=e.vertexNormals.length;t<s;t++)this.vertexNormals[t]=e.vertexNormals[t].clone();for(let t=0,s=e.vertexColors.length;t<s;t++)this.vertexColors[t]=e.vertexColors[t].clone();return this}}THREE.Face3=n,THREE.Geometry=o})();