(function(){const e=new WeakMap;class t extends THREE.Loader{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,t,r,o){const s=new THREE.FileLoader(this.manager);s.setPath(this.path),s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(e,(e=>{const r={attributeIDs:this.defaultAttributeIDs,attributeTypes:this.defaultAttributeTypes,useUniqueIDs:!1};this.decodeGeometry(e,r).then(t).catch(o)}),r,o)}decodeDracoFile(e,t,r,o){const s={attributeIDs:r||this.defaultAttributeIDs,attributeTypes:o||this.defaultAttributeTypes,useUniqueIDs:!!r};this.decodeGeometry(e,s).then(t)}decodeGeometry(t,r){for(const e in r.attributeTypes){const t=r.attributeTypes[e];void 0!==t.BYTES_PER_ELEMENT&&(r.attributeTypes[e]=t.name)}const o=JSON.stringify(r);if(e.has(t)){const r=e.get(t);if(r.key===o)return r.promise;if(0===t.byteLength)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let s;const i=this.workerNextTaskID++,n=t.byteLength,a=this._getWorker(i,n).then((e=>(s=e,new Promise(((e,o)=>{s._callbacks[i]={resolve:e,reject:o},s.postMessage({type:"decode",id:i,taskConfig:r,buffer:t},[t])}))))).then((e=>this._createGeometry(e.geometry)));return a.catch((()=>!0)).then((()=>{s&&i&&this._releaseTask(s,i)})),e.set(t,{key:o,promise:a}),a}_createGeometry(e){const t=new THREE.BufferGeometry;e.index&&t.setIndex(new THREE.BufferAttribute(e.index.array,1));for(let r=0;r<e.attributes.length;r++){const o=e.attributes[r],s=o.name,i=o.array,n=o.itemSize;t.setAttribute(s,new THREE.BufferAttribute(i,n))}return t}_loadLibrary(e,t){const r=new THREE.FileLoader(this.manager);return r.setPath(this.decoderPath),r.setResponseType(t),r.setWithCredentials(this.withCredentials),new Promise(((t,o)=>{r.load(e,t,void 0,o)}))}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e="object"!==typeof WebAssembly||"js"===this.decoderConfig.type,t=[];return e?t.push(this._loadLibrary("draco_decoder.js","text")):(t.push(this._loadLibrary("draco_wasm_wrapper.js","text")),t.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(t).then((t=>{const o=t[0];e||(this.decoderConfig.wasmBinary=t[1]);const s=r.toString(),i=["/* draco decoder */",o,"","/* worker */",s.substring(s.indexOf("{")+1,s.lastIndexOf("}"))].join("\n");this.workerSourceURL=URL.createObjectURL(new Blob([i]))})),this.decoderPending}_getWorker(e,t){return this._initDecoder().then((()=>{if(this.workerPool.length<this.workerLimit){const e=new Worker(this.workerSourceURL);e._callbacks={},e._taskCosts={},e._taskLoad=0,e.postMessage({type:"init",decoderConfig:this.decoderConfig}),e.onmessage=function(t){const r=t.data;switch(r.type){case"decode":e._callbacks[r.id].resolve(r);break;case"error":e._callbacks[r.id].reject(r);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+r.type+'"')}},this.workerPool.push(e)}else this.workerPool.sort((function(e,t){return e._taskLoad>t._taskLoad?-1:1}));const r=this.workerPool[this.workerPool.length-1];return r._taskCosts[e]=t,r._taskLoad+=t,r}))}_releaseTask(e,t){e._taskLoad-=e._taskCosts[t],delete e._callbacks[t],delete e._taskCosts[t]}debug(){console.log("Task load: ",this.workerPool.map((e=>e._taskLoad)))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this}}function r(){let e,t;function r(e,t,r,i){const n=i.attributeIDs,a=i.attributeTypes;let d,c;const u=t.GetEncodedGeometryType(r);if(u===e.TRIANGULAR_MESH)d=new e.Mesh,c=t.DecodeBufferToMesh(r,d);else{if(u!==e.POINT_CLOUD)throw new Error("THREE.DRACOLoader: Unexpected geometry type.");d=new e.PointCloud,c=t.DecodeBufferToPointCloud(r,d)}if(!c.ok()||0===d.ptr)throw new Error("THREE.DRACOLoader: Decoding failed: "+c.error_msg());const l={index:null,attributes:[]};for(const o in n){const r=self[a[o]];let c,u;if(i.useUniqueIDs)u=n[o],c=t.GetAttributeByUniqueId(d,u);else{if(u=t.GetAttributeId(d,e[n[o]]),-1===u)continue;c=t.GetAttribute(d,u)}l.attributes.push(s(e,t,d,o,r,c))}return u===e.TRIANGULAR_MESH&&(l.index=o(e,t,d)),e.destroy(d),l}function o(e,t,r){const o=r.num_faces(),s=3*o,i=4*s,n=e._malloc(i);t.GetTrianglesUInt32Array(r,i,n);const a=new Uint32Array(e.HEAPF32.buffer,n,s).slice();return e._free(n),{array:a,itemSize:1}}function s(e,t,r,o,s,n){const a=n.num_components(),d=r.num_points(),c=d*a,u=c*s.BYTES_PER_ELEMENT,l=i(e,s),h=e._malloc(u);t.GetAttributeDataArrayForAllPoints(r,n,l,u,h);const f=new s(e.HEAPF32.buffer,h,c).slice();return e._free(h),{name:o,array:f,itemSize:a}}function i(e,t){switch(t){case Float32Array:return e.DT_FLOAT32;case Int8Array:return e.DT_INT8;case Int16Array:return e.DT_INT16;case Int32Array:return e.DT_INT32;case Uint8Array:return e.DT_UINT8;case Uint16Array:return e.DT_UINT16;case Uint32Array:return e.DT_UINT32}}onmessage=function(o){const s=o.data;switch(s.type){case"init":e=s.decoderConfig,t=new Promise((function(t){e.onModuleLoaded=function(e){t({draco:e})},DracoDecoderModule(e)}));break;case"decode":const o=s.buffer,i=s.taskConfig;t.then((e=>{const t=e.draco,n=new t.Decoder,a=new t.DecoderBuffer;a.Init(new Int8Array(o),o.byteLength);try{const e=r(t,n,a,i),o=e.attributes.map((e=>e.array.buffer));e.index&&o.push(e.index.array.buffer),self.postMessage({type:"decode",id:s.id,geometry:e},o)}catch(d){console.error(d),self.postMessage({type:"error",id:s.id,error:d.message})}finally{t.destroy(a),t.destroy(n)}}));break}}}THREE.DRACOLoader=t})();