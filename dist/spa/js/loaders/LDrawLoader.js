(function(){const t=0,e=1,r=2,n=3,a=4,o=5,i=0,s=1,l=2,c=3,u=4,h=5,d=6,p=new THREE.Vector3,g=new THREE.Vector3;class m extends THREE.ShaderMaterial{constructor(t){super({uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.fog,{diffuse:{value:new THREE.Color},opacity:{value:1}}]),vertexShader:"\n\t\t\t\tattribute vec3 control0;\n\t\t\t\tattribute vec3 control1;\n\t\t\t\tattribute vec3 direction;\n\t\t\t\tvarying float discardFlag;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <color_pars_vertex>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <color_vertex>\n\n\t\t\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\t// Transform the line segment ends and control points into camera clip space\n\t\t\t\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\t\t\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\t\t\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\t\t\t\tc0.xy /= c0.w;\n\t\t\t\t\tc1.xy /= c1.w;\n\t\t\t\t\tp0.xy /= p0.w;\n\t\t\t\t\tp1.xy /= p1.w;\n\n\t\t\t\t\t// Get the direction of the segment and an orthogonal vector\n\t\t\t\t\tvec2 dir = p1.xy - p0.xy;\n\t\t\t\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t\t\t\t// Get control point directions from the line\n\t\t\t\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\t\t\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t\t\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t\t\t\t// from the line segment then the line should not be drawn.\n\t\t\t\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\t\t\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\t\t\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\t\t\tuniform vec3 diffuse;\n\t\t\tuniform float opacity;\n\t\t\tvarying float discardFlag;\n\n\t\t\t#include <common>\n\t\t\t#include <color_pars_fragment>\n\t\t\t#include <fog_pars_fragment>\n\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t#include <clipping_planes_pars_fragment>\n\t\t\tvoid main() {\n\n\t\t\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t\t\t#include <clipping_planes_fragment>\n\t\t\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t#include <color_fragment>\n\t\t\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t#include <encodings_fragment>\n\t\t\t\t#include <fog_fragment>\n\t\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t}\n\t\t\t"}),Object.defineProperties(this,{opacity:{get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}},color:{get:function(){return this.uniforms.diffuse.value}}}),this.setValues(t),this.isLDrawConditionalLineMaterial=!0}}function f(t,e){function r(t){const e=~~(100*t.x),r=~~(100*t.y),n=~~(100*t.z);return`${e},${r},${n}`}function n(t,e){return`${r(t)}_${r(e)}`}const a=new Set,o={},i=[];for(let s=0,l=e.length;s<l;s++){const t=e[s],r=t.vertices,o=r[0],i=r[1];a.add(n(o,i)),a.add(n(i,o))}for(let s=0,l=t.length;s<l;s++){const e=t[s],r=e.vertices,i=r.length;for(let t=0;t<i;t++){const s=t,l=(t+1)%i,c=r[s],u=r[l],h=n(c,u);if(a.has(h))continue;const d={index:s,tri:e};o[h]=d}}while(1){let t=null;for(const r in o){t=o[r];break}if(null===t)break;const e=[t];while(e.length>0){const t=e.pop().tri,r=t.vertices,a=t.normals,s=t.faceNormal,l=r.length;for(let c=0;c<l;c++){const u=c,h=(c+1)%l,d=r[u],p=r[h],g=n(d,p);delete o[g];const m=n(p,d),f=o[m];if(f){const r=f.tri,n=f.index,l=r.normals,c=l.length,d=r.faceNormal;if(Math.abs(r.faceNormal.dot(t.faceNormal))<.25)continue;m in o&&(e.push(f),delete o[m]);const p=(n+1)%c;a[u]&&l[p]&&a[u]!==l[p]&&(l[p].norm.add(a[u].norm),a[u].norm=l[p].norm);let g=a[u]||l[p];null===g&&(g={norm:new THREE.Vector3},i.push(g.norm)),null===a[u]&&(a[u]=g,g.norm.add(s)),null===l[p]&&(l[p]=g,g.norm.add(d)),a[h]&&l[n]&&a[h]!==l[n]&&(l[n].norm.add(a[h].norm),a[h].norm=l[n].norm);let b=a[h]||l[n];null===b&&(b={norm:new THREE.Vector3},i.push(b.norm)),null===a[h]&&(a[h]=b,b.norm.add(s)),null===l[n]&&(l[n]=b,b.norm.add(d))}}}}for(let s=0,l=i.length;s<l;s++)i[s].normalize()}function b(t){return"Part"===t}function E(t){return"Model"===t||"Unofficial_Model"===t}function w(t){return/primitive/i.test(t)||"Subpart"===t}class C{constructor(t,e){this.line=t,this.lineLength=t.length,this.currentCharIndex=0,this.currentChar=" ",this.lineNumber=e}seekNonSpace(){while(this.currentCharIndex<this.lineLength){if(this.currentChar=this.line.charAt(this.currentCharIndex)," "!==this.currentChar&&"\t"!==this.currentChar)return;this.currentCharIndex++}}getToken(){const t=this.currentCharIndex++;while(this.currentCharIndex<this.lineLength){if(this.currentChar=this.line.charAt(this.currentCharIndex)," "===this.currentChar||"\t"===this.currentChar)break;this.currentCharIndex++}const e=this.currentCharIndex;return this.seekNonSpace(),this.line.substring(t,e)}getRemainingString(){return this.line.substring(this.currentCharIndex,this.lineLength)}isAtTheEnd(){return this.currentCharIndex>=this.lineLength}setToEnd(){this.currentCharIndex=this.lineLength}getLineNumberString(){return this.lineNumber>=0?" at line "+this.lineNumber:""}}class x{constructor(t){this.cache={},this.loader=t}setData(t,e){this.cache[t.toLowerCase()]=e}async loadData(t){const e=t.toLowerCase();return e in this.cache?this.cache[e]:(this.cache[t]=new Promise((async(e,r)=>{let n=!1,a=i;while(a!==d){let r=t;switch(a){case i:a+=1;break;case s:r="parts/"+r,a+=1;break;case l:r="p/"+r,a+=1;break;case c:r="models/"+r,a+=1;break;case u:r=t.substring(0,t.lastIndexOf("/")+1)+r,a+=1;break;case h:n?a=d:(t=t.toLowerCase(),r=t,n=!0,a=i);break}const o=this.loader,p=new THREE.FileLoader(o.manager);p.setPath(o.partsLibraryPath),p.setRequestHeader(o.requestHeader),p.setWithCredentials(o.withCredentials);try{const n=await p.loadAsync(r);return this.setData(t,n),void e(n)}catch{continue}}r()})),this.cache[t])}}function v(t,e){return t.colourCode===e.colourCode?0:t.colourCode<e.colourCode?-1:1}function k(t,e,r=!1,n=null){t.sort(v),null===n&&(n=t.length);const a=new Float32Array(e*n*3),o=3===e?new Float32Array(e*n*3):null,i=[],s=new Array(6),l=new THREE.BufferGeometry;let c=null,u=0,h=0,d=0;for(let g=0,m=t.length;g<m;g++){const r=t[g];let n=r.vertices;4===n.length&&(s[0]=n[0],s[1]=n[1],s[2]=n[2],s[3]=n[0],s[4]=n[2],s[5]=n[3],n=s);for(let t=0,e=n.length;t<e;t++){const e=n[t],r=d+3*t;a[r+0]=e.x,a[r+1]=e.y,a[r+2]=e.z}if(3===e){let t=r.normals;4===t.length&&(s[0]=t[0],s[1]=t[1],s[2]=t[2],s[3]=t[0],s[4]=t[2],s[5]=t[3],t=s);for(let e=0,n=t.length;e<n;e++){let n=r.faceNormal;t[e]&&(n=t[e].norm);const a=d+3*e;o[a+0]=n.x,o[a+1]=n.y,o[a+2]=n.z}}c!==r.material?(null!==c&&l.addGroup(u,h,i.length-1),i.push(r.material),c=r.material,u=d/3,h=n.length):h+=n.length,d+=3*n.length}h>0&&l.addGroup(u,1/0,i.length-1),l.setAttribute("position",new THREE.BufferAttribute(a,3)),null!==o&&l.setAttribute("normal",new THREE.BufferAttribute(o,3));let p=null;if(2===e?p=new THREE.LineSegments(l,1===i.length?i[0]:i):3===e&&(p=new THREE.Mesh(l,1===i.length?i[0]:i)),r){p.isConditionalLine=!0;const e=new Float32Array(3*t.length*2),r=new Float32Array(3*t.length*2),n=new Float32Array(3*t.length*2);for(let a=0,o=t.length;a<o;a++){const o=t[a],i=o.vertices,s=o.controlPoints,l=s[0],c=s[1],u=i[0],h=i[1],d=3*a*2;e[d+0]=l.x,e[d+1]=l.y,e[d+2]=l.z,e[d+3]=l.x,e[d+4]=l.y,e[d+5]=l.z,r[d+0]=c.x,r[d+1]=c.y,r[d+2]=c.z,r[d+3]=c.x,r[d+4]=c.y,r[d+5]=c.z,n[d+0]=h.x-u.x,n[d+1]=h.y-u.y,n[d+2]=h.z-u.z,n[d+3]=h.x-u.x,n[d+4]=h.y-u.y,n[d+5]=h.z-u.z}l.setAttribute("control0",new THREE.BufferAttribute(e,3,!1)),l.setAttribute("control1",new THREE.BufferAttribute(r,3,!1)),l.setAttribute("direction",new THREE.BufferAttribute(n,3,!1))}return p}class M extends THREE.Loader{constructor(t){super(t),this.materials=[],this.cache=new x(this),this.fileMap=null,this.rootParseScope=this.newParseScopeLevel(),this.setMaterials([this.parseColourMetaDirective(new C("Main_Colour CODE 16 VALUE #FF8080 EDGE #333333")),this.parseColourMetaDirective(new C("Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333"))]),this.separateObjects=!1,this.smoothNormals=!0,this.partsLibraryPath=""}setPartsLibraryPath(t){return this.partsLibraryPath=t,this}async preloadMaterials(t){const e=new THREE.FileLoader(this.manager);e.setPath(this.path),e.setRequestHeader(this.requestHeader),e.setWithCredentials(this.withCredentials);const r=await e.loadAsync(t),n=/^0 !COLOUR/,a=r.split(/[\n\r]/g),o=[];for(let i=0,s=a.length;i<s;i++){const t=a[i];if(n.test(t)){const e=t.replace(n,""),r=this.parseColourMetaDirective(new C(e));o.push(r)}}this.setMaterials(o)}load(t,e,r,n){this.fileMap||(this.fileMap={});const a=new THREE.FileLoader(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,(r=>{this.processObject(r,null,t,this.rootParseScope).then((function(t){e(t.groupObject)}))}),r,n)}parse(t,e,r){this.processObject(t,null,e,this.rootParseScope).then((function(t){r(t.groupObject)}))}setMaterials(t){return this.rootParseScope=this.newParseScopeLevel(t),this.rootParseScope.isFromParse=!1,this.materials=t,this}setFileMap(t){return this.fileMap=t,this}newParseScopeLevel(t=null,e=null){const r={};if(t)for(let a=0,o=t.length;a<o;a++){const e=t[a];r[e.userData.code]=e}const n={parentScope:e,lib:r,url:null,subobjects:null,numSubobjects:0,subobjectIndex:0,inverted:!1,category:null,keywords:null,currentFileName:null,mainColourCode:e?e.mainColourCode:"16",mainEdgeColourCode:e?e.mainEdgeColourCode:"24",currentMatrix:new THREE.Matrix4,matrix:new THREE.Matrix4,type:"Model",groupObject:null,isFromParse:!0,faces:[],lineSegments:[],conditionalSegments:[],totalFaces:0,startingConstructionStep:!1};return n}addMaterial(t,e){const r=e.lib;return r[t.userData.code]||this.materials.push(t),r[t.userData.code]=t,this}getMaterial(t,e=this.rootParseScope){if(t.startsWith("0x2")){const e=t.substring(3);return this.parseColourMetaDirective(new C("Direct_Color_"+e+" CODE -1 VALUE #"+e+" EDGE #"+e))}while(e){const r=e.lib[t];if(r)return r;e=e.parentScope}return null}parseColourMetaDirective(i){let s=null,l=16711935,c=16711935,u=1,h=!1,d=0,p=t,g=null;const f=i.getToken();if(!f)throw'LDrawLoader: Material name was expected after "!COLOUR tag'+i.getLineNumberString()+".";let b=null;while(1){if(b=i.getToken(),!b)break;switch(b.toUpperCase()){case"CODE":s=i.getToken();break;case"VALUE":if(l=i.getToken(),l.startsWith("0x"))l="#"+l.substring(2);else if(!l.startsWith("#"))throw"LDrawLoader: Invalid colour while parsing material"+i.getLineNumberString()+".";break;case"EDGE":if(c=i.getToken(),c.startsWith("0x"))c="#"+c.substring(2);else if(!c.startsWith("#")){if(g=this.getMaterial(c),!g)throw"LDrawLoader: Invalid edge colour while parsing material"+i.getLineNumberString()+".";g=g.userData.edgeMaterial}break;case"ALPHA":if(u=parseInt(i.getToken()),isNaN(u))throw"LDrawLoader: Invalid alpha value in material definition"+i.getLineNumberString()+".";u=Math.max(0,Math.min(1,u/255)),u<1&&(h=!0);break;case"LUMINANCE":if(d=parseInt(i.getToken()),isNaN(d))throw"LDrawLoader: Invalid luminance value in material definition"+C.getLineNumberString()+".";d=Math.max(0,Math.min(1,d/255));break;case"CHROME":p=e;break;case"PEARLESCENT":p=r;break;case"RUBBER":p=n;break;case"MATTE_METALLIC":p=a;break;case"METAL":p=o;break;case"MATERIAL":i.setToEnd();break;default:throw'LDrawLoader: Unknown token "'+b+'" while parsing material'+i.getLineNumberString()+"."}}let E=null;switch(p){case t:E=new THREE.MeshStandardMaterial({color:l,roughness:.3,metalness:0});break;case r:E=new THREE.MeshStandardMaterial({color:l,roughness:.3,metalness:.25});break;case e:E=new THREE.MeshStandardMaterial({color:l,roughness:0,metalness:1});break;case n:E=new THREE.MeshStandardMaterial({color:l,roughness:.9,metalness:0});break;case a:E=new THREE.MeshStandardMaterial({color:l,roughness:.8,metalness:.4});break;case o:E=new THREE.MeshStandardMaterial({color:l,roughness:.2,metalness:.85});break;default:break}return E.transparent=h,E.premultipliedAlpha=!0,E.opacity=u,E.depthWrite=!h,E.polygonOffset=!0,E.polygonOffsetFactor=1,0!==d&&E.emissive.set(E.color).multiplyScalar(d),g||(g=new THREE.LineBasicMaterial({color:c,transparent:h,opacity:u,depthWrite:!h}),g.userData.code=s,g.name=f+" - Edge",g.userData.conditionalEdgeMaterial=new m({fog:!0,transparent:h,depthWrite:!h,color:c,opacity:u})),E.userData.code=s,E.name=f,E.userData.edgeMaterial=g,E}objectParse(t,e){const r=e,n=r.parentScope,a=r.mainColourCode,o=r.mainEdgeColourCode;let i,s,l;const c=[];let u=null,h=null;-1!==t.indexOf("\r\n")&&(t=t.replace(/\r\n/g,"\n"));const d=t.split("\n"),m=d.length;let f=!1,b=null,E=null,x=!1,v=!0,k=!1,M=!0,L="",T=!1;const y=this;function S(t,e){let n=t.getToken();e||"16"!==n||(n=a),e&&"24"===n&&(n=o);const i=y.getMaterial(n,r);if(!i)throw'LDrawLoader: Unknown colour code "'+n+'" is used'+t.getLineNumberString()+" but it was not defined previously.";return i}function D(t){const e=new THREE.Vector3(parseFloat(t.getToken()),parseFloat(t.getToken()),parseFloat(t.getToken()));return y.separateObjects||e.applyMatrix4(r.currentMatrix),e}for(let F=0;F<m;F++){const t=d[F];if(0===t.length)continue;if(f){t.startsWith("0 FILE ")?(this.cache.setData(b.toLowerCase(),E),b=t.substring(7),E=""):E+=t+"\n";continue}const n=new C(t,F+1);if(n.seekNonSpace(),n.isAtTheEnd())continue;const a=n.getToken();let o,m,R,N,H,O,A,_,P,j,I,V;switch(a){case"0":const t=n.getToken();if(t)switch(t){case"!LDRAW_ORG":L=n.getToken(),r.type=L,r.matrix.determinant()<0&&(y.separateObjects&&w(L)||!y.separateObjects)&&(r.inverted=!r.inverted),i=r.faces,s=r.lineSegments,l=r.conditionalSegments;break;case"!COLOUR":o=this.parseColourMetaDirective(n),o?this.addMaterial(o,e):console.warn("LDrawLoader: Error parsing material"+n.getLineNumberString());break;case"!CATEGORY":u=n.getToken();break;case"!KEYWORDS":const t=n.getRemainingString().split(",");t.length>0&&(h||(h=[]),t.forEach((function(t){h.push(t.trim())})));break;case"FILE":F>0&&(f=!0,b=n.getRemainingString(),E="",x=!1,v=!0);break;case"BFC":while(!n.isAtTheEnd()){const t=n.getToken();switch(t){case"CERTIFY":case"NOCERTIFY":x="CERTIFY"===t,v=!0;break;case"CW":case"CCW":v="CCW"===t;break;case"INVERTNEXT":k=!0;break;case"CLIP":case"NOCLIP":M="CLIP"===t;break;default:console.warn('THREE.LDrawLoader: BFC directive "'+t+'" is unknown.');break}}break;case"STEP":T=!0;break;default:break}break;case"1":o=S(n);const d=parseFloat(n.getToken()),C=parseFloat(n.getToken()),z=parseFloat(n.getToken()),W=parseFloat(n.getToken()),U=parseFloat(n.getToken()),G=parseFloat(n.getToken()),B=parseFloat(n.getToken()),q=parseFloat(n.getToken()),Y=parseFloat(n.getToken()),$=parseFloat(n.getToken()),K=parseFloat(n.getToken()),X=parseFloat(n.getToken()),J=(new THREE.Matrix4).set(W,U,G,d,B,q,Y,C,$,K,X,z,0,0,0,1);let Q=n.getRemainingString().trim().replace(/\\/g,"/");y.fileMap[Q]?Q=y.fileMap[Q]:Q.startsWith("s/")?Q="parts/"+Q:Q.startsWith("48/")&&(Q="p/"+Q),c.push({material:o,matrix:J,fileName:Q,inverted:k!==r.inverted,startingConstructionStep:T}),k=!1;break;case"2":o=S(n,!0),O=D(n),A=D(n),m={material:o.userData.edgeMaterial,colourCode:o.userData.code,v0:O,v1:A,vertices:[O,A]},s.push(m);break;case"5":o=S(n,!0),O=D(n),A=D(n),j=D(n),I=D(n),m={material:o.userData.edgeMaterial.userData.conditionalEdgeMaterial,colourCode:o.userData.code,vertices:[O,A],controlPoints:[j,I]},l.push(m);break;case"3":o=S(n),R=r.inverted,N=v!==R,H=!x||!M,!0===N?(O=D(n),A=D(n),_=D(n)):(_=D(n),A=D(n),O=D(n)),p.subVectors(A,O),g.subVectors(_,A),V=(new THREE.Vector3).crossVectors(p,g).normalize(),i.push({material:o,colourCode:o.userData.code,faceNormal:V,vertices:[O,A,_],normals:[null,null,null]}),r.totalFaces++,!0===H&&(i.push({material:o,colourCode:o.userData.code,faceNormal:V,vertices:[_,A,O],normals:[null,null,null]}),r.totalFaces++);break;case"4":o=S(n),R=r.inverted,N=v!==R,H=!x||!M,!0===N?(O=D(n),A=D(n),_=D(n),P=D(n)):(P=D(n),_=D(n),A=D(n),O=D(n)),p.subVectors(A,O),g.subVectors(_,A),V=(new THREE.Vector3).crossVectors(p,g).normalize(),i.push({material:o,colourCode:o.userData.code,faceNormal:V,vertices:[O,A,_,P],normals:[null,null,null,null]}),r.totalFaces+=2,!0===H&&(i.push({material:o,colourCode:o.userData.code,faceNormal:V,vertices:[P,_,A,O],normals:[null,null,null,null]}),r.totalFaces+=2);break;default:throw'LDrawLoader: Unknown line type "'+a+'"'+n.getLineNumberString()+"."}}f&&this.cache.setData(b.toLowerCase(),E),r.category=u,r.keywords=h,r.subobjects=c,r.numSubobjects=c.length,r.subobjectIndex=0;const R=!n.isFromParse;(R||y.separateObjects&&!w(L))&&(r.groupObject=new THREE.Group,r.groupObject.userData.startingConstructionStep=r.startingConstructionStep)}computeConstructionSteps(t){let e=0;t.traverse((t=>{t.isGroup&&(t.userData.startingConstructionStep&&e++,t.userData.constructionStep=e)})),t.userData.numConstructionSteps=e+1}finalizeObject(t){if(null===t)return;const e=t.parentScope,r=b(t.type)||!b(t.type)&&!E(t.type)&&E(t.parentScope.type);this.smoothNormals&&r&&f(t.faces,t.lineSegments);const n=!e.isFromParse;if(this.separateObjects&&!w(t.type)||n){const r=t.groupObject;t.faces.length>0&&r.add(k(t.faces,3,!1,t.totalFaces)),t.lineSegments.length>0&&r.add(k(t.lineSegments,2)),t.conditionalSegments.length>0&&r.add(k(t.conditionalSegments,2,!0)),e.groupObject&&(r.name=t.fileName,r.userData.category=t.category,r.userData.keywords=t.keywords,t.matrix.decompose(r.position,r.quaternion,r.scale),e.groupObject.add(r))}else{const r=this.separateObjects,n=e.lineSegments,a=e.conditionalSegments,o=e.faces,i=t.lineSegments,s=t.conditionalSegments,l=t.faces;for(let e=0,c=i.length;e<c;e++){const a=i[e];if(r){const e=a.vertices;e[0].applyMatrix4(t.matrix),e[1].applyMatrix4(t.matrix)}n.push(a)}for(let e=0,c=s.length;e<c;e++){const n=s[e];if(r){const e=n.vertices,r=n.controlPoints;e[0].applyMatrix4(t.matrix),e[1].applyMatrix4(t.matrix),r[0].applyMatrix4(t.matrix),r[1].applyMatrix4(t.matrix)}a.push(n)}for(let e=0,c=l.length;e<c;e++){const n=l[e];if(r){const e=n.vertices;for(let r=0,n=e.length;r<n;r++)e[r]=e[r].clone().applyMatrix4(t.matrix);p.subVectors(e[1],e[0]),g.subVectors(e[2],e[1]),n.faceNormal.crossVectors(p,g).normalize()}o.push(n)}e.totalFaces+=t.totalFaces}}async processObject(t,e,r,n){const a=this,o=this.newParseScopeLevel(null,n);o.url=r;const i=o.parentScope;e&&(o.currentMatrix.multiplyMatrices(i.currentMatrix,e.matrix),o.matrix.copy(e.matrix),o.inverted=e.inverted,o.startingConstructionStep=e.startingConstructionStep,o.mainColourCode=e.material.userData.code,o.mainEdgeColourCode=e.material.userData.edgeMaterial.userData.code,o.fileName=e.fileName),this.objectParse(t,o);const s=o.subobjects,l=[];for(let h=0,d=s.length;h<d;h++)l.push(u(o.subobjects[h]));const c=await Promise.all(l);for(let h=0,d=c.length;h<d;h++)this.finalizeObject(c[h]);return i.isFromParse||(this.finalizeObject(o),this.computeConstructionSteps(o.groupObject)),o;function u(t){return a.cache.loadData(t.fileName).then((function(e){return a.processObject(e,t,r,o)})).catch((function(){return console.warn('LDrawLoader: Subobject "'+t.fileName+'" could not be found.'),null}))}}}THREE.LDrawLoader=M})();