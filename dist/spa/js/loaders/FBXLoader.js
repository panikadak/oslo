(function(){let e,t,r;class n extends THREE.Loader{constructor(e){super(e)}load(e,t,r,n){const o=this,a=""===o.path?THREE.LoaderUtils.extractUrlBase(e):o.path,s=new THREE.FileLoader(this.manager);s.setPath(o.path),s.setResponseType("arraybuffer"),s.setRequestHeader(o.requestHeader),s.setWithCredentials(o.withCredentials),s.load(e,(function(r){try{t(o.parse(r,a))}catch(s){n?n(s):console.error(s),o.manager.itemError(e)}}),r,n)}parse(t,r){if(p(t))e=(new l).parse(t);else{const r=w(t);if(!h(r))throw new Error("THREE.FBXLoader: Unknown format.");if(d(r)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+d(r));e=(new i).parse(r)}const n=new THREE.TextureLoader(this.manager).setPath(this.resourcePath||r).setCrossOrigin(this.crossOrigin);return new o(n,this.manager).parse(e)}}class o{constructor(e,t){this.textureLoader=e,this.manager=t}parse(){t=this.parseConnections();const e=this.parseImages(),n=this.parseTextures(e),o=this.parseMaterials(n),s=this.parseDeformers(),i=(new a).parse(s);return this.parseScene(s,i,o),r}parseConnections(){const t=new Map;if("Connections"in e){const r=e.Connections.connections;r.forEach((function(e){const r=e[0],n=e[1],o=e[2];t.has(r)||t.set(r,{parents:[],children:[]});const a={ID:n,relationship:o};t.get(r).parents.push(a),t.has(n)||t.set(n,{parents:[],children:[]});const s={ID:r,relationship:o};t.get(n).children.push(s)}))}return t}parseImages(){const t={},r={};if("Video"in e.Objects){const n=e.Objects.Video;for(const e in n){const o=n[e],a=parseInt(e);if(t[a]=o.RelativeFilename||o.Filename,"Content"in o){const t=o.Content instanceof ArrayBuffer&&o.Content.byteLength>0,a="string"===typeof o.Content&&""!==o.Content;if(t||a){const t=this.parseImage(n[e]);r[o.RelativeFilename||o.Filename]=t}}}}for(const e in t){const n=t[e];void 0!==r[n]?t[e]=r[n]:t[e]=t[e].split("\\").pop()}return t}parseImage(e){const t=e.Content,r=e.RelativeFilename||e.Filename,n=r.slice(r.lastIndexOf(".")+1).toLowerCase();let o;switch(n){case"bmp":o="image/bmp";break;case"jpg":case"jpeg":o="image/jpeg";break;case"png":o="image/png";break;case"tif":o="image/tiff";break;case"tga":null===this.manager.getHandler(".tga")&&console.warn("FBXLoader: TGA loader not found, skipping ",r),o="image/tga";break;default:return void console.warn('FBXLoader: Image type "'+n+'" is not supported.')}if("string"===typeof t)return"data:"+o+";base64,"+t;{const e=new Uint8Array(t);return window.URL.createObjectURL(new Blob([e],{type:o}))}}parseTextures(t){const r=new Map;if("Texture"in e.Objects){const n=e.Objects.Texture;for(const e in n){const o=this.parseTexture(n[e],t);r.set(parseInt(e),o)}}return r}parseTexture(e,t){const r=this.loadTexture(e,t);r.ID=e.id,r.name=e.attrName;const n=e.WrapModeU,o=e.WrapModeV,a=void 0!==n?n.value:0,s=void 0!==o?o.value:0;if(r.wrapS=0===a?THREE.RepeatWrapping:THREE.ClampToEdgeWrapping,r.wrapT=0===s?THREE.RepeatWrapping:THREE.ClampToEdgeWrapping,"Scaling"in e){const t=e.Scaling.value;r.repeat.x=t[0],r.repeat.y=t[1]}return r}loadTexture(e,r){let n;const o=this.textureLoader.path,a=t.get(e.id).children;let s;void 0!==a&&a.length>0&&void 0!==r[a[0].ID]&&(n=r[a[0].ID],0!==n.indexOf("blob:")&&0!==n.indexOf("data:")||this.textureLoader.setPath(void 0));const i=e.FileName.slice(-3).toLowerCase();if("tga"===i){const t=this.manager.getHandler(".tga");null===t?(console.warn("FBXLoader: TGA loader not found, creating placeholder texture for",e.RelativeFilename),s=new THREE.Texture):(t.setPath(this.textureLoader.path),s=t.load(n))}else"psd"===i?(console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for",e.RelativeFilename),s=new THREE.Texture):s=this.textureLoader.load(n);return this.textureLoader.setPath(o),s}parseMaterials(t){const r=new Map;if("Material"in e.Objects){const n=e.Objects.Material;for(const e in n){const o=this.parseMaterial(n[e],t);null!==o&&r.set(parseInt(e),o)}}return r}parseMaterial(e,r){const n=e.id,o=e.attrName;let a=e.ShadingModel;if("object"===typeof a&&(a=a.value),!t.has(n))return null;const s=this.parseParameters(e,r,n);let i;switch(a.toLowerCase()){case"phong":i=new THREE.MeshPhongMaterial;break;case"lambert":i=new THREE.MeshLambertMaterial;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to THREE.MeshPhongMaterial.',a),i=new THREE.MeshPhongMaterial;break}return i.setValues(s),i.name=o,i}parseParameters(e,r,n){const o={};e.BumpFactor&&(o.bumpScale=e.BumpFactor.value),e.Diffuse?o.color=(new THREE.Color).fromArray(e.Diffuse.value):!e.DiffuseColor||"Color"!==e.DiffuseColor.type&&"ColorRGB"!==e.DiffuseColor.type||(o.color=(new THREE.Color).fromArray(e.DiffuseColor.value)),e.DisplacementFactor&&(o.displacementScale=e.DisplacementFactor.value),e.Emissive?o.emissive=(new THREE.Color).fromArray(e.Emissive.value):!e.EmissiveColor||"Color"!==e.EmissiveColor.type&&"ColorRGB"!==e.EmissiveColor.type||(o.emissive=(new THREE.Color).fromArray(e.EmissiveColor.value)),e.EmissiveFactor&&(o.emissiveIntensity=parseFloat(e.EmissiveFactor.value)),e.Opacity&&(o.opacity=parseFloat(e.Opacity.value)),o.opacity<1&&(o.transparent=!0),e.ReflectionFactor&&(o.reflectivity=e.ReflectionFactor.value),e.Shininess&&(o.shininess=e.Shininess.value),e.Specular?o.specular=(new THREE.Color).fromArray(e.Specular.value):e.SpecularColor&&"Color"===e.SpecularColor.type&&(o.specular=(new THREE.Color).fromArray(e.SpecularColor.value));const a=this;return t.get(n).children.forEach((function(e){const t=e.relationship;switch(t){case"Bump":o.bumpMap=a.getTexture(r,e.ID);break;case"Maya|TEX_ao_map":o.aoMap=a.getTexture(r,e.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":o.map=a.getTexture(r,e.ID),void 0!==o.map&&(o.map.encoding=THREE.sRGBEncoding);break;case"DisplacementColor":o.displacementMap=a.getTexture(r,e.ID);break;case"EmissiveColor":o.emissiveMap=a.getTexture(r,e.ID),void 0!==o.emissiveMap&&(o.emissiveMap.encoding=THREE.sRGBEncoding);break;case"NormalMap":case"Maya|TEX_normal_map":o.normalMap=a.getTexture(r,e.ID);break;case"ReflectionColor":o.envMap=a.getTexture(r,e.ID),void 0!==o.envMap&&(o.envMap.mapping=THREE.EquirectangularReflectionMapping,o.envMap.encoding=THREE.sRGBEncoding);break;case"SpecularColor":o.specularMap=a.getTexture(r,e.ID),void 0!==o.specularMap&&(o.specularMap.encoding=THREE.sRGBEncoding);break;case"TransparentColor":case"TransparencyFactor":o.alphaMap=a.getTexture(r,e.ID),o.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",t);break}})),o}getTexture(r,n){return"LayeredTexture"in e.Objects&&n in e.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),n=t.get(n).children[0].ID),r.get(n)}parseDeformers(){const r={},n={};if("Deformer"in e.Objects){const o=e.Objects.Deformer;for(const e in o){const a=o[e],s=t.get(parseInt(e));if("Skin"===a.attrType){const t=this.parseSkeleton(s,o);t.ID=e,s.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),t.geometryID=s.parents[0].ID,r[e]=t}else if("BlendShape"===a.attrType){const t={id:e};t.rawTargets=this.parseMorphTargets(s,o),t.id=e,s.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),n[e]=t}}}return{skeletons:r,morphTargets:n}}parseSkeleton(e,t){const r=[];return e.children.forEach((function(e){const n=t[e.ID];if("Cluster"!==n.attrType)return;const o={ID:e.ID,indices:[],weights:[],transformLink:(new THREE.Matrix4).fromArray(n.TransformLink.a)};"Indexes"in n&&(o.indices=n.Indexes.a,o.weights=n.Weights.a),r.push(o)})),{rawBones:r,bones:[]}}parseMorphTargets(e,r){const n=[];for(let o=0;o<e.children.length;o++){const a=e.children[o],s=r[a.ID],i={name:s.attrName,initialWeight:s.DeformPercent,id:s.id,fullWeights:s.FullWeights.a};if("BlendShapeChannel"!==s.attrType)return;i.geoID=t.get(parseInt(a.ID)).children.filter((function(e){return void 0===e.relationship}))[0].ID,n.push(i)}return n}parseScene(n,o,a){r=new THREE.Group;const i=this.parseModels(n.skeletons,o,a),l=e.Objects.Model,c=this;i.forEach((function(e){const n=l[e.ID];c.setLookAtProperties(e,n);const o=t.get(e.ID).parents;o.forEach((function(t){const r=i.get(t.ID);void 0!==r&&r.add(e)})),null===e.parent&&r.add(e)})),this.bindSkeleton(n.skeletons,o,i),this.createAmbientLight(),r.traverse((function(e){if(e.userData.transformData){e.parent&&(e.userData.transformData.parentMatrix=e.parent.matrix,e.userData.transformData.parentMatrixWorld=e.parent.matrixWorld);const t=y(e.userData.transformData);e.applyMatrix4(t),e.updateWorldMatrix()}}));const u=(new s).parse();1===r.children.length&&r.children[0].isGroup&&(r.children[0].animations=u,r=r.children[0]),r.animations=u}parseModels(r,n,o){const a=new Map,s=e.Objects.Model;for(const e in s){const i=parseInt(e),l=s[e],c=t.get(i);let u=this.buildSkeleton(c,r,i,l.attrName);if(!u){switch(l.attrType){case"Camera":u=this.createCamera(c);break;case"Light":u=this.createLight(c);break;case"Mesh":u=this.createMesh(c,n,o);break;case"NurbsCurve":u=this.createCurve(c,n);break;case"LimbNode":case"Root":u=new THREE.Bone;break;case"Null":default:u=new THREE.Group;break}u.name=l.attrName?THREE.PropertyBinding.sanitizeNodeName(l.attrName):"",u.ID=i}this.getTransformData(u,l),a.set(i,u)}return a}buildSkeleton(e,t,r,n){let o=null;return e.parents.forEach((function(e){for(const a in t){const s=t[a];s.rawBones.forEach((function(t,a){if(t.ID===e.ID){const e=o;o=new THREE.Bone,o.matrixWorld.copy(t.transformLink),o.name=n?THREE.PropertyBinding.sanitizeNodeName(n):"",o.ID=r,s.bones[a]=o,null!==e&&o.add(e)}}))}})),o}createCamera(t){let r,n;if(t.children.forEach((function(t){const r=e.Objects.NodeAttribute[t.ID];void 0!==r&&(n=r)})),void 0===n)r=new THREE.Object3D;else{let e=0;void 0!==n.CameraProjectionType&&1===n.CameraProjectionType.value&&(e=1);let t=1;void 0!==n.NearPlane&&(t=n.NearPlane.value/1e3);let o=1e3;void 0!==n.FarPlane&&(o=n.FarPlane.value/1e3);let a=window.innerWidth,s=window.innerHeight;void 0!==n.AspectWidth&&void 0!==n.AspectHeight&&(a=n.AspectWidth.value,s=n.AspectHeight.value);const i=a/s;let l=45;void 0!==n.FieldOfView&&(l=n.FieldOfView.value);const c=n.FocalLength?n.FocalLength.value:null;switch(e){case 0:r=new THREE.PerspectiveCamera(l,i,t,o),null!==c&&r.setFocalLength(c);break;case 1:r=new THREE.OrthographicCamera(-a/2,a/2,s/2,-s/2,t,o);break;default:console.warn("THREE.FBXLoader: Unknown camera type "+e+"."),r=new THREE.Object3D;break}}return r}createLight(t){let r,n;if(t.children.forEach((function(t){const r=e.Objects.NodeAttribute[t.ID];void 0!==r&&(n=r)})),void 0===n)r=new THREE.Object3D;else{let e;e=void 0===n.LightType?0:n.LightType.value;let t=16777215;void 0!==n.Color&&(t=(new THREE.Color).fromArray(n.Color.value));let o=void 0===n.Intensity?1:n.Intensity.value/100;void 0!==n.CastLightOnObject&&0===n.CastLightOnObject.value&&(o=0);let a=0;void 0!==n.FarAttenuationEnd&&(a=void 0!==n.EnableFarAttenuation&&0===n.EnableFarAttenuation.value?0:n.FarAttenuationEnd.value);const s=1;switch(e){case 0:r=new THREE.PointLight(t,o,a,s);break;case 1:r=new THREE.DirectionalLight(t,o);break;case 2:let e=Math.PI/3;void 0!==n.InnerAngle&&(e=THREE.MathUtils.degToRad(n.InnerAngle.value));let i=0;void 0!==n.OuterAngle&&(i=THREE.MathUtils.degToRad(n.OuterAngle.value),i=Math.max(i,1)),r=new THREE.SpotLight(t,o,a,e,i,s);break;default:console.warn("THREE.FBXLoader: Unknown light type "+n.LightType.value+", defaulting to a THREE.PointLight."),r=new THREE.PointLight(t,o);break}void 0!==n.CastShadows&&1===n.CastShadows.value&&(r.castShadow=!0)}return r}createMesh(e,t,r){let n,o=null,a=null;const s=[];return e.children.forEach((function(e){t.has(e.ID)&&(o=t.get(e.ID)),r.has(e.ID)&&s.push(r.get(e.ID))})),s.length>1?a=s:s.length>0?a=s[0]:(a=new THREE.MeshPhongMaterial({color:13421772}),s.push(a)),"color"in o.attributes&&s.forEach((function(e){e.vertexColors=!0})),o.FBX_Deformer?(n=new THREE.SkinnedMesh(o,a),n.normalizeSkinWeights()):n=new THREE.Mesh(o,a),n}createCurve(e,t){const r=e.children.reduce((function(e,r){return t.has(r.ID)&&(e=t.get(r.ID)),e}),null),n=new THREE.LineBasicMaterial({color:3342591,linewidth:1});return new THREE.Line(r,n)}getTransformData(e,t){const r={};"InheritType"in t&&(r.inheritType=parseInt(t.InheritType.value)),r.eulerOrder="RotationOrder"in t?T(t.RotationOrder.value):"ZYX","Lcl_Translation"in t&&(r.translation=t.Lcl_Translation.value),"PreRotation"in t&&(r.preRotation=t.PreRotation.value),"Lcl_Rotation"in t&&(r.rotation=t.Lcl_Rotation.value),"PostRotation"in t&&(r.postRotation=t.PostRotation.value),"Lcl_Scaling"in t&&(r.scale=t.Lcl_Scaling.value),"ScalingOffset"in t&&(r.scalingOffset=t.ScalingOffset.value),"ScalingPivot"in t&&(r.scalingPivot=t.ScalingPivot.value),"RotationOffset"in t&&(r.rotationOffset=t.RotationOffset.value),"RotationPivot"in t&&(r.rotationPivot=t.RotationPivot.value),e.userData.transformData=r}setLookAtProperties(n,o){if("LookAtProperty"in o){const o=t.get(n.ID).children;o.forEach((function(t){if("LookAtProperty"===t.relationship){const o=e.Objects.Model[t.ID];if("Lcl_Translation"in o){const e=o.Lcl_Translation.value;void 0!==n.target?(n.target.position.fromArray(e),r.add(n.target)):n.lookAt((new THREE.Vector3).fromArray(e))}}}))}}bindSkeleton(e,r,n){const o=this.parsePoseNodes();for(const a in e){const s=e[a],i=t.get(parseInt(s.ID)).parents;i.forEach((function(e){if(r.has(e.ID)){const r=e.ID,a=t.get(r);a.parents.forEach((function(e){if(n.has(e.ID)){const t=n.get(e.ID);t.bind(new THREE.Skeleton(s.bones),o[e.ID])}}))}}))}}parsePoseNodes(){const t={};if("Pose"in e.Objects){const r=e.Objects.Pose;for(const e in r)if("BindPose"===r[e].attrType&&r[e].NbPoseNodes>0){const n=r[e].PoseNode;Array.isArray(n)?n.forEach((function(e){t[e.Node]=(new THREE.Matrix4).fromArray(e.Matrix.a)})):t[n.Node]=(new THREE.Matrix4).fromArray(n.Matrix.a)}}return t}createAmbientLight(){if("GlobalSettings"in e&&"AmbientColor"in e.GlobalSettings){const t=e.GlobalSettings.AmbientColor.value,n=t[0],o=t[1],a=t[2];if(0!==n||0!==o||0!==a){const e=new THREE.Color(n,o,a);r.add(new THREE.AmbientLight(e,1))}}}}class a{parse(r){const n=new Map;if("Geometry"in e.Objects){const o=e.Objects.Geometry;for(const e in o){const a=t.get(parseInt(e)),s=this.parseGeometry(a,o[e],r);n.set(parseInt(e),s)}}return n}parseGeometry(e,t,r){switch(t.attrType){case"Mesh":return this.parseMeshGeometry(e,t,r);case"NurbsCurve":return this.parseNurbsGeometry(t)}}parseMeshGeometry(t,r,n){const o=n.skeletons,a=[],s=t.parents.map((function(t){return e.Objects.Model[t.ID]}));if(0===s.length)return;const i=t.children.reduce((function(e,t){return void 0!==o[t.ID]&&(e=o[t.ID]),e}),null);t.children.forEach((function(e){void 0!==n.morphTargets[e.ID]&&a.push(n.morphTargets[e.ID])}));const l=s[0],c={};"RotationOrder"in l&&(c.eulerOrder=T(l.RotationOrder.value)),"InheritType"in l&&(c.inheritType=parseInt(l.InheritType.value)),"GeometricTranslation"in l&&(c.translation=l.GeometricTranslation.value),"GeometricRotation"in l&&(c.rotation=l.GeometricRotation.value),"GeometricScaling"in l&&(c.scale=l.GeometricScaling.value);const u=y(c);return this.genGeometry(r,i,a,u)}genGeometry(e,t,r,n){const o=new THREE.BufferGeometry;e.attrName&&(o.name=e.attrName);const a=this.parseGeoNode(e,t),s=this.genBuffers(a),i=new THREE.Float32BufferAttribute(s.vertex,3);if(i.applyMatrix4(n),o.setAttribute("position",i),s.colors.length>0&&o.setAttribute("color",new THREE.Float32BufferAttribute(s.colors,3)),t&&(o.setAttribute("skinIndex",new THREE.Uint16BufferAttribute(s.weightsIndices,4)),o.setAttribute("skinWeight",new THREE.Float32BufferAttribute(s.vertexWeights,4)),o.FBX_Deformer=t),s.normal.length>0){const e=(new THREE.Matrix3).getNormalMatrix(n),t=new THREE.Float32BufferAttribute(s.normal,3);t.applyNormalMatrix(e),o.setAttribute("normal",t)}if(s.uvs.forEach((function(e,t){let r="uv"+(t+1).toString();0===t&&(r="uv"),o.setAttribute(r,new THREE.Float32BufferAttribute(s.uvs[t],2))})),a.material&&"AllSame"!==a.material.mappingType){let e=s.materialIndex[0],t=0;if(s.materialIndex.forEach((function(r,n){r!==e&&(o.addGroup(t,n-t,e),e=r,t=n)})),o.groups.length>0){const t=o.groups[o.groups.length-1],r=t.start+t.count;r!==s.materialIndex.length&&o.addGroup(r,s.materialIndex.length-r,e)}0===o.groups.length&&o.addGroup(0,s.materialIndex.length,s.materialIndex[0])}return this.addMorphTargets(o,e,r,n),o}parseGeoNode(e,t){const r={};if(r.vertexPositions=void 0!==e.Vertices?e.Vertices.a:[],r.vertexIndices=void 0!==e.PolygonVertexIndex?e.PolygonVertexIndex.a:[],e.LayerElementColor&&(r.color=this.parseVertexColors(e.LayerElementColor[0])),e.LayerElementMaterial&&(r.material=this.parseMaterialIndices(e.LayerElementMaterial[0])),e.LayerElementNormal&&(r.normal=this.parseNormals(e.LayerElementNormal[0])),e.LayerElementUV){r.uv=[];let t=0;while(e.LayerElementUV[t])e.LayerElementUV[t].UV&&r.uv.push(this.parseUVs(e.LayerElementUV[t])),t++}return r.weightTable={},null!==t&&(r.skeleton=t,t.rawBones.forEach((function(e,t){e.indices.forEach((function(n,o){void 0===r.weightTable[n]&&(r.weightTable[n]=[]),r.weightTable[n].push({id:t,weight:e.weights[o]})}))}))),r}genBuffers(e){const t={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let r=0,n=0,o=!1,a=[],s=[],i=[],l=[],c=[],u=[];const p=this;return e.vertexIndices.forEach((function(h,d){let f,m=!1;h<0&&(h^=-1,m=!0);let E=[],v=[];if(a.push(3*h,3*h+1,3*h+2),e.color){const t=g(d,r,h,e.color);i.push(t[0],t[1],t[2])}if(e.skeleton){if(void 0!==e.weightTable[h]&&e.weightTable[h].forEach((function(e){v.push(e.weight),E.push(e.id)})),v.length>4){o||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),o=!0);const e=[0,0,0,0],t=[0,0,0,0];v.forEach((function(r,n){let o=r,a=E[n];t.forEach((function(t,r,n){if(o>t){n[r]=o,o=t;const s=e[r];e[r]=a,a=s}}))})),E=e,v=t}while(v.length<4)v.push(0),E.push(0);for(let e=0;e<4;++e)c.push(v[e]),u.push(E[e])}if(e.normal){const t=g(d,r,h,e.normal);s.push(t[0],t[1],t[2])}e.material&&"AllSame"!==e.material.mappingType&&(f=g(d,r,h,e.material)[0]),e.uv&&e.uv.forEach((function(e,t){const n=g(d,r,h,e);void 0===l[t]&&(l[t]=[]),l[t].push(n[0]),l[t].push(n[1])})),n++,m&&(p.genFace(t,e,a,f,s,i,l,c,u,n),r++,n=0,a=[],s=[],i=[],l=[],c=[],u=[])})),t}genFace(e,t,r,n,o,a,s,i,l,c){for(let u=2;u<c;u++)e.vertex.push(t.vertexPositions[r[0]]),e.vertex.push(t.vertexPositions[r[1]]),e.vertex.push(t.vertexPositions[r[2]]),e.vertex.push(t.vertexPositions[r[3*(u-1)]]),e.vertex.push(t.vertexPositions[r[3*(u-1)+1]]),e.vertex.push(t.vertexPositions[r[3*(u-1)+2]]),e.vertex.push(t.vertexPositions[r[3*u]]),e.vertex.push(t.vertexPositions[r[3*u+1]]),e.vertex.push(t.vertexPositions[r[3*u+2]]),t.skeleton&&(e.vertexWeights.push(i[0]),e.vertexWeights.push(i[1]),e.vertexWeights.push(i[2]),e.vertexWeights.push(i[3]),e.vertexWeights.push(i[4*(u-1)]),e.vertexWeights.push(i[4*(u-1)+1]),e.vertexWeights.push(i[4*(u-1)+2]),e.vertexWeights.push(i[4*(u-1)+3]),e.vertexWeights.push(i[4*u]),e.vertexWeights.push(i[4*u+1]),e.vertexWeights.push(i[4*u+2]),e.vertexWeights.push(i[4*u+3]),e.weightsIndices.push(l[0]),e.weightsIndices.push(l[1]),e.weightsIndices.push(l[2]),e.weightsIndices.push(l[3]),e.weightsIndices.push(l[4*(u-1)]),e.weightsIndices.push(l[4*(u-1)+1]),e.weightsIndices.push(l[4*(u-1)+2]),e.weightsIndices.push(l[4*(u-1)+3]),e.weightsIndices.push(l[4*u]),e.weightsIndices.push(l[4*u+1]),e.weightsIndices.push(l[4*u+2]),e.weightsIndices.push(l[4*u+3])),t.color&&(e.colors.push(a[0]),e.colors.push(a[1]),e.colors.push(a[2]),e.colors.push(a[3*(u-1)]),e.colors.push(a[3*(u-1)+1]),e.colors.push(a[3*(u-1)+2]),e.colors.push(a[3*u]),e.colors.push(a[3*u+1]),e.colors.push(a[3*u+2])),t.material&&"AllSame"!==t.material.mappingType&&(e.materialIndex.push(n),e.materialIndex.push(n),e.materialIndex.push(n)),t.normal&&(e.normal.push(o[0]),e.normal.push(o[1]),e.normal.push(o[2]),e.normal.push(o[3*(u-1)]),e.normal.push(o[3*(u-1)+1]),e.normal.push(o[3*(u-1)+2]),e.normal.push(o[3*u]),e.normal.push(o[3*u+1]),e.normal.push(o[3*u+2])),t.uv&&t.uv.forEach((function(t,r){void 0===e.uvs[r]&&(e.uvs[r]=[]),e.uvs[r].push(s[r][0]),e.uvs[r].push(s[r][1]),e.uvs[r].push(s[r][2*(u-1)]),e.uvs[r].push(s[r][2*(u-1)+1]),e.uvs[r].push(s[r][2*u]),e.uvs[r].push(s[r][2*u+1])}))}addMorphTargets(t,r,n,o){if(0===n.length)return;t.morphTargetsRelative=!0,t.morphAttributes.position=[];const a=this;n.forEach((function(n){n.rawTargets.forEach((function(n){const s=e.Objects.Geometry[n.geoID];void 0!==s&&a.genMorphGeometry(t,r,s,o,n.name)}))}))}genMorphGeometry(e,t,r,n,o){const a=void 0!==t.PolygonVertexIndex?t.PolygonVertexIndex.a:[],s=void 0!==r.Vertices?r.Vertices.a:[],i=void 0!==r.Indexes?r.Indexes.a:[],l=3*e.attributes.position.count,c=new Float32Array(l);for(let d=0;d<i.length;d++){const e=3*i[d];c[e]=s[3*d],c[e+1]=s[3*d+1],c[e+2]=s[3*d+2]}const u={vertexIndices:a,vertexPositions:c},p=this.genBuffers(u),h=new THREE.Float32BufferAttribute(p.vertex,3);h.name=o||r.attrName,h.applyMatrix4(n),e.morphAttributes.position.push(h)}parseNormals(e){const t=e.MappingInformationType,r=e.ReferenceInformationType,n=e.Normals.a;let o=[];return"IndexToDirect"===r&&("NormalIndex"in e?o=e.NormalIndex.a:"NormalsIndex"in e&&(o=e.NormalsIndex.a)),{dataSize:3,buffer:n,indices:o,mappingType:t,referenceType:r}}parseUVs(e){const t=e.MappingInformationType,r=e.ReferenceInformationType,n=e.UV.a;let o=[];return"IndexToDirect"===r&&(o=e.UVIndex.a),{dataSize:2,buffer:n,indices:o,mappingType:t,referenceType:r}}parseVertexColors(e){const t=e.MappingInformationType,r=e.ReferenceInformationType,n=e.Colors.a;let o=[];return"IndexToDirect"===r&&(o=e.ColorIndex.a),{dataSize:4,buffer:n,indices:o,mappingType:t,referenceType:r}}parseMaterialIndices(e){const t=e.MappingInformationType,r=e.ReferenceInformationType;if("NoMappingInformation"===t)return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:r};const n=e.Materials.a,o=[];for(let a=0;a<n.length;++a)o.push(a);return{dataSize:1,buffer:n,indices:o,mappingType:t,referenceType:r}}parseNurbsGeometry(e){if(void 0===THREE.NURBSCurve)return console.error("THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."),new THREE.BufferGeometry;const t=parseInt(e.Order);if(isNaN(t))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",e.Order,e.id),new THREE.BufferGeometry;const r=t-1,n=e.KnotVector.a,o=[],a=e.Points.a;for(let u=0,p=a.length;u<p;u+=4)o.push((new THREE.Vector4).fromArray(a,u));let s,i;if("Closed"===e.Form)o.push(o[0]);else if("Periodic"===e.Form){s=r,i=n.length-1-s;for(let e=0;e<r;++e)o.push(o[e])}const l=new THREE.NURBSCurve(r,n,o,s,i),c=l.getPoints(12*o.length);return(new THREE.BufferGeometry).setFromPoints(c)}}class s{parse(){const e=[],t=this.parseClips();if(void 0!==t)for(const r in t){const n=t[r],o=this.addClip(n);e.push(o)}return e}parseClips(){if(void 0===e.Objects.AnimationCurve)return;const t=this.parseAnimationCurveNodes();this.parseAnimationCurves(t);const r=this.parseAnimationLayers(t),n=this.parseAnimStacks(r);return n}parseAnimationCurveNodes(){const t=e.Objects.AnimationCurveNode,r=new Map;for(const e in t){const n=t[e];if(null!==n.attrName.match(/S|R|T|DeformPercent/)){const e={id:n.id,attr:n.attrName,curves:{}};r.set(e.id,e)}}return r}parseAnimationCurves(r){const n=e.Objects.AnimationCurve;for(const e in n){const o={id:n[e].id,times:n[e].KeyTime.a.map(f),values:n[e].KeyValueFloat.a},a=t.get(o.id);if(void 0!==a){const e=a.parents[0].ID,t=a.parents[0].relationship;t.match(/X/)?r.get(e).curves["x"]=o:t.match(/Y/)?r.get(e).curves["y"]=o:t.match(/Z/)?r.get(e).curves["z"]=o:t.match(/d|DeformPercent/)&&r.has(e)&&(r.get(e).curves["morph"]=o)}}}parseAnimationLayers(n){const o=e.Objects.AnimationLayer,a=new Map;for(const s in o){const o=[],i=t.get(parseInt(s));if(void 0!==i){const l=i.children;l.forEach((function(a,s){if(n.has(a.ID)){const i=n.get(a.ID);if(void 0!==i.curves.x||void 0!==i.curves.y||void 0!==i.curves.z){if(void 0===o[s]){const n=t.get(a.ID).parents.filter((function(e){return void 0!==e.relationship}))[0].ID;if(void 0!==n){const t=e.Objects.Model[n.toString()];if(void 0===t)return void console.warn("THREE.FBXLoader: Encountered a unused curve.",a);const i={modelName:t.attrName?THREE.PropertyBinding.sanitizeNodeName(t.attrName):"",ID:t.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};r.traverse((function(e){e.ID===t.id&&(i.transform=e.matrix,e.userData.transformData&&(i.eulerOrder=e.userData.transformData.eulerOrder))})),i.transform||(i.transform=new THREE.Matrix4),"PreRotation"in t&&(i.preRotation=t.PreRotation.value),"PostRotation"in t&&(i.postRotation=t.PostRotation.value),o[s]=i}}o[s]&&(o[s][i.attr]=i)}else if(void 0!==i.curves.morph){if(void 0===o[s]){const r=t.get(a.ID).parents.filter((function(e){return void 0!==e.relationship}))[0].ID,n=t.get(r).parents[0].ID,i=t.get(n).parents[0].ID,l=t.get(i).parents[0].ID,c=e.Objects.Model[l],u={modelName:c.attrName?THREE.PropertyBinding.sanitizeNodeName(c.attrName):"",morphName:e.Objects.Deformer[r].attrName};o[s]=u}o[s][i.attr]=i}}})),a.set(parseInt(s),o)}}return a}parseAnimStacks(r){const n=e.Objects.AnimationStack,o={};for(const e in n){const a=t.get(parseInt(e)).children;a.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");const s=r.get(a[0].ID);o[e]={name:n[e].attrName,layer:s}}return o}addClip(e){let t=[];const r=this;return e.layer.forEach((function(e){t=t.concat(r.generateTracks(e))})),new THREE.AnimationClip(e.name,-1,t)}generateTracks(e){const t=[];let r=new THREE.Vector3,n=new THREE.Quaternion,o=new THREE.Vector3;if(e.transform&&e.transform.decompose(r,n,o),r=r.toArray(),n=(new THREE.Euler).setFromQuaternion(n,e.eulerOrder).toArray(),o=o.toArray(),void 0!==e.T&&Object.keys(e.T.curves).length>0){const n=this.generateVectorTrack(e.modelName,e.T.curves,r,"position");void 0!==n&&t.push(n)}if(void 0!==e.R&&Object.keys(e.R.curves).length>0){const r=this.generateRotationTrack(e.modelName,e.R.curves,n,e.preRotation,e.postRotation,e.eulerOrder);void 0!==r&&t.push(r)}if(void 0!==e.S&&Object.keys(e.S.curves).length>0){const r=this.generateVectorTrack(e.modelName,e.S.curves,o,"scale");void 0!==r&&t.push(r)}if(void 0!==e.DeformPercent){const r=this.generateMorphTrack(e);void 0!==r&&t.push(r)}return t}generateVectorTrack(e,t,r,n){const o=this.getTimesForAllAxes(t),a=this.getKeyframeTrackValues(o,t,r);return new THREE.VectorKeyframeTrack(e+"."+n,o,a)}generateRotationTrack(e,t,r,n,o,a){void 0!==t.x&&(this.interpolateRotations(t.x),t.x.values=t.x.values.map(THREE.MathUtils.degToRad)),void 0!==t.y&&(this.interpolateRotations(t.y),t.y.values=t.y.values.map(THREE.MathUtils.degToRad)),void 0!==t.z&&(this.interpolateRotations(t.z),t.z.values=t.z.values.map(THREE.MathUtils.degToRad));const s=this.getTimesForAllAxes(t),i=this.getKeyframeTrackValues(s,t,r);void 0!==n&&(n=n.map(THREE.MathUtils.degToRad),n.push(a),n=(new THREE.Euler).fromArray(n),n=(new THREE.Quaternion).setFromEuler(n)),void 0!==o&&(o=o.map(THREE.MathUtils.degToRad),o.push(a),o=(new THREE.Euler).fromArray(o),o=(new THREE.Quaternion).setFromEuler(o).invert());const l=new THREE.Quaternion,c=new THREE.Euler,u=[];for(let p=0;p<i.length;p+=3)c.set(i[p],i[p+1],i[p+2],a),l.setFromEuler(c),void 0!==n&&l.premultiply(n),void 0!==o&&l.multiply(o),l.toArray(u,p/3*4);return new THREE.QuaternionKeyframeTrack(e+".quaternion",s,u)}generateMorphTrack(e){const t=e.DeformPercent.curves.morph,n=t.values.map((function(e){return e/100})),o=r.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];return new THREE.NumberKeyframeTrack(e.modelName+".morphTargetInfluences["+o+"]",t.times,n)}getTimesForAllAxes(e){let t=[];if(void 0!==e.x&&(t=t.concat(e.x.times)),void 0!==e.y&&(t=t.concat(e.y.times)),void 0!==e.z&&(t=t.concat(e.z.times)),t=t.sort((function(e,t){return e-t})),t.length>1){let e=1,r=t[0];for(let n=1;n<t.length;n++){const o=t[n];o!==r&&(t[e]=o,r=o,e++)}t=t.slice(0,e)}return t}getKeyframeTrackValues(e,t,r){const n=r,o=[];let a=-1,s=-1,i=-1;return e.forEach((function(e){if(t.x&&(a=t.x.times.indexOf(e)),t.y&&(s=t.y.times.indexOf(e)),t.z&&(i=t.z.times.indexOf(e)),-1!==a){const e=t.x.values[a];o.push(e),n[0]=e}else o.push(n[0]);if(-1!==s){const e=t.y.values[s];o.push(e),n[1]=e}else o.push(n[1]);if(-1!==i){const e=t.z.values[i];o.push(e),n[2]=e}else o.push(n[2])})),o}interpolateRotations(e){for(let t=1;t<e.values.length;t++){const r=e.values[t-1],n=e.values[t]-r,o=Math.abs(n);if(o>=180){const a=o/180,s=n/a;let i=r+s;const l=e.times[t-1],c=e.times[t]-l,u=c/a;let p=l+u;const h=[],d=[];while(p<e.times[t])h.push(p),p+=u,d.push(i),i+=s;e.times=b(e.times,t,h),e.values=b(e.values,t,d)}}}}class i{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(e){this.nodeStack.push(e),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(e,t){this.currentProp=e,this.currentPropName=t}parse(e){this.currentIndent=0,this.allNodes=new u,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const t=this,r=e.split(/[\r\n]+/);return r.forEach((function(e,n){const o=e.match(/^[\s\t]*;/),a=e.match(/^[\s\t]*$/);if(o||a)return;const s=e.match("^\\t{"+t.currentIndent+"}(\\w+):(.*){",""),i=e.match("^\\t{"+t.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),l=e.match("^\\t{"+(t.currentIndent-1)+"}}");s?t.parseNodeBegin(e,s):i?t.parseNodeProperty(e,i,r[++n]):l?t.popStack():e.match(/^[^\s\t}]/)&&t.parseNodePropertyContinued(e)})),this.allNodes}parseNodeBegin(e,t){const r=t[1].trim().replace(/^"/,"").replace(/"$/,""),n=t[2].split(",").map((function(e){return e.trim().replace(/^"/,"").replace(/"$/,"")})),o={name:r},a=this.parseNodeAttr(n),s=this.getCurrentNode();0===this.currentIndent?this.allNodes.add(r,o):r in s?("PoseNode"===r?s.PoseNode.push(o):void 0!==s[r].id&&(s[r]={},s[r][s[r].id]=s[r]),""!==a.id&&(s[r][a.id]=o)):"number"===typeof a.id?(s[r]={},s[r][a.id]=o):"Properties70"!==r&&(s[r]="PoseNode"===r?[o]:o),"number"===typeof a.id&&(o.id=a.id),""!==a.name&&(o.attrName=a.name),""!==a.type&&(o.attrType=a.type),this.pushStack(o)}parseNodeAttr(e){let t=e[0];""!==e[0]&&(t=parseInt(e[0]),isNaN(t)&&(t=e[0]));let r="",n="";return e.length>1&&(r=e[1].replace(/^(\w+)::/,""),n=e[2]),{id:t,name:r,type:n}}parseNodeProperty(e,t,r){let n=t[1].replace(/^"/,"").replace(/"$/,"").trim(),o=t[2].replace(/^"/,"").replace(/"$/,"").trim();"Content"===n&&","===o&&(o=r.replace(/"/g,"").replace(/,$/,"").trim());const a=this.getCurrentNode(),s=a.name;if("Properties70"!==s){if("C"===n){const e=o.split(",").slice(1),t=parseInt(e[0]),r=parseInt(e[1]);let s=o.split(",").slice(3);s=s.map((function(e){return e.trim().replace(/^"/,"")})),n="connections",o=[t,r],I(o,s),void 0===a[n]&&(a[n]=[])}"Node"===n&&(a.id=o),n in a&&Array.isArray(a[n])?a[n].push(o):"a"!==n?a[n]=o:a.a=o,this.setCurrentProp(a,n),"a"===n&&","!==o.slice(-1)&&(a.a=R(o))}else this.parseNodeSpecialProperty(e,n,o)}parseNodePropertyContinued(e){const t=this.getCurrentNode();t.a+=e,","!==e.slice(-1)&&(t.a=R(t.a))}parseNodeSpecialProperty(e,t,r){const n=r.split('",').map((function(e){return e.trim().replace(/^\"/,"").replace(/\s/,"_")})),o=n[0],a=n[1],s=n[2],i=n[3];let l=n[4];switch(a){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":l=parseFloat(l);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":l=R(l);break}this.getPrevNode()[o]={type:a,type2:s,flag:i,value:l},this.setCurrentProp(this.getPrevNode(),o)}}class l{parse(e){const t=new c(e);t.skip(23);const r=t.getUint32();if(r<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+r);const n=new u;while(!this.endOfContent(t)){const e=this.parseNode(t,r);null!==e&&n.add(e.name,e)}return n}endOfContent(e){return e.size()%16===0?(e.getOffset()+160+16&-16)>=e.size():e.getOffset()+160+16>=e.size()}parseNode(e,t){const r={},n=t>=7500?e.getUint64():e.getUint32(),o=t>=7500?e.getUint64():e.getUint32();t>=7500?e.getUint64():e.getUint32();const a=e.getUint8(),s=e.getString(a);if(0===n)return null;const i=[];for(let p=0;p<o;p++)i.push(this.parseProperty(e));const l=i.length>0?i[0]:"",c=i.length>1?i[1]:"",u=i.length>2?i[2]:"";r.singleProperty=1===o&&e.getOffset()===n;while(n>e.getOffset()){const n=this.parseNode(e,t);null!==n&&this.parseSubNode(s,r,n)}return r.propertyList=i,"number"===typeof l&&(r.id=l),""!==c&&(r.attrName=c),""!==u&&(r.attrType=u),""!==s&&(r.name=s),r}parseSubNode(e,t,r){if(!0===r.singleProperty){const e=r.propertyList[0];Array.isArray(e)?(t[r.name]=r,r.a=e):t[r.name]=e}else if("Connections"===e&&"C"===r.name){const e=[];r.propertyList.forEach((function(t,r){0!==r&&e.push(t)})),void 0===t.connections&&(t.connections=[]),t.connections.push(e)}else if("Properties70"===r.name){const e=Object.keys(r);e.forEach((function(e){t[e]=r[e]}))}else if("Properties70"===e&&"P"===r.name){let e=r.propertyList[0],n=r.propertyList[1];const o=r.propertyList[2],a=r.propertyList[3];let s;0===e.indexOf("Lcl ")&&(e=e.replace("Lcl ","Lcl_")),0===n.indexOf("Lcl ")&&(n=n.replace("Lcl ","Lcl_")),s="Color"===n||"ColorRGB"===n||"Vector"===n||"Vector3D"===n||0===n.indexOf("Lcl_")?[r.propertyList[4],r.propertyList[5],r.propertyList[6]]:r.propertyList[4],t[e]={type:n,type2:o,flag:a,value:s}}else void 0===t[r.name]?"number"===typeof r.id?(t[r.name]={},t[r.name][r.id]=r):t[r.name]=r:"PoseNode"===r.name?(Array.isArray(t[r.name])||(t[r.name]=[t[r.name]]),t[r.name].push(r)):void 0===t[r.name][r.id]&&(t[r.name][r.id]=r)}parseProperty(e){const t=e.getString(1);let r;switch(t){case"C":return e.getBoolean();case"D":return e.getFloat64();case"F":return e.getFloat32();case"I":return e.getInt32();case"L":return e.getInt64();case"R":return r=e.getUint32(),e.getArrayBuffer(r);case"S":return r=e.getUint32(),e.getString(r);case"Y":return e.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const n=e.getUint32(),o=e.getUint32(),a=e.getUint32();if(0===o)switch(t){case"b":case"c":return e.getBooleanArray(n);case"d":return e.getFloat64Array(n);case"f":return e.getFloat32Array(n);case"i":return e.getInt32Array(n);case"l":return e.getInt64Array(n)}"undefined"===typeof fflate&&console.error("THREE.FBXLoader: External library fflate.min.js required.");const s=fflate.unzlibSync(new Uint8Array(e.getArrayBuffer(a))),i=new c(s.buffer);switch(t){case"b":case"c":return i.getBooleanArray(n);case"d":return i.getFloat64Array(n);case"f":return i.getFloat32Array(n);case"i":return i.getInt32Array(n);case"l":return i.getInt64Array(n)}default:throw new Error("THREE.FBXLoader: Unknown property type "+t)}}}class c{constructor(e,t){this.dv=new DataView(e),this.offset=0,this.littleEndian=void 0===t||t}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(e){this.offset+=e}getBoolean(){return 1===(1&this.getUint8())}getBooleanArray(e){const t=[];for(let r=0;r<e;r++)t.push(this.getBoolean());return t}getUint8(){const e=this.dv.getUint8(this.offset);return this.offset+=1,e}getInt16(){const e=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,e}getInt32(){const e=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,e}getInt32Array(e){const t=[];for(let r=0;r<e;r++)t.push(this.getInt32());return t}getUint32(){const e=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,e}getInt64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),2147483648&t?(t=4294967295&~t,e=4294967295&~e,4294967295===e&&(t=t+1&4294967295),e=e+1&4294967295,-(4294967296*t+e)):4294967296*t+e}getInt64Array(e){const t=[];for(let r=0;r<e;r++)t.push(this.getInt64());return t}getUint64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),4294967296*t+e}getFloat32(){const e=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,e}getFloat32Array(e){const t=[];for(let r=0;r<e;r++)t.push(this.getFloat32());return t}getFloat64(){const e=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,e}getFloat64Array(e){const t=[];for(let r=0;r<e;r++)t.push(this.getFloat64());return t}getArrayBuffer(e){const t=this.dv.buffer.slice(this.offset,this.offset+e);return this.offset+=e,t}getString(e){let t=[];for(let n=0;n<e;n++)t[n]=this.getUint8();const r=t.indexOf(0);return r>=0&&(t=t.slice(0,r)),THREE.LoaderUtils.decodeText(new Uint8Array(t))}}class u{add(e,t){this[e]=t}}function p(e){const t="Kaydara FBX Binary  \0";return e.byteLength>=t.length&&t===w(e,0,t.length)}function h(e){const t=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let r=0;function n(t){const n=e[t-1];return e=e.slice(r+t),r++,n}for(let o=0;o<t.length;++o){const e=n(1);if(e===t[o])return!1}return!0}function d(e){const t=/FBXVersion: (\d+)/,r=e.match(t);if(r){const e=parseInt(r[1]);return e}throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function f(e){return e/46186158e3}const m=[];function g(e,t,r,n){let o;switch(n.mappingType){case"ByPolygonVertex":o=e;break;case"ByPolygon":o=t;break;case"ByVertice":o=r;break;case"AllSame":o=n.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+n.mappingType)}"IndexToDirect"===n.referenceType&&(o=n.indices[o]);const a=o*n.dataSize,s=a+n.dataSize;return x(m,n.buffer,a,s)}const E=new THREE.Euler,v=new THREE.Vector3;function y(e){const t=new THREE.Matrix4,r=new THREE.Matrix4,n=new THREE.Matrix4,o=new THREE.Matrix4,a=new THREE.Matrix4,s=new THREE.Matrix4,i=new THREE.Matrix4,l=new THREE.Matrix4,c=new THREE.Matrix4,u=new THREE.Matrix4,p=new THREE.Matrix4,h=new THREE.Matrix4,d=e.inheritType?e.inheritType:0;if(e.translation&&t.setPosition(v.fromArray(e.translation)),e.preRotation){const t=e.preRotation.map(THREE.MathUtils.degToRad);t.push(e.eulerOrder),r.makeRotationFromEuler(E.fromArray(t))}if(e.rotation){const t=e.rotation.map(THREE.MathUtils.degToRad);t.push(e.eulerOrder),n.makeRotationFromEuler(E.fromArray(t))}if(e.postRotation){const t=e.postRotation.map(THREE.MathUtils.degToRad);t.push(e.eulerOrder),o.makeRotationFromEuler(E.fromArray(t)),o.invert()}e.scale&&a.scale(v.fromArray(e.scale)),e.scalingOffset&&i.setPosition(v.fromArray(e.scalingOffset)),e.scalingPivot&&s.setPosition(v.fromArray(e.scalingPivot)),e.rotationOffset&&l.setPosition(v.fromArray(e.rotationOffset)),e.rotationPivot&&c.setPosition(v.fromArray(e.rotationPivot)),e.parentMatrixWorld&&(p.copy(e.parentMatrix),u.copy(e.parentMatrixWorld));const f=r.clone().multiply(n).multiply(o),m=new THREE.Matrix4;m.extractRotation(u);const g=new THREE.Matrix4;g.copyPosition(u);const y=g.clone().invert().multiply(u),T=m.clone().invert().multiply(y),R=a,w=new THREE.Matrix4;if(0===d)w.copy(m).multiply(f).multiply(T).multiply(R);else if(1===d)w.copy(m).multiply(T).multiply(f).multiply(R);else{const e=(new THREE.Matrix4).scale((new THREE.Vector3).setFromMatrixScale(p)),t=e.clone().invert(),r=T.clone().multiply(t);w.copy(m).multiply(f).multiply(r).multiply(R)}const I=c.clone().invert(),x=s.clone().invert();let b=t.clone().multiply(l).multiply(c).multiply(r).multiply(n).multiply(o).multiply(I).multiply(i).multiply(s).multiply(a).multiply(x);const H=(new THREE.Matrix4).copyPosition(b),A=u.clone().multiply(H);return h.copyPosition(A),b=h.clone().multiply(w),b.premultiply(u.invert()),b}function T(e){e=e||0;const t=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return 6===e?(console.warn("THREE.FBXLoader: unsupported THREE.Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),t[0]):t[e]}function R(e){const t=e.split(",").map((function(e){return parseFloat(e)}));return t}function w(e,t,r){return void 0===t&&(t=0),void 0===r&&(r=e.byteLength),THREE.LoaderUtils.decodeText(new Uint8Array(e,t,r))}function I(e,t){for(let r=0,n=e.length,o=t.length;r<o;r++,n++)e[n]=t[r]}function x(e,t,r,n){for(let o=r,a=0;o<n;o++,a++)e[a]=t[o];return e}function b(e,t,r){return e.slice(0,t).concat(r).concat(e.slice(t))}THREE.FBXLoader=n})();