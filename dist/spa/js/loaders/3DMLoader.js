(function(){const e=new WeakMap;class t extends THREE.Loader{constructor(e){super(e),this.libraryPath="",this.libraryPending=null,this.libraryBinary=null,this.libraryConfig={},this.url="",this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.workerConfig={},this.materials=[],this.warnings=[]}setLibraryPath(e){return this.libraryPath=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(t,r,a,s){const o=new THREE.FileLoader(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),this.url=t,o.load(t,(a=>{if(e.has(a)){const t=e.get(a);return t.promise.then(r).catch(s)}this.decodeObjects(a,t).then((e=>{e.userData.warnings=this.warnings,r(e)})).catch((e=>s(e)))}),a,s)}debug(){console.log("Task load: ",this.workerPool.map((e=>e._taskLoad)))}decodeObjects(t,r){let a,s;const o=t.byteLength,n=this._getWorker(o).then((e=>(a=e,s=this.workerNextTaskID++,new Promise(((e,r)=>{a._callbacks[s]={resolve:e,reject:r},a.postMessage({type:"decode",id:s,buffer:t},[t])}))))).then((e=>this._createGeometry(e.data))).catch((e=>{throw e}));return n.catch((()=>!0)).then((()=>{a&&s&&this._releaseTask(a,s)})),e.set(t,{url:r,promise:n}),n}parse(e,t,r){this.decodeObjects(e,"").then((e=>{e.userData.warnings=this.warnings,t(e)})).catch((e=>r(e)))}_compareMaterials(e){const t={};t.name=e.name,t.color={},t.color.r=e.color.r,t.color.g=e.color.g,t.color.b=e.color.b,t.type=e.type;for(let r=0;r<this.materials.length;r++){const e=this.materials[r],a={};if(a.name=e.name,a.color={},a.color.r=e.color.r,a.color.g=e.color.g,a.color.b=e.color.b,a.type=e.type,JSON.stringify(t)===JSON.stringify(a))return e}return this.materials.push(e),e}_createMaterial(e){if(void 0===e)return new THREE.MeshStandardMaterial({color:new THREE.Color(1,1,1),metalness:.8,name:"default",side:2});const t=e.diffuseColor,r=new THREE.Color(t.r/255,t.g/255,t.b/255);0===t.r&&0===t.g&&0===t.b&&(r.r=1,r.g=1,r.b=1);const a=new THREE.MeshStandardMaterial({color:r,name:e.name,side:2,transparent:e.transparency>0,opacity:1-e.transparency}),s=new THREE.TextureLoader;for(let o=0;o<e.textures.length;o++){const t=e.textures[o];if(null!==t.image){const e=s.load(t.image);switch(t.type){case"Diffuse":a.map=e;break;case"Bump":a.bumpMap=e;break;case"Transparency":a.alphaMap=e,a.transparent=!0;break;case"Emap":a.envMap=e;break}e.wrapS=0===t.wrapU?THREE.RepeatWrapping:THREE.ClampToEdgeWrapping,e.wrapT=0===t.wrapV?THREE.RepeatWrapping:THREE.ClampToEdgeWrapping,e.repeat.set(t.repeat[0],t.repeat[1])}}return a}_createGeometry(e){const t=new THREE.Object3D,r=[],a=[],s=[];t.userData["layers"]=e.layers,t.userData["groups"]=e.groups,t.userData["settings"]=e.settings,t.userData["objectType"]="File3dm",t.userData["materials"]=null,t.name=this.url;let o=e.objects;const n=e.materials;for(let i=0;i<o.length;i++){const c=o[i],l=c.attributes;switch(c.objectType){case"InstanceDefinition":a.push(c);break;case"InstanceReference":s.push(c);break;default:let o;if(l.materialIndex>=0){const e=n[l.materialIndex];let t=this._createMaterial(e);t=this._compareMaterials(t),o=this._createObject(c,t)}else{const e=this._createMaterial();o=this._createObject(c,e)}if(void 0===o)continue;const i=e.layers[l.layerIndex];o.visible=!i||e.layers[l.layerIndex].visible,l.isInstanceDefinitionObject?r.push(o):t.add(o);break}}for(let i=0;i<a.length;i++){const e=a[i];o=[];for(let t=0;t<e.attributes.objectIds.length;t++){const a=e.attributes.objectIds[t];for(let e=0;e<r.length;e++){const t=r[e].userData.attributes.id;a===t&&o.push(r[e])}}for(let r=0;r<s.length;r++){const a=s[r];if(a.geometry.parentIdefId===e.attributes.id){const e=new THREE.Object3D,r=a.geometry.xform.array,s=new THREE.Matrix4;s.set(r[0],r[1],r[2],r[3],r[4],r[5],r[6],r[7],r[8],r[9],r[10],r[11],r[12],r[13],r[14],r[15]),e.applyMatrix4(s);for(let t=0;t<o.length;t++)e.add(o[t].clone(!0));t.add(e)}}}return t.userData["materials"]=this.materials,t}_createObject(e,t){const r=new THREE.BufferGeometryLoader,a=e.attributes;let s,o,n,i;switch(e.objectType){case"Point":case"PointSet":s=r.parse(e.geometry),s.attributes.hasOwnProperty("color")?o=new THREE.PointsMaterial({vertexColors:!0,sizeAttenuation:!1,size:2}):(n=a.drawColor,i=new THREE.Color(n.r/255,n.g/255,n.b/255),o=new THREE.PointsMaterial({color:i,sizeAttenuation:!1,size:2})),o=this._compareMaterials(o);const c=new THREE.Points(s,o);return c.userData["attributes"]=a,c.userData["objectType"]=e.objectType,a.name&&(c.name=a.name),c;case"Mesh":case"Extrusion":case"SubD":case"Brep":if(null===e.geometry)return;s=r.parse(e.geometry),s.attributes.hasOwnProperty("color")&&(t.vertexColors=!0),null===t&&(t=this._createMaterial(),t=this._compareMaterials(t));const l=new THREE.Mesh(s,t);return l.castShadow=a.castsShadows,l.receiveShadow=a.receivesShadows,l.userData["attributes"]=a,l.userData["objectType"]=e.objectType,a.name&&(l.name=a.name),l;case"Curve":s=r.parse(e.geometry),n=a.drawColor,i=new THREE.Color(n.r/255,n.g/255,n.b/255),o=new THREE.LineBasicMaterial({color:i}),o=this._compareMaterials(o);const u=new THREE.Line(s,o);return u.userData["attributes"]=a,u.userData["objectType"]=e.objectType,a.name&&(u.name=a.name),u;case"TextDot":s=e.geometry;const p=document.createElement("canvas").getContext("2d"),h=`${s.fontHeight}px ${s.fontFace}`;p.font=h;const d=p.measureText(s.text).width+10,g=s.fontHeight+10,y=window.devicePixelRatio;p.canvas.width=d*y,p.canvas.height=g*y,p.canvas.style.width=d+"px",p.canvas.style.height=g+"px",p.setTransform(y,0,0,y,0,0),p.font=h,p.textBaseline="middle",p.textAlign="center",i=a.drawColor,p.fillStyle=`rgba(${i.r},${i.g},${i.b},${i.a})`,p.fillRect(0,0,d,g),p.fillStyle="white",p.fillText(s.text,d/2,g/2);const m=new THREE.CanvasTexture(p.canvas);m.minFilter=THREE.LinearFilter,m.wrapS=THREE.ClampToEdgeWrapping,m.wrapT=THREE.ClampToEdgeWrapping,o=new THREE.SpriteMaterial({map:m,depthTest:!1});const b=new THREE.Sprite(o);return b.position.set(s.point[0],s.point[1],s.point[2]),b.scale.set(d/10,g/10,1),b.userData["attributes"]=a,b.userData["objectType"]=e.objectType,a.name&&(b.name=a.name),b;case"Light":let T;switch(s=e.geometry,s.lightStyle.name){case"LightStyle_WorldPoint":T=new THREE.PointLight,T.castShadow=a.castsShadows,T.position.set(s.location[0],s.location[1],s.location[2]),T.shadow.normalBias=.1;break;case"LightStyle_WorldSpot":T=new THREE.SpotLight,T.castShadow=a.castsShadows,T.position.set(s.location[0],s.location[1],s.location[2]),T.target.position.set(s.direction[0],s.direction[1],s.direction[2]),T.angle=s.spotAngleRadians,T.shadow.normalBias=.1;break;case"LightStyle_WorldRectangular":T=new THREE.RectAreaLight;const e=Math.abs(s.width[2]),t=Math.abs(s.length[0]);T.position.set(s.location[0]-t/2,s.location[1],s.location[2]-e/2),T.height=t,T.width=e,T.lookAt(new THREE.Vector3(s.direction[0],s.direction[1],s.direction[2]));break;case"LightStyle_WorldDirectional":T=new THREE.DirectionalLight,T.castShadow=a.castsShadows,T.position.set(s.location[0],s.location[1],s.location[2]),T.target.position.set(s.direction[0],s.direction[1],s.direction[2]),T.shadow.normalBias=.1;break;case"LightStyle_WorldLinear":break;default:break}return T&&(T.intensity=s.intensity,n=s.diffuse,i=new THREE.Color(n.r/255,n.g/255,n.b/255),T.color=i,T.userData["attributes"]=a,T.userData["objectType"]=e.objectType),T}}_initLibrary(){if(!this.libraryPending){const e=new THREE.FileLoader(this.manager);e.setPath(this.libraryPath);const t=new Promise(((t,r)=>{e.load("rhino3dm.js",t,void 0,r)})),a=new THREE.FileLoader(this.manager);a.setPath(this.libraryPath),a.setResponseType("arraybuffer");const s=new Promise(((e,t)=>{a.load("rhino3dm.wasm",e,void 0,t)}));this.libraryPending=Promise.all([t,s]).then((([e,t])=>{this.libraryConfig.wasmBinary=t;const a=r.toString(),s=["/* rhino3dm.js */",e,"/* worker */",a.substring(a.indexOf("{")+1,a.lastIndexOf("}"))].join("\n");this.workerSourceURL=URL.createObjectURL(new Blob([s]))}))}return this.libraryPending}_getWorker(e){return this._initLibrary().then((()=>{if(this.workerPool.length<this.workerLimit){const e=new Worker(this.workerSourceURL);e._callbacks={},e._taskCosts={},e._taskLoad=0,e.postMessage({type:"init",libraryConfig:this.libraryConfig}),e.onmessage=t=>{const r=t.data;switch(r.type){case"warning":this.warnings.push(r.data),console.warn(r.data);break;case"decode":e._callbacks[r.id].resolve(r);break;case"error":e._callbacks[r.id].reject(r);break;default:console.error('THREE.Rhino3dmLoader: Unexpected message, "'+r.type+'"')}},this.workerPool.push(e)}else this.workerPool.sort((function(e,t){return e._taskLoad>t._taskLoad?-1:1}));const t=this.workerPool[this.workerPool.length-1];return t._taskLoad+=e,t}))}_releaseTask(e,t){e._taskLoad-=e._taskCosts[t],delete e._callbacks[t],delete e._taskCosts[t]}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this}}function r(){let e,t,r,a;function s(e,t){const r=new Uint8Array(t),s=e.File3dm.fromByteArray(r),i=[],c=[],l=[],u=[],p=[],h=[],d=[],g=s.objects(),y=g.count;for(let a=0;a<y;a++){const e=g.get(a),t=o(e,s);e.delete(),t&&i.push(t)}for(let a=0;a<s.instanceDefinitions().count();a++){const e=s.instanceDefinitions().get(a),t=n(e);t.objectIds=e.getObjectIds(),i.push({geometry:null,attributes:t,objectType:"InstanceDefinition"})}const m=[e.TextureType.Diffuse,e.TextureType.Bump,e.TextureType.Transparency,e.TextureType.Opacity,e.TextureType.Emap],b=[e.TextureType.PBR_BaseColor,e.TextureType.PBR_Subsurface,e.TextureType.PBR_SubsurfaceScattering,e.TextureType.PBR_SubsurfaceScatteringRadius,e.TextureType.PBR_Metallic,e.TextureType.PBR_Specular,e.TextureType.PBR_SpecularTint,e.TextureType.PBR_Roughness,e.TextureType.PBR_Anisotropic,e.TextureType.PBR_Anisotropic_Rotation,e.TextureType.PBR_Sheen,e.TextureType.PBR_SheenTint,e.TextureType.PBR_Clearcoat,e.TextureType.PBR_ClearcoatBump,e.TextureType.PBR_ClearcoatRoughness,e.TextureType.PBR_OpacityIor,e.TextureType.PBR_OpacityRoughness,e.TextureType.PBR_Emission,e.TextureType.PBR_AmbientOcclusion,e.TextureType.PBR_Displacement];for(let o=0;o<s.materials().count();o++){const e=s.materials().get(o),t=e.physicallyBased();let r=n(e);const i=[];for(let o=0;o<m.length;o++){const t=e.getTexture(m[o]);if(t){let e=m[o].constructor.name;e=e.substring(12,e.length);const r={type:e},n=s.getEmbeddedFileAsBase64(t.fileName);r.wrapU=t.wrapU,r.wrapV=t.wrapV,r.wrapW=t.wrapW;const c=t.uvwTransform.toFloatArray(!0);r.repeat=[c[0],c[5]],n?r.image="data:image/png;base64,"+n:(self.postMessage({type:"warning",id:a,data:{message:`THREE.3DMLoader: Image for ${e} texture not embedded in file.`,type:"missing resource"}}),r.image=null),i.push(r),t.delete()}}if(r.textures=i,t.supported){for(let r=0;r<b.length;r++){const t=e.getTexture(b[r]);if(t){const e=s.getEmbeddedFileAsBase64(t.fileName);let a=b[r].constructor.name;a=a.substring(12,a.length);const o={type:a,image:"data:image/png;base64,"+e};i.push(o),t.delete()}}const t=n(e.physicallyBased());r=Object.assign(t,r)}c.push(r),e.delete(),t.delete()}for(let a=0;a<s.layers().count();a++){const e=s.layers().get(a),t=n(e);l.push(t),e.delete()}for(let a=0;a<s.views().count();a++){const e=s.views().get(a),t=n(e);u.push(t),e.delete()}for(let a=0;a<s.namedViews().count();a++){const e=s.namedViews().get(a),t=n(e);p.push(t),e.delete()}for(let a=0;a<s.groups().count();a++){const e=s.groups().get(a),t=n(e);h.push(t),e.delete()}const T=n(s.settings()),f=s.strings().count();for(let a=0;a<f;a++)d.push(s.strings().get(a));return s.delete(),{objects:i,materials:c,layers:l,views:u,namedViews:p,groups:h,strings:d,settings:T}}function o(e,t){const s=e.geometry(),o=e.attributes();let c,l,u,p,h,d=s.objectType;switch(d){case r.ObjectType.Curve:const e=i(s,100);u={},l={},p={},u.itemSize=3,u.type="Float32Array",u.array=[];for(let t=0;t<e.length;t++)u.array.push(e[t][0]),u.array.push(e[t][1]),u.array.push(e[t][2]);l.position=u,p.attributes=l,c={data:p};break;case r.ObjectType.Point:const g=s.location;u={};const y={};l={},p={},u.itemSize=3,u.type="Float32Array",u.array=[g[0],g[1],g[2]];const m=o.drawColor(t);y.itemSize=3,y.type="Float32Array",y.array=[m.r/255,m.g/255,m.b/255],l.position=u,l.color=y,p.attributes=l,c={data:p};break;case r.ObjectType.PointSet:case r.ObjectType.Mesh:c=s.toThreejsJSON();break;case r.ObjectType.Brep:const b=s.faces();h=new r.Mesh;for(let t=0;t<b.count;t++){const e=b.get(t),a=e.getMesh(r.MeshType.Any);a&&(h.append(a),a.delete()),e.delete()}h.faces().count>0&&(h.compact(),c=h.toThreejsJSON(),b.delete()),h.delete();break;case r.ObjectType.Extrusion:h=s.getMesh(r.MeshType.Any),h&&(c=h.toThreejsJSON(),h.delete());break;case r.ObjectType.TextDot:c=n(s);break;case r.ObjectType.Light:c=n(s),"LightStyle_WorldLinear"===c.lightStyle.name&&self.postMessage({type:"warning",id:a,data:{message:`THREE.3DMLoader: No conversion exists for ${d.constructor.name} ${c.lightStyle.name}`,type:"no conversion",guid:o.id}});break;case r.ObjectType.InstanceReference:c=n(s),c.xform=n(s.xform),c.xform.array=s.xform.toFloatArray(!0);break;case r.ObjectType.SubD:s.subdivide(3),h=r.Mesh.createFromSubDControlNet(s),h&&(c=h.toThreejsJSON(),h.delete());break;default:self.postMessage({type:"warning",id:a,data:{message:`THREE.3DMLoader: Conversion not implemented for ${d.constructor.name}`,type:"not implemented",guid:o.id}});break}if(c)return l=n(o),l.geometry=n(s),o.groupCount>0&&(l.groupIds=o.getGroupList()),o.userStringCount>0&&(l.userStrings=o.getUserStrings()),s.userStringCount>0&&(l.geometry.userStrings=s.getUserStrings()),l.drawColor=o.drawColor(t),d=d.constructor.name,d=d.substring(11,d.length),{geometry:c,attributes:l,objectType:d};self.postMessage({type:"warning",id:a,data:{message:`THREE.3DMLoader: ${d.constructor.name} has no associated mesh geometry.`,type:"missing mesh",guid:o.id}})}function n(e){const t={};for(const r in e){const a=e[r];"function"!==typeof a&&("object"===typeof a&&null!==a&&a.hasOwnProperty("constructor")?t[r]={name:a.constructor.name,value:a.value}:t[r]=a)}return t}function i(e,t){let a=t,s=[];const o=[];if(e instanceof r.LineCurve)return[e.pointAtStart,e.pointAtEnd];if(e instanceof r.PolylineCurve){a=e.pointCount;for(let t=0;t<a;t++)s.push(e.point(t));return s}if(e instanceof r.PolyCurve){const t=e.segmentCount;for(let r=0;r<t;r++){const t=e.segmentCurve(r),o=i(t,a);s=s.concat(o),t.delete()}return s}if(e instanceof r.ArcCurve&&(a=Math.floor(e.angleDegrees/5),a=a<2?2:a),e instanceof r.NurbsCurve&&1===e.degree){const t=e.tryGetPolyline();for(let e=0;e<t.count;e++)s.push(t.get(e));return t.delete(),s}const n=e.domain,c=a-1;for(let r=0;r<a;r++){const t=n[0]+r/c*(n[1]-n[0]);if(t===n[0]||t===n[1]){o.push(t);continue}const a=e.tangentAt(t),s=e.tangentAt(o.slice(-1)[0]),i=a[0]*a[0]+a[1]*a[1]+a[2]*a[2],l=s[0]*s[0]+s[1]*s[1]+s[2]*s[2],u=Math.sqrt(i*l);let p;if(0===u)p=Math.PI/2;else{const e=(a.x*s.x+a.y*s.y+a.z*s.z)/u;p=Math.acos(Math.max(-1,Math.min(1,e)))}p<.1||o.push(t)}return s=o.map((t=>e.pointAt(t))),s}onmessage=function(o){const n=o.data;switch(n.type){case"init":t=n.libraryConfig;const o=t.wasmBinary;let i;e=new Promise((function(e){i={wasmBinary:o,onRuntimeInitialized:e},rhino3dm(i)})).then((()=>{r=i}));break;case"decode":a=n.id;const c=n.buffer;e.then((()=>{try{const e=s(r,c);self.postMessage({type:"decode",id:n.id,data:e})}catch(e){self.postMessage({type:"error",id:n.id,error:e})}}));break}}}THREE.Rhino3dmLoader=t})();