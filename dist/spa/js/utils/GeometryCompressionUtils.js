(function(){function e(e,t){e.geometry||console.error("Mesh must contain geometry. ");const r=e.geometry.attributes.normal;if(r||console.error("Geometry must contain normal attribute. "),r.isPacked)return;3!=r.itemSize&&console.error("normal.itemSize is not 3, which cannot be encoded. ");const i=r.array,s=r.count;let l;if("DEFAULT"==t){l=new Uint8Array(3*s);for(let e=0;e<i.length;e+=3){const t=n(i[e],i[e+1],i[e+2],1);l[e+0]=t[0],l[e+1]=t[1],l[e+2]=t[2]}e.geometry.setAttribute("normal",new THREE.BufferAttribute(l,3,!0)),e.geometry.attributes.normal.bytes=1*l.length}else if("OCT1Byte"==t){l=new Int8Array(2*s);for(let e=0;e<i.length;e+=3){const t=o(i[e],i[e+1],i[e+2],1);l[e/3*2+0]=t[0],l[e/3*2+1]=t[1]}e.geometry.setAttribute("normal",new THREE.BufferAttribute(l,2,!0)),e.geometry.attributes.normal.bytes=1*l.length}else if("OCT2Byte"==t){l=new Int16Array(2*s);for(let e=0;e<i.length;e+=3){const t=o(i[e],i[e+1],i[e+2],2);l[e/3*2+0]=t[0],l[e/3*2+1]=t[1]}e.geometry.setAttribute("normal",new THREE.BufferAttribute(l,2,!0)),e.geometry.attributes.normal.bytes=2*l.length}else if("ANGLES"==t){l=new Uint16Array(2*s);for(let e=0;e<i.length;e+=3){const t=a(i[e],i[e+1],i[e+2]);l[e/3*2+0]=t[0],l[e/3*2+1]=t[1]}e.geometry.setAttribute("normal",new THREE.BufferAttribute(l,2,!0)),e.geometry.attributes.normal.bytes=2*l.length}else console.error("Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. ");e.geometry.attributes.normal.needsUpdate=!0,e.geometry.attributes.normal.isPacked=!0,e.geometry.attributes.normal.packingMethod=t,e.material instanceof THREE.PackedPhongMaterial||(e.material=(new THREE.PackedPhongMaterial).copy(e.material)),"ANGLES"==t&&(e.material.defines.USE_PACKED_NORMAL=0),"OCT1Byte"==t&&(e.material.defines.USE_PACKED_NORMAL=1),"OCT2Byte"==t&&(e.material.defines.USE_PACKED_NORMAL=1),"DEFAULT"==t&&(e.material.defines.USE_PACKED_NORMAL=2)}function t(e){e.geometry||console.error("Mesh must contain geometry. ");const t=e.geometry.attributes.position;if(t||console.error("Geometry must contain position attribute. "),t.isPacked)return;3!=t.itemSize&&console.error("position.itemSize is not 3, which cannot be packed. ");const r=t.array,n=2,a=i(r,n),o=a.quantized,s=a.decodeMat;null==e.geometry.boundingBox&&e.geometry.computeBoundingBox(),null==e.geometry.boundingSphere&&e.geometry.computeBoundingSphere(),e.geometry.setAttribute("position",new THREE.BufferAttribute(o,3)),e.geometry.attributes.position.isPacked=!0,e.geometry.attributes.position.needsUpdate=!0,e.geometry.attributes.position.bytes=o.length*n,e.material instanceof THREE.PackedPhongMaterial||(e.material=(new THREE.PackedPhongMaterial).copy(e.material)),e.material.defines.USE_PACKED_POSITION=0,e.material.uniforms.quantizeMatPos.value=s,e.material.uniforms.quantizeMatPos.needsUpdate=!0}function r(e){e.geometry||console.error("Mesh must contain geometry property. ");const t=e.geometry.attributes.uv;if(t||console.error("Geometry must contain uv attribute. "),t.isPacked)return;const r={min:1/0,max:-1/0},a=t.array;for(let n=0;n<a.length;n++)r.min=Math.min(r.min,a[n]),r.max=Math.max(r.max,a[n]);let o;if(r.min>=-1&&r.max<=1){o=new Uint16Array(a.length);for(let e=0;e<a.length;e+=2){const t=n(a[e],a[e+1],0,2);o[e]=t[0],o[e+1]=t[1]}e.geometry.setAttribute("uv",new THREE.BufferAttribute(o,2,!0)),e.geometry.attributes.uv.isPacked=!0,e.geometry.attributes.uv.needsUpdate=!0,e.geometry.attributes.uv.bytes=2*o.length,e.material instanceof THREE.PackedPhongMaterial||(e.material=(new THREE.PackedPhongMaterial).copy(e.material)),e.material.defines.USE_PACKED_UV=0}else o=s(a,2),e.geometry.setAttribute("uv",new THREE.BufferAttribute(o.quantized,2)),e.geometry.attributes.uv.isPacked=!0,e.geometry.attributes.uv.needsUpdate=!0,e.geometry.attributes.uv.bytes=2*o.quantized.length,e.material instanceof THREE.PackedPhongMaterial||(e.material=(new THREE.PackedPhongMaterial).copy(e.material)),e.material.defines.USE_PACKED_UV=1,e.material.uniforms.quantizeMatUV.value=o.decodeMat,e.material.uniforms.quantizeMatUV.needsUpdate=!0}function n(e,t,r,n){if(1==n){const n=Math.round(.5*(e+1)*255),a=Math.round(.5*(t+1)*255),o=Math.round(.5*(r+1)*255);return new Uint8Array([n,a,o])}if(2==n){const n=Math.round(.5*(e+1)*65535),a=Math.round(.5*(t+1)*65535),o=Math.round(.5*(r+1)*65535);return new Uint16Array([n,a,o])}console.error("number of bytes must be 1 or 2")}function a(e,t,r){const n=parseInt(.5*(1+Math.atan2(t,e)/Math.PI)*65535),a=parseInt(.5*(1+r)*65535);return new Uint16Array([n,a])}function o(e,t,r,n){let a,o,i,s,l;return i=a=m(e,t,r,"floor","floor"),o=u(a),l=c(e,t,r,o),a=m(e,t,r,"ceil","floor"),o=u(a),s=c(e,t,r,o),s>l&&(i=a,l=s),a=m(e,t,r,"floor","ceil"),o=u(a),s=c(e,t,r,o),s>l&&(i=a,l=s),a=m(e,t,r,"ceil","ceil"),o=u(a),s=c(e,t,r,o),s>l&&(i=a),i;function m(e,t,a,o,i){let s=e/(Math.abs(e)+Math.abs(t)+Math.abs(a)),l=t/(Math.abs(e)+Math.abs(t)+Math.abs(a));if(r<0){const e=(1-Math.abs(l))*(s>=0?1:-1),t=(1-Math.abs(s))*(l>=0?1:-1);s=e,l=t;let r=1-Math.abs(s)-Math.abs(l);r>0&&(r+=.001,s+=s>0?r/2:-r/2,l+=l>0?r/2:-r/2)}return 1==n?new Int8Array([Math[o](127.5*s+(s<0?1:0)),Math[i](127.5*l+(l<0?1:0))]):2==n?new Int16Array([Math[o](32767.5*s+(s<0?1:0)),Math[i](32767.5*l+(l<0?1:0))]):void 0}function u(e){let t=e[0],r=e[1];1==n?(t/=t<0?127:128,r/=r<0?127:128):2==n&&(t/=t<0?32767:32768,r/=r<0?32767:32768);const a=1-Math.abs(t)-Math.abs(r);if(a<0){const e=t;t=(1-Math.abs(r))*(t>=0?1:-1),r=(1-Math.abs(e))*(r>=0?1:-1)}const o=Math.sqrt(t*t+r*r+a*a);return[t/o,r/o,a/o]}function c(e,t,r,n){return e*n[0]+t*n[1]+r*n[2]}}function i(e,t){let r,n;1==t?(r=new Uint8Array(e.length),n=255):2==t?(r=new Uint16Array(e.length),n=65535):console.error("number of bytes error! ");const a=new THREE.Matrix4,o=new Float32Array(3),i=new Float32Array(3);o[0]=o[1]=o[2]=Number.MAX_VALUE,i[0]=i[1]=i[2]=-Number.MAX_VALUE;for(let l=0;l<e.length;l+=3)o[0]=Math.min(o[0],e[l+0]),o[1]=Math.min(o[1],e[l+1]),o[2]=Math.min(o[2],e[l+2]),i[0]=Math.max(i[0],e[l+0]),i[1]=Math.max(i[1],e[l+1]),i[2]=Math.max(i[2],e[l+2]);a.scale(new THREE.Vector3((i[0]-o[0])/n,(i[1]-o[1])/n,(i[2]-o[2])/n)),a.elements[12]=o[0],a.elements[13]=o[1],a.elements[14]=o[2],a.transpose();const s=new Float32Array([i[0]!==o[0]?n/(i[0]-o[0]):0,i[1]!==o[1]?n/(i[1]-o[1]):0,i[2]!==o[2]?n/(i[2]-o[2]):0]);for(let l=0;l<e.length;l+=3)r[l+0]=Math.floor((e[l+0]-o[0])*s[0]),r[l+1]=Math.floor((e[l+1]-o[1])*s[1]),r[l+2]=Math.floor((e[l+2]-o[2])*s[2]);return{quantized:r,decodeMat:a}}function s(e,t){let r,n;1==t?(r=new Uint8Array(e.length),n=255):2==t?(r=new Uint16Array(e.length),n=65535):console.error("number of bytes error! ");const a=new THREE.Matrix3,o=new Float32Array(2),i=new Float32Array(2);o[0]=o[1]=Number.MAX_VALUE,i[0]=i[1]=-Number.MAX_VALUE;for(let l=0;l<e.length;l+=2)o[0]=Math.min(o[0],e[l+0]),o[1]=Math.min(o[1],e[l+1]),i[0]=Math.max(i[0],e[l+0]),i[1]=Math.max(i[1],e[l+1]);a.scale((i[0]-o[0])/n,(i[1]-o[1])/n),a.elements[6]=o[0],a.elements[7]=o[1],a.transpose();const s=new Float32Array([i[0]!==o[0]?n/(i[0]-o[0]):0,i[1]!==o[1]?n/(i[1]-o[1]):0]);for(let l=0;l<e.length;l+=2)r[l+0]=Math.floor((e[l+0]-o[0])*s[0]),r[l+1]=Math.floor((e[l+1]-o[1])*s[1]);return{quantized:r,decodeMat:a}}THREE.GeometryCompressionUtils={},THREE.GeometryCompressionUtils.compressNormals=e,THREE.GeometryCompressionUtils.compressPositions=t,THREE.GeometryCompressionUtils.compressUvs=r})();