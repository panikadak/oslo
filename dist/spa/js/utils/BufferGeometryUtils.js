(function(){function e(e){e.computeTangents(),console.warn("THREE.BufferGeometryUtils: .computeTangents() has been removed. Use THREE.BufferGeometry.computeTangents() instead.")}function t(e,t=!1){const o=null!==e[0].index,n=new Set(Object.keys(e[0].attributes)),i=new Set(Object.keys(e[0].morphAttributes)),s={},u={},a=e[0].morphTargetsRelative,f=new THREE.BufferGeometry;let l=0;for(let r=0;r<e.length;++r){const m=e[r];let c=0;if(o!==(null!==m.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+r+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const e in m.attributes){if(!n.has(e))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+r+'. All geometries must have compatible attributes; make sure "'+e+'" attribute exists among all geometries, or in none of them.'),null;void 0===s[e]&&(s[e]=[]),s[e].push(m.attributes[e]),c++}if(c!==n.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+r+". Make sure all geometries have the same number of attributes."),null;if(a!==m.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+r+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const e in m.morphAttributes){if(!i.has(e))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+r+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===u[e]&&(u[e]=[]),u[e].push(m.morphAttributes[e])}if(f.userData.mergedUserData=f.userData.mergedUserData||[],f.userData.mergedUserData.push(m.userData),t){let e;if(o)e=m.index.count;else{if(void 0===m.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+r+". The geometry must have either an index or a position attribute"),null;e=m.attributes.position.count}f.addGroup(l,e,r),l+=e}}if(o){let t=0;const r=[];for(let o=0;o<e.length;++o){const n=e[o].index;for(let e=0;e<n.count;++e)r.push(n.getX(e)+t);t+=e[o].attributes.position.count}f.setIndex(r)}for(const m in s){const e=r(s[m]);if(!e)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+m+" attribute."),null;f.setAttribute(m,e)}for(const m in u){const e=u[m][0].length;if(0===e)break;f.morphAttributes=f.morphAttributes||{},f.morphAttributes[m]=[];for(let t=0;t<e;++t){const e=[];for(let r=0;r<u[m].length;++r)e.push(u[m][r][t]);const o=r(e);if(!o)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+m+" morphAttribute."),null;f.morphAttributes[m].push(o)}}return f}function r(e){let t,r,o,n=0;for(let u=0;u<e.length;++u){const i=e[u];if(i.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===t&&(t=i.array.constructor),t!==i.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. THREE.BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===r&&(r=i.itemSize),r!==i.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. THREE.BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===o&&(o=i.normalized),o!==i.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. THREE.BufferAttribute.normalized must be consistent across matching attributes."),null;n+=i.array.length}const i=new t(n);let s=0;for(let u=0;u<e.length;++u)i.set(e[u].array,s),s+=e[u].array.length;return new THREE.BufferAttribute(i,r,o)}function o(e){let t,r=0,o=0;for(let f=0,l=e.length;f<l;++f){const n=e[f];if(void 0===t&&(t=n.array.constructor),t!==n.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;r+=n.array.length,o+=n.itemSize}const n=new THREE.InterleavedBuffer(new t(r),o);let i=0;const s=[],u=["getX","getY","getZ","getW"],a=["setX","setY","setZ","setW"];for(let f=0,l=e.length;f<l;f++){const t=e[f],r=t.itemSize,o=t.count,l=new THREE.InterleavedBufferAttribute(n,r,i,t.normalized);s.push(l),i+=r;for(let e=0;e<o;e++)for(let o=0;o<r;o++)l[a[o]](e,t[u[o]](e))}return s}function n(e){let t=0;for(const o in e.attributes){const r=e.getAttribute(o);t+=r.count*r.itemSize*r.array.BYTES_PER_ELEMENT}const r=e.getIndex();return t+=r?r.count*r.itemSize*r.array.BYTES_PER_ELEMENT:0,t}function i(e,t=1e-4){t=Math.max(t,Number.EPSILON);const r={},o=e.getIndex(),n=e.getAttribute("position"),i=o?o.count:n.count;let s=0;const u=Object.keys(e.attributes),a={},f={},l=[],m=["getX","getY","getZ","getW"];for(let d=0,h=u.length;d<h;d++){const t=u[d];a[t]=[];const r=e.morphAttributes[t];r&&(f[t]=new Array(r.length).fill().map((()=>[])))}const c=Math.log10(1/t),g=Math.pow(10,c);for(let d=0;d<i;d++){const t=o?o.getX(d):d;let n="";for(let r=0,o=u.length;r<o;r++){const o=u[r],i=e.getAttribute(o),s=i.itemSize;for(let e=0;e<s;e++)n+=~~(i[m[e]](t)*g)+","}if(n in r)l.push(r[n]);else{for(let r=0,o=u.length;r<o;r++){const o=u[r],n=e.getAttribute(o),i=e.morphAttributes[o],s=n.itemSize,l=a[o],c=f[o];for(let e=0;e<s;e++){const r=m[e];if(l.push(n[r](t)),i)for(let e=0,o=i.length;e<o;e++)c[e].push(i[e][r](t))}}r[n]=s,l.push(s),s++}}const E=e.clone();for(let d=0,h=u.length;d<h;d++){const t=u[d],r=e.getAttribute(t),o=new r.array.constructor(a[t]),n=new THREE.BufferAttribute(o,r.itemSize,r.normalized);if(E.setAttribute(t,n),t in f)for(let i=0;i<f[t].length;i++){const r=e.morphAttributes[t][i],o=new r.array.constructor(f[t][i]),n=new THREE.BufferAttribute(o,r.itemSize,r.normalized);E.morphAttributes[t][i]=n}}return E.setIndex(l),E}function s(e,t){if(t===THREE.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(t===THREE.TriangleFanDrawMode||t===THREE.TriangleStripDrawMode){let r=e.getIndex();if(null===r){const t=[],o=e.getAttribute("position");if(void 0===o)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let e=0;e<o.count;e++)t.push(e);e.setIndex(t),r=e.getIndex()}const o=r.count-2,n=[];if(t===THREE.TriangleFanDrawMode)for(let e=1;e<=o;e++)n.push(r.getX(0)),n.push(r.getX(e)),n.push(r.getX(e+1));else for(let e=0;e<o;e++)e%2===0?(n.push(r.getX(e)),n.push(r.getX(e+1)),n.push(r.getX(e+2))):(n.push(r.getX(e+2)),n.push(r.getX(e+1)),n.push(r.getX(e)));n.length/3!==o&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=e.clone();return i.setIndex(n),i.clearGroups(),i}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),e}function u(e){if(!0!==e.geometry.isBufferGeometry)return console.error("THREE.BufferGeometryUtils: Geometry is not of type THREE.BufferGeometry."),null;const t=new THREE.Vector3,r=new THREE.Vector3,o=new THREE.Vector3,n=new THREE.Vector3,i=new THREE.Vector3,s=new THREE.Vector3,u=new THREE.Vector3,a=new THREE.Vector3,f=new THREE.Vector3;function l(e,l,m,c,g,E,d,h,b){t.fromBufferAttribute(m,E),r.fromBufferAttribute(m,d),o.fromBufferAttribute(m,h);const T=e.morphTargetInfluences;if(l.morphTargets&&c&&T){u.set(0,0,0),a.set(0,0,0),f.set(0,0,0);for(let e=0,l=c.length;e<l;e++){const l=T[e],m=c[e];0!==l&&(n.fromBufferAttribute(m,E),i.fromBufferAttribute(m,d),s.fromBufferAttribute(m,h),g?(u.addScaledVector(n,l),a.addScaledVector(i,l),f.addScaledVector(s,l)):(u.addScaledVector(n.sub(t),l),a.addScaledVector(i.sub(r),l),f.addScaledVector(s.sub(o),l)))}t.add(u),r.add(a),o.add(f)}e.isSkinnedMesh&&(e.boneTransform(E,t),e.boneTransform(d,r),e.boneTransform(h,o)),b[3*E+0]=t.x,b[3*E+1]=t.y,b[3*E+2]=t.z,b[3*d+0]=r.x,b[3*d+1]=r.y,b[3*d+2]=r.z,b[3*h+0]=o.x,b[3*h+1]=o.y,b[3*h+2]=o.z}const m=e.geometry,c=e.material;let g,E,d;const h=m.index,b=m.attributes.position,T=m.morphAttributes.position,y=m.morphTargetsRelative,p=m.attributes.normal,B=m.morphAttributes.position,A=m.groups,R=m.drawRange;let H,w,G,U,x,S,M,v;const z=new Float32Array(b.count*b.itemSize),X=new Float32Array(p.count*p.itemSize);if(null!==h)if(Array.isArray(c))for(H=0,G=A.length;H<G;H++)for(x=A[H],S=c[x.materialIndex],M=Math.max(x.start,R.start),v=Math.min(x.start+x.count,R.start+R.count),w=M,U=v;w<U;w+=3)g=h.getX(w),E=h.getX(w+1),d=h.getX(w+2),l(e,S,b,T,y,g,E,d,z),l(e,S,p,B,y,g,E,d,X);else for(M=Math.max(0,R.start),v=Math.min(h.count,R.start+R.count),H=M,G=v;H<G;H+=3)g=h.getX(H),E=h.getX(H+1),d=h.getX(H+2),l(e,c,b,T,y,g,E,d,z),l(e,c,p,B,y,g,E,d,X);else if(void 0!==b)if(Array.isArray(c))for(H=0,G=A.length;H<G;H++)for(x=A[H],S=c[x.materialIndex],M=Math.max(x.start,R.start),v=Math.min(x.start+x.count,R.start+R.count),w=M,U=v;w<U;w+=3)g=w,E=w+1,d=w+2,l(e,S,b,T,y,g,E,d,z),l(e,S,p,B,y,g,E,d,X);else for(M=Math.max(0,R.start),v=Math.min(b.count,R.start+R.count),H=M,G=v;H<G;H+=3)g=H,E=H+1,d=H+2,l(e,c,b,T,y,g,E,d,z),l(e,c,p,B,y,g,E,d,X);const D=new THREE.Float32BufferAttribute(z,3),I=new THREE.Float32BufferAttribute(X,3);return{positionAttribute:b,normalAttribute:p,morphedPositionAttribute:D,morphedNormalAttribute:I}}THREE.BufferGeometryUtils={},THREE.BufferGeometryUtils.computeMorphedAttributes=u,THREE.BufferGeometryUtils.computeTangents=e,THREE.BufferGeometryUtils.estimateBytesUsed=n,THREE.BufferGeometryUtils.interleaveAttributes=o,THREE.BufferGeometryUtils.mergeBufferAttributes=r,THREE.BufferGeometryUtils.mergeBufferGeometries=t,THREE.BufferGeometryUtils.mergeVertices=i,THREE.BufferGeometryUtils.toTrianglesDrawMode=s})();