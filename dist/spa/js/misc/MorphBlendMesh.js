(function(){class t extends THREE.Mesh{constructor(t,i){super(t,i),this.animationsMap={},this.animationsList=[];const n=Object.keys(this.morphTargetDictionary).length,a="__default",e=0,s=n-1,o=n/1;this.createAnimation(a,e,s,o),this.setAnimationWeight(a,1)}createAnimation(t,i,n,a){const e={start:i,end:n,length:n-i+1,fps:a,duration:(n-i)/a,lastFrame:0,currentFrame:0,active:!1,time:0,direction:1,weight:1,directionBackwards:!1,mirroredLoop:!1};this.animationsMap[t]=e,this.animationsList.push(e)}autoCreateAnimations(t){const i=/([a-z]+)_?(\d+)/i;let n;const a={};let e=0;for(const s in this.morphTargetDictionary){const t=s.match(i);if(t&&t.length>1){const i=t[1];a[i]||(a[i]={start:1/0,end:-1/0});const s=a[i];e<s.start&&(s.start=e),e>s.end&&(s.end=e),n||(n=i)}e++}for(const s in a){const i=a[s];this.createAnimation(s,i.start,i.end,t)}this.firstAnimation=n}setAnimationDirectionForward(t){const i=this.animationsMap[t];i&&(i.direction=1,i.directionBackwards=!1)}setAnimationDirectionBackward(t){const i=this.animationsMap[t];i&&(i.direction=-1,i.directionBackwards=!0)}setAnimationFPS(t,i){const n=this.animationsMap[t];n&&(n.fps=i,n.duration=(n.end-n.start)/n.fps)}setAnimationDuration(t,i){const n=this.animationsMap[t];n&&(n.duration=i,n.fps=(n.end-n.start)/n.duration)}setAnimationWeight(t,i){const n=this.animationsMap[t];n&&(n.weight=i)}setAnimationTime(t,i){const n=this.animationsMap[t];n&&(n.time=i)}getAnimationTime(t){let i=0;const n=this.animationsMap[t];return n&&(i=n.time),i}getAnimationDuration(t){let i=-1;const n=this.animationsMap[t];return n&&(i=n.duration),i}playAnimation(t){const i=this.animationsMap[t];i?(i.time=0,i.active=!0):console.warn("THREE.MorphBlendMesh: animation["+t+"] undefined in .playAnimation()")}stopAnimation(t){const i=this.animationsMap[t];i&&(i.active=!1)}update(t){for(let i=0,n=this.animationsList.length;i<n;i++){const n=this.animationsList[i];if(!n.active)continue;const a=n.duration/n.length;n.time+=n.direction*t,n.mirroredLoop?(n.time>n.duration||n.time<0)&&(n.direction*=-1,n.time>n.duration&&(n.time=n.duration,n.directionBackwards=!0),n.time<0&&(n.time=0,n.directionBackwards=!1)):(n.time=n.time%n.duration,n.time<0&&(n.time+=n.duration));const e=n.start+THREE.MathUtils.clamp(Math.floor(n.time/a),0,n.length-1),s=n.weight;e!==n.currentFrame&&(this.morphTargetInfluences[n.lastFrame]=0,this.morphTargetInfluences[n.currentFrame]=1*s,this.morphTargetInfluences[e]=0,n.lastFrame=n.currentFrame,n.currentFrame=e);let o=n.time%a/a;n.directionBackwards&&(o=1-o),n.currentFrame!==n.lastFrame?(this.morphTargetInfluences[n.currentFrame]=o*s,this.morphTargetInfluences[n.lastFrame]=(1-o)*s):this.morphTargetInfluences[n.currentFrame]=s}}}THREE.MorphBlendMesh=t})();