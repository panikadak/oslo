(function(){const t=new THREE.Vector3;class e{constructor(t=1.4,e=1e-4){this.minSizeForBreak=t,this.smallDelta=e,this.tempLine1=new THREE.Line3,this.tempPlane1=new THREE.Plane,this.tempPlane2=new THREE.Plane,this.tempPlane_Cut=new THREE.Plane,this.tempCM1=new THREE.Vector3,this.tempCM2=new THREE.Vector3,this.tempVector3=new THREE.Vector3,this.tempVector3_2=new THREE.Vector3,this.tempVector3_3=new THREE.Vector3,this.tempVector3_P0=new THREE.Vector3,this.tempVector3_P1=new THREE.Vector3,this.tempVector3_P2=new THREE.Vector3,this.tempVector3_N0=new THREE.Vector3,this.tempVector3_N1=new THREE.Vector3,this.tempVector3_AB=new THREE.Vector3,this.tempVector3_CB=new THREE.Vector3,this.tempResultObjects={object1:null,object2:null},this.segments=[];const s=900;for(let o=0;o<s;o++)this.segments[o]=!1}prepareBreakableObject(t,e,s,o,n){t.geometry.isBufferGeometry||console.error("THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry.");const r=t.userData;r.mass=e,r.velocity=s.clone(),r.angularVelocity=o.clone(),r.breakable=n}subdivideByImpact(t,e,s,o,n){const r=[],a=this.tempPlane1,c=this.tempPlane2;this.tempVector3.addVectors(e,s),a.setFromCoplanarPoints(e,t.position,this.tempVector3);const i=n+o,l=this;function m(n,p,h,u){if(Math.random()<.05*u||u>i)return void r.push(n);let E=Math.PI;0===u?(c.normal.copy(a.normal),c.constant=a.constant):u<=o?(E=(h-p)*(.2+.6*Math.random())+p,l.tempVector3_2.copy(t.position).sub(e).applyAxisAngle(s,E).add(e),c.setFromCoplanarPoints(e,l.tempVector3,l.tempVector3_2)):(E=(.5*(1&u)+.2*(2-Math.random()))*Math.PI,l.tempVector3_2.copy(e).sub(n.position).applyAxisAngle(s,E).add(n.position),l.tempVector3_3.copy(s).add(n.position),c.setFromCoplanarPoints(n.position,l.tempVector3_3,l.tempVector3_2)),l.cutByPlane(n,c,l.tempResultObjects);const V=l.tempResultObjects.object1,y=l.tempResultObjects.object2;V&&m(V,p,E,u+1),y&&m(y,E,h,u+1)}return m(t,0,2*Math.PI,0),r}cutByPlane(t,s,o){const n=t.geometry,r=n.attributes.position.array,a=n.attributes.normal.array,c=r.length/3;let i=c/3,l=n.getIndex();function m(t,e){const s=3*t+e;return l?l[s]:s}l&&(l=l.array,i=l.length/3);const p=[],h=[],u=this.smallDelta,E=c*c;for(let e=0;e<E;e++)this.segments[e]=!1;const V=this.tempVector3_P0,y=this.tempVector3_P1,d=this.tempVector3_N0,b=this.tempVector3_N1;for(let e=0;e<i-1;e++){const t=m(e,0),s=m(e,1),o=m(e,2);d.set(a[t],a[t]+1,a[t]+2);for(let n=e+1;n<i;n++){const e=m(n,0),r=m(n,1),i=m(n,2);b.set(a[e],a[e]+1,a[e]+2);const l=1-d.dot(b)<u;l&&(t===e||t===r||t===i?s===e||s===r||s===i?(this.segments[t*c+s]=!0,this.segments[s*c+t]=!0):(this.segments[o*c+t]=!0,this.segments[t*c+o]=!0):s!==e&&s!==r&&s!==i||(this.segments[o*c+s]=!0,this.segments[s*c+o]=!0))}}const f=this.tempPlane_Cut;t.updateMatrix(),e.transformPlaneToLocalSpace(s,t.matrix,f);for(let e=0;e<i;e++){const t=m(e,0),s=m(e,1),n=m(e,2);for(let e=0;e<3;e++){const a=0===e?t:1===e?s:n,i=0===e?s:1===e?n:t,l=this.segments[a*c+i];if(l)continue;this.segments[a*c+i]=!0,this.segments[i*c+a]=!0,V.set(r[3*a],r[3*a+1],r[3*a+2]),y.set(r[3*i],r[3*i+1],r[3*i+2]);let m=0,E=f.distanceToPoint(V);E>u?(m=2,h.push(V.clone())):E<-u?(m=1,p.push(V.clone())):(m=3,p.push(V.clone()),h.push(V.clone()));let d=0;if(E=f.distanceToPoint(y),E>u?(d=2,h.push(y.clone())):E<-u?(d=1,p.push(y.clone())):(d=3,p.push(y.clone()),h.push(y.clone())),1===m&&2===d||2===m&&1===d){this.tempLine1.start.copy(V),this.tempLine1.end.copy(y);let t=new THREE.Vector3;if(t=f.intersectLine(this.tempLine1,t),null===t)return console.error("Internal error: segment does not intersect plane."),o.segmentedObject1=null,o.segmentedObject2=null,0;p.push(t),h.push(t.clone())}}}const T=.5*t.userData.mass;this.tempCM1.set(0,0,0);let P=0;const R=p.length;if(R>0){for(let t=0;t<R;t++)this.tempCM1.add(p[t]);this.tempCM1.divideScalar(R);for(let t=0;t<R;t++){const e=p[t];e.sub(this.tempCM1),P=Math.max(P,e.x,e.y,e.z)}this.tempCM1.add(t.position)}this.tempCM2.set(0,0,0);let g=0;const M=h.length;if(M>0){for(let t=0;t<M;t++)this.tempCM2.add(h[t]);this.tempCM2.divideScalar(M);for(let t=0;t<M;t++){const e=h[t];e.sub(this.tempCM2),g=Math.max(g,e.x,e.y,e.z)}this.tempCM2.add(t.position)}let C=null,H=null,w=0;return R>4&&(C=new THREE.Mesh(new THREE.ConvexGeometry(p),t.material),C.position.copy(this.tempCM1),C.quaternion.copy(t.quaternion),this.prepareBreakableObject(C,T,t.userData.velocity,t.userData.angularVelocity,2*P>this.minSizeForBreak),w++),M>4&&(H=new THREE.Mesh(new THREE.ConvexGeometry(h),t.material),H.position.copy(this.tempCM2),H.quaternion.copy(t.quaternion),this.prepareBreakableObject(H,T,t.userData.velocity,t.userData.angularVelocity,2*g>this.minSizeForBreak),w++),o.object1=C,o.object2=H,w}static transformFreeVector(t,e){const s=t.x,o=t.y,n=t.z,r=e.elements;return t.x=r[0]*s+r[4]*o+r[8]*n,t.y=r[1]*s+r[5]*o+r[9]*n,t.z=r[2]*s+r[6]*o+r[10]*n,t}static transformFreeVectorInverse(t,e){const s=t.x,o=t.y,n=t.z,r=e.elements;return t.x=r[0]*s+r[1]*o+r[2]*n,t.y=r[4]*s+r[5]*o+r[6]*n,t.z=r[8]*s+r[9]*o+r[10]*n,t}static transformTiedVectorInverse(t,e){const s=t.x,o=t.y,n=t.z,r=e.elements;return t.x=r[0]*s+r[1]*o+r[2]*n-r[12],t.y=r[4]*s+r[5]*o+r[6]*n-r[13],t.z=r[8]*s+r[9]*o+r[10]*n-r[14],t}static transformPlaneToLocalSpace(s,o,n){n.normal.copy(s.normal),n.constant=s.constant;const r=e.transformTiedVectorInverse(s.coplanarPoint(t),o);e.transformFreeVectorInverse(n.normal,o),n.constant=-r.dot(n.normal)}}THREE.ConvexObjectBreaker=e})();