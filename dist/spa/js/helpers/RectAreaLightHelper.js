(function(){class t extends THREE.Line{constructor(t,i){const e=[1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],o=new THREE.BufferGeometry;o.setAttribute("position",new THREE.Float32BufferAttribute(e,3)),o.computeBoundingSphere();const s=new THREE.LineBasicMaterial({fog:!1});super(o,s),this.light=t,this.color=i,this.type="RectAreaLightHelper";const r=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],l=new THREE.BufferGeometry;l.setAttribute("position",new THREE.Float32BufferAttribute(r,3)),l.computeBoundingSphere(),this.add(new THREE.Mesh(l,new THREE.MeshBasicMaterial({side:THREE.BackSide,fog:!1})))}updateMatrixWorld(){if(this.scale.set(.5*this.light.width,.5*this.light.height,1),void 0!==this.color)this.material.color.set(this.color),this.children[0].material.color.set(this.color);else{this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);const t=this.material.color,i=Math.max(t.r,t.g,t.b);i>1&&t.multiplyScalar(1/i),this.children[0].material.color.copy(this.material.color)}this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld),this.children[0].matrixWorld.copy(this.matrixWorld)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}THREE.RectAreaLightHelper=t})();