(function(){class t extends THREE.BufferGeometry{constructor(i={}){super(),this.type="LightningStrike",this.init(t.copyParameters(i,i)),this.createMesh()}static createRandomGenerator(){const t=2053,i=[];for(let r=0;r<t;r++)i.push(Math.random());const e={currentSeed:0,random:function(){const r=i[e.currentSeed];return e.currentSeed=(e.currentSeed+1)%t,r},getSeed:function(){return e.currentSeed/t},setSeed:function(i){e.currentSeed=Math.floor(i*t)%t}};return e}static copyParameters(t={},i={}){const e=function(e){return i===t?e:e.clone()};return t.sourceOffset=void 0!==i.sourceOffset?e(i.sourceOffset):new THREE.Vector3(0,100,0),t.destOffset=void 0!==i.destOffset?e(i.destOffset):new THREE.Vector3(0,0,0),t.timeScale=void 0!==i.timeScale?i.timeScale:1,t.roughness=void 0!==i.roughness?i.roughness:.9,t.straightness=void 0!==i.straightness?i.straightness:.7,t.up0=void 0!==i.up0?e(i.up0):new THREE.Vector3(0,0,1),t.up1=void 0!==i.up1?e(i.up1):new THREE.Vector3(0,0,1),t.radius0=void 0!==i.radius0?i.radius0:1,t.radius1=void 0!==i.radius1?i.radius1:1,t.radius0Factor=void 0!==i.radius0Factor?i.radius0Factor:.5,t.radius1Factor=void 0!==i.radius1Factor?i.radius1Factor:.2,t.minRadius=void 0!==i.minRadius?i.minRadius:.2,t.isEternal=void 0!==i.isEternal?i.isEternal:void 0===i.birthTime||void 0===i.deathTime,t.birthTime=i.birthTime,t.deathTime=i.deathTime,t.propagationTimeFactor=void 0!==i.propagationTimeFactor?i.propagationTimeFactor:.1,t.vanishingTimeFactor=void 0!==i.vanishingTimeFactor?i.vanishingTimeFactor:.9,t.subrayPeriod=void 0!==i.subrayPeriod?i.subrayPeriod:4,t.subrayDutyCycle=void 0!==i.subrayDutyCycle?i.subrayDutyCycle:.6,t.maxIterations=void 0!==i.maxIterations?i.maxIterations:9,t.isStatic=void 0!==i.isStatic&&i.isStatic,t.ramification=void 0!==i.ramification?i.ramification:5,t.maxSubrayRecursion=void 0!==i.maxSubrayRecursion?i.maxSubrayRecursion:3,t.recursionProbability=void 0!==i.recursionProbability?i.recursionProbability:.6,t.generateUVs=void 0!==i.generateUVs&&i.generateUVs,t.randomGenerator=i.randomGenerator,t.noiseSeed=i.noiseSeed,t.onDecideSubrayCreation=i.onDecideSubrayCreation,t.onSubrayCreation=i.onSubrayCreation,t}update(i){this.isStatic||(this.rayParameters.isEternal||this.rayParameters.birthTime<=i&&i<=this.rayParameters.deathTime?(this.updateMesh(i),i<this.subrays[0].endPropagationTime?this.state=t.RAY_PROPAGATING:i>this.subrays[0].beginVanishingTime?this.state=t.RAY_VANISHING:this.state=t.RAY_STEADY,this.visible=!0):(this.visible=!1,i<this.rayParameters.birthTime?this.state=t.RAY_UNBORN:this.state=t.RAY_EXTINGUISHED))}init(i){this.rayParameters=i,this.maxIterations=void 0!==i.maxIterations?Math.floor(i.maxIterations):9,i.maxIterations=this.maxIterations,this.isStatic=void 0!==i.isStatic&&i.isStatic,i.isStatic=this.isStatic,this.ramification=void 0!==i.ramification?Math.floor(i.ramification):5,i.ramification=this.ramification,this.maxSubrayRecursion=void 0!==i.maxSubrayRecursion?Math.floor(i.maxSubrayRecursion):3,i.maxSubrayRecursion=this.maxSubrayRecursion,this.recursionProbability=void 0!==i.recursionProbability?i.recursionProbability:.6,i.recursionProbability=this.recursionProbability,this.generateUVs=void 0!==i.generateUVs&&i.generateUVs,i.generateUVs=this.generateUVs,void 0!==i.randomGenerator?(this.randomGenerator=i.randomGenerator,this.seedGenerator=i.randomGenerator,void 0!==i.noiseSeed&&this.seedGenerator.setSeed(i.noiseSeed)):(this.randomGenerator=t.createRandomGenerator(),this.seedGenerator=Math),void 0!==i.onDecideSubrayCreation?this.onDecideSubrayCreation=i.onDecideSubrayCreation:(this.createDefaultSubrayCreationCallbacks(),void 0!==i.onSubrayCreation&&(this.onSubrayCreation=i.onSubrayCreation)),this.state=t.RAY_INITIALIZED,this.maxSubrays=Math.ceil(1+Math.pow(this.ramification,Math.max(0,this.maxSubrayRecursion-1))),i.maxSubrays=this.maxSubrays,this.maxRaySegments=2*(1<<this.maxIterations),this.subrays=[];for(let t=0;t<this.maxSubrays;t++)this.subrays.push(this.createSubray());this.raySegments=[];for(let t=0;t<this.maxRaySegments;t++)this.raySegments.push(this.createSegment());this.time=0,this.timeFraction=0,this.currentSegmentCallback=null,this.currentCreateTriangleVertices=this.generateUVs?this.createTriangleVerticesWithUVs:this.createTriangleVerticesWithoutUVs,this.numSubrays=0,this.currentSubray=null,this.currentSegmentIndex=0,this.isInitialSegment=!1,this.subrayProbability=0,this.currentVertex=0,this.currentIndex=0,this.currentCoordinate=0,this.currentUVCoordinate=0,this.vertices=null,this.uvs=null,this.indices=null,this.positionAttribute=null,this.uvsAttribute=null,this.simplexX=new THREE.SimplexNoise(this.seedGenerator),this.simplexY=new THREE.SimplexNoise(this.seedGenerator),this.simplexZ=new THREE.SimplexNoise(this.seedGenerator),this.forwards=new THREE.Vector3,this.forwardsFill=new THREE.Vector3,this.side=new THREE.Vector3,this.down=new THREE.Vector3,this.middlePos=new THREE.Vector3,this.middleLinPos=new THREE.Vector3,this.newPos=new THREE.Vector3,this.vPos=new THREE.Vector3,this.cross1=new THREE.Vector3}createMesh(){const t=1<<this.maxIterations,i=3*(t+1)*this.maxSubrays,e=18*t*this.maxSubrays;this.vertices=new Float32Array(3*i),this.indices=new Uint32Array(e),this.generateUVs&&(this.uvs=new Float32Array(2*i)),this.fillMesh(0),this.setIndex(new THREE.Uint32BufferAttribute(this.indices,1)),this.positionAttribute=new THREE.Float32BufferAttribute(this.vertices,3),this.setAttribute("position",this.positionAttribute),this.generateUVs&&(this.uvsAttribute=new THREE.Float32BufferAttribute(new Float32Array(this.uvs),2),this.setAttribute("uv",this.uvsAttribute)),this.isStatic||(this.index.usage=THREE.DynamicDrawUsage,this.positionAttribute.usage=THREE.DynamicDrawUsage,this.generateUVs&&(this.uvsAttribute.usage=THREE.DynamicDrawUsage)),this.vertices=this.positionAttribute.array,this.indices=this.index.array,this.generateUVs&&(this.uvs=this.uvsAttribute.array)}updateMesh(t){this.fillMesh(t),this.drawRange.count=this.currentIndex,this.index.needsUpdate=!0,this.positionAttribute.needsUpdate=!0,this.generateUVs&&(this.uvsAttribute.needsUpdate=!0)}fillMesh(t){const i=this;this.currentVertex=0,this.currentIndex=0,this.currentCoordinate=0,this.currentUVCoordinate=0,this.fractalRay(t,(function(e){const r=i.currentSubray;t<r.birthTime||(this.rayParameters.isEternal&&0==i.currentSubray.recursion?(i.createPrism(e),i.onDecideSubrayCreation(e,i)):t<r.endPropagationTime?i.timeFraction>=e.fraction0*r.propagationTimeFactor&&(i.createPrism(e),i.onDecideSubrayCreation(e,i)):t<r.beginVanishingTime?(i.createPrism(e),i.onDecideSubrayCreation(e,i)):(i.timeFraction<=r.vanishingTimeFactor+e.fraction1*(1-r.vanishingTimeFactor)&&i.createPrism(e),i.onDecideSubrayCreation(e,i)))}))}addNewSubray(){return this.subrays[this.numSubrays++]}initSubray(t,i){t.pos0.copy(i.sourceOffset),t.pos1.copy(i.destOffset),t.up0.copy(i.up0),t.up1.copy(i.up1),t.radius0=i.radius0,t.radius1=i.radius1,t.birthTime=i.birthTime,t.deathTime=i.deathTime,t.timeScale=i.timeScale,t.roughness=i.roughness,t.straightness=i.straightness,t.propagationTimeFactor=i.propagationTimeFactor,t.vanishingTimeFactor=i.vanishingTimeFactor,t.maxIterations=this.maxIterations,t.seed=void 0!==i.noiseSeed?i.noiseSeed:0,t.recursion=0}fractalRay(t,i){this.time=t,this.currentSegmentCallback=i,this.numSubrays=0,this.initSubray(this.addNewSubray(),this.rayParameters);for(let e=0;e<this.numSubrays;e++){const i=this.subrays[e];this.currentSubray=i,this.randomGenerator.setSeed(i.seed),i.endPropagationTime=THREE.MathUtils.lerp(i.birthTime,i.deathTime,i.propagationTimeFactor),i.beginVanishingTime=THREE.MathUtils.lerp(i.deathTime,i.birthTime,1-i.vanishingTimeFactor);const r=this.randomGenerator.random;i.linPos0.set(r(),r(),r()).multiplyScalar(1e3),i.linPos1.set(r(),r(),r()).multiplyScalar(1e3),this.timeFraction=(t-i.birthTime)/(i.deathTime-i.birthTime),this.currentSegmentIndex=0,this.isInitialSegment=!0;const s=this.getNewSegment();s.iteration=0,s.pos0.copy(i.pos0),s.pos1.copy(i.pos1),s.linPos0.copy(i.linPos0),s.linPos1.copy(i.linPos1),s.up0.copy(i.up0),s.up1.copy(i.up1),s.radius0=i.radius0,s.radius1=i.radius1,s.fraction0=0,s.fraction1=1,s.positionVariationFactor=1-i.straightness,this.subrayProbability=this.ramification*Math.pow(this.recursionProbability,i.recursion)/(1<<i.maxIterations),this.fractalRayRecursive(s)}this.currentSegmentCallback=null,this.currentSubray=null}fractalRayRecursive(t){if(t.iteration>=this.currentSubray.maxIterations)return void this.currentSegmentCallback(t);this.forwards.subVectors(t.pos1,t.pos0);let i=this.forwards.length();i<1e-6&&(this.forwards.set(0,0,.01),i=this.forwards.length());const e=.5*(t.radius0+t.radius1),r=.5*(t.fraction0+t.fraction1),s=this.time*this.currentSubray.timeScale*Math.pow(2,t.iteration);this.middlePos.lerpVectors(t.pos0,t.pos1,.5),this.middleLinPos.lerpVectors(t.linPos0,t.linPos1,.5);const a=this.middleLinPos;this.newPos.set(this.simplexX.noise4d(a.x,a.y,a.z,s),this.simplexY.noise4d(a.x,a.y,a.z,s),this.simplexZ.noise4d(a.x,a.y,a.z,s)),this.newPos.multiplyScalar(t.positionVariationFactor*i),this.newPos.add(this.middlePos);const o=this.getNewSegment();o.pos0.copy(t.pos0),o.pos1.copy(this.newPos),o.linPos0.copy(t.linPos0),o.linPos1.copy(this.middleLinPos),o.up0.copy(t.up0),o.up1.copy(t.up1),o.radius0=t.radius0,o.radius1=e,o.fraction0=t.fraction0,o.fraction1=r,o.positionVariationFactor=t.positionVariationFactor*this.currentSubray.roughness,o.iteration=t.iteration+1;const n=this.getNewSegment();n.pos0.copy(this.newPos),n.pos1.copy(t.pos1),n.linPos0.copy(this.middleLinPos),n.linPos1.copy(t.linPos1),this.cross1.crossVectors(t.up0,this.forwards.normalize()),n.up0.crossVectors(this.forwards,this.cross1).normalize(),n.up1.copy(t.up1),n.radius0=e,n.radius1=t.radius1,n.fraction0=r,n.fraction1=t.fraction1,n.positionVariationFactor=t.positionVariationFactor*this.currentSubray.roughness,n.iteration=t.iteration+1,this.fractalRayRecursive(o),this.fractalRayRecursive(n)}createPrism(t){this.forwardsFill.subVectors(t.pos1,t.pos0).normalize(),this.isInitialSegment&&(this.currentCreateTriangleVertices(t.pos0,t.up0,this.forwardsFill,t.radius0,0),this.isInitialSegment=!1),this.currentCreateTriangleVertices(t.pos1,t.up0,this.forwardsFill,t.radius1,t.fraction1),this.createPrismFaces()}createTriangleVerticesWithoutUVs(i,e,r,s){this.side.crossVectors(e,r).multiplyScalar(s*t.COS30DEG),this.down.copy(e).multiplyScalar(-s*t.SIN30DEG);const a=this.vPos,o=this.vertices;a.copy(i).sub(this.side).add(this.down),o[this.currentCoordinate++]=a.x,o[this.currentCoordinate++]=a.y,o[this.currentCoordinate++]=a.z,a.copy(i).add(this.side).add(this.down),o[this.currentCoordinate++]=a.x,o[this.currentCoordinate++]=a.y,o[this.currentCoordinate++]=a.z,a.copy(e).multiplyScalar(s).add(i),o[this.currentCoordinate++]=a.x,o[this.currentCoordinate++]=a.y,o[this.currentCoordinate++]=a.z,this.currentVertex+=3}createTriangleVerticesWithUVs(i,e,r,s,a){this.side.crossVectors(e,r).multiplyScalar(s*t.COS30DEG),this.down.copy(e).multiplyScalar(-s*t.SIN30DEG);const o=this.vPos,n=this.vertices,c=this.uvs;o.copy(i).sub(this.side).add(this.down),n[this.currentCoordinate++]=o.x,n[this.currentCoordinate++]=o.y,n[this.currentCoordinate++]=o.z,c[this.currentUVCoordinate++]=a,c[this.currentUVCoordinate++]=0,o.copy(i).add(this.side).add(this.down),n[this.currentCoordinate++]=o.x,n[this.currentCoordinate++]=o.y,n[this.currentCoordinate++]=o.z,c[this.currentUVCoordinate++]=a,c[this.currentUVCoordinate++]=.5,o.copy(e).multiplyScalar(s).add(i),n[this.currentCoordinate++]=o.x,n[this.currentCoordinate++]=o.y,n[this.currentCoordinate++]=o.z,c[this.currentUVCoordinate++]=a,c[this.currentUVCoordinate++]=1,this.currentVertex+=3}createPrismFaces(t){const i=this.indices;t=this.currentVertex-6,i[this.currentIndex++]=t+1,i[this.currentIndex++]=t+2,i[this.currentIndex++]=t+5,i[this.currentIndex++]=t+1,i[this.currentIndex++]=t+5,i[this.currentIndex++]=t+4,i[this.currentIndex++]=t+0,i[this.currentIndex++]=t+1,i[this.currentIndex++]=t+4,i[this.currentIndex++]=t+0,i[this.currentIndex++]=t+4,i[this.currentIndex++]=t+3,i[this.currentIndex++]=t+2,i[this.currentIndex++]=t+0,i[this.currentIndex++]=t+3,i[this.currentIndex++]=t+2,i[this.currentIndex++]=t+3,i[this.currentIndex++]=t+5}createDefaultSubrayCreationCallbacks(){const t=this.randomGenerator.random;this.onDecideSubrayCreation=function(i,e){const r=e.currentSubray,s=e.rayParameters.subrayPeriod,a=e.rayParameters.subrayDutyCycle,o=e.rayParameters.isEternal&&0==r.recursion?-t()*s:THREE.MathUtils.lerp(r.birthTime,r.endPropagationTime,i.fraction0)-t()*s,n=e.time-o,c=Math.floor(n/s),u=t()*(c+1),h=n%s<=a*s;let d=0;if(h&&(d=e.subrayProbability),r.recursion<e.maxSubrayRecursion&&e.numSubrays<e.maxSubrays&&t()<d){const n=e.addNewSubray(),h=e.randomGenerator.getSeed();n.seed=u,e.randomGenerator.setSeed(u),n.recursion=r.recursion+1,n.maxIterations=Math.max(1,r.maxIterations-1),n.linPos0.set(t(),t(),t()).multiplyScalar(1e3),n.linPos1.set(t(),t(),t()).multiplyScalar(1e3),n.up0.copy(r.up0),n.up1.copy(r.up1),n.radius0=i.radius0*e.rayParameters.radius0Factor,n.radius1=Math.min(e.rayParameters.minRadius,i.radius1*e.rayParameters.radius1Factor),n.birthTime=o+c*s,n.deathTime=n.birthTime+s*a,e.rayParameters.isEternal||0!=r.recursion||(n.birthTime=Math.max(n.birthTime,r.birthTime),n.deathTime=Math.min(n.deathTime,r.deathTime)),n.timeScale=2*r.timeScale,n.roughness=r.roughness,n.straightness=r.straightness,n.propagationTimeFactor=r.propagationTimeFactor,n.vanishingTimeFactor=r.vanishingTimeFactor,e.onSubrayCreation(i,r,n,e),e.randomGenerator.setSeed(h)}};const i=new THREE.Vector3,e=new THREE.Vector3,r=new THREE.Vector3,s=new THREE.Vector3;this.onSubrayCreation=function(t,i,e,r){r.subrayCylinderPosition(t,i,e,.5,.6,.2)},this.subrayConePosition=function(a,o,n,c,u,h){n.pos0.copy(a.pos0),i.subVectors(o.pos1,o.pos0),e.copy(i).normalize(),i.multiplyScalar(a.fraction0+(1-a.fraction0)*(t()*c));const d=i.length();r.crossVectors(o.up0,e);const m=2*Math.PI*t();r.multiplyScalar(Math.cos(m)),s.copy(o.up0).multiplyScalar(Math.sin(m)),n.pos1.copy(r).add(s).multiplyScalar(d*u*(h+t()*(1-h))).add(i).add(o.pos0)},this.subrayCylinderPosition=function(a,o,n,c,u,h){n.pos0.copy(a.pos0),i.subVectors(o.pos1,o.pos0),e.copy(i).normalize(),i.multiplyScalar(a.fraction0+(1-a.fraction0)*((2*t()-1)*c));const d=i.length();r.crossVectors(o.up0,e);const m=2*Math.PI*t();r.multiplyScalar(Math.cos(m)),s.copy(o.up0).multiplyScalar(Math.sin(m)),n.pos1.copy(r).add(s).multiplyScalar(d*u*(h+t()*(1-h))).add(i).add(o.pos0)}}createSubray(){return{seed:0,maxIterations:0,recursion:0,pos0:new THREE.Vector3,pos1:new THREE.Vector3,linPos0:new THREE.Vector3,linPos1:new THREE.Vector3,up0:new THREE.Vector3,up1:new THREE.Vector3,radius0:0,radius1:0,birthTime:0,deathTime:0,timeScale:0,roughness:0,straightness:0,propagationTimeFactor:0,vanishingTimeFactor:0,endPropagationTime:0,beginVanishingTime:0}}createSegment(){return{iteration:0,pos0:new THREE.Vector3,pos1:new THREE.Vector3,linPos0:new THREE.Vector3,linPos1:new THREE.Vector3,up0:new THREE.Vector3,up1:new THREE.Vector3,radius0:0,radius1:0,fraction0:0,fraction1:0,positionVariationFactor:0}}getNewSegment(){return this.raySegments[this.currentSegmentIndex++]}copy(i){return super.copy(i),this.init(t.copyParameters({},i.rayParameters)),this}clone(){return new this.constructor(t.copyParameters({},this.rayParameters))}}t.prototype.isLightningStrike=!0,t.RAY_INITIALIZED=0,t.RAY_UNBORN=1,t.RAY_PROPAGATING=2,t.RAY_STEADY=3,t.RAY_VANISHING=4,t.RAY_EXTINGUISHED=5,t.COS30DEG=Math.cos(30*Math.PI/180),t.SIN30DEG=Math.sin(30*Math.PI/180),THREE.LightningStrike=t})();