(function(){class e extends THREE.Mesh{constructor(t,r={}){super(t),this.type="Reflector";const n=this,a=void 0!==r.color?new THREE.Color(r.color):new THREE.Color(8355711),o=r.textureWidth||512,i=r.textureHeight||512,l=r.clipBias||0,s=r.shader||e.ReflectorShader,d=new THREE.Plane,c=new THREE.Vector3,u=new THREE.Vector3,m=new THREE.Vector3,p=new THREE.Matrix4,f=new THREE.Vector3(0,0,-1),x=new THREE.Vector4,v=new THREE.Vector3,E=new THREE.Vector3,b=new THREE.Vector4,R=new THREE.Matrix4,g=new THREE.PerspectiveCamera,h={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBFormat},T=new THREE.WebGLRenderTarget(o,i,h);THREE.MathUtils.isPowerOfTwo(o)&&THREE.MathUtils.isPowerOfTwo(i)||(T.texture.generateMipmaps=!1);const M=new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.clone(s.uniforms),fragmentShader:s.fragmentShader,vertexShader:s.vertexShader});M.uniforms["tDiffuse"].value=T.texture,M.uniforms["color"].value=a,M.uniforms["textureMatrix"].value=R,this.material=M,this.onBeforeRender=function(e,t,r){if(u.setFromMatrixPosition(n.matrixWorld),m.setFromMatrixPosition(r.matrixWorld),p.extractRotation(n.matrixWorld),c.set(0,0,1),c.applyMatrix4(p),v.subVectors(u,m),v.dot(c)>0)return;v.reflect(c).negate(),v.add(u),p.extractRotation(r.matrixWorld),f.set(0,0,-1),f.applyMatrix4(p),f.add(m),E.subVectors(u,f),E.reflect(c).negate(),E.add(u),g.position.copy(v),g.up.set(0,1,0),g.up.applyMatrix4(p),g.up.reflect(c),g.lookAt(E),g.far=r.far,g.updateMatrixWorld(),g.projectionMatrix.copy(r.projectionMatrix),R.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),R.multiply(g.projectionMatrix),R.multiply(g.matrixWorldInverse),R.multiply(n.matrixWorld),d.setFromNormalAndCoplanarPoint(c,u),d.applyMatrix4(g.matrixWorldInverse),x.set(d.normal.x,d.normal.y,d.normal.z,d.constant);const a=g.projectionMatrix;b.x=(Math.sign(x.x)+a.elements[8])/a.elements[0],b.y=(Math.sign(x.y)+a.elements[9])/a.elements[5],b.z=-1,b.w=(1+a.elements[10])/a.elements[14],x.multiplyScalar(2/x.dot(b)),a.elements[2]=x.x,a.elements[6]=x.y,a.elements[10]=x.z+1-l,a.elements[14]=x.w,T.texture.encoding=e.outputEncoding,n.visible=!1;const o=e.getRenderTarget(),i=e.xr.enabled,s=e.shadowMap.autoUpdate;e.xr.enabled=!1,e.shadowMap.autoUpdate=!1,e.setRenderTarget(T),e.state.buffers.depth.setMask(!0),!1===e.autoClear&&e.clear(),e.render(t,g),e.xr.enabled=i,e.shadowMap.autoUpdate=s,e.setRenderTarget(o);const h=r.viewport;void 0!==h&&e.state.viewport(h),n.visible=!0},this.getRenderTarget=function(){return T},this.dispose=function(){T.dispose(),n.material.dispose()}}}e.prototype.isReflector=!0,e.ReflectorShader={uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:"\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}",fragmentShader:"\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t}"},THREE.Reflector=e})();