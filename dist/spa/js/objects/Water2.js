(function(){class t extends THREE.Mesh{constructor(e,o={}){super(e),this.type="Water";const r=this,n=void 0!==o.color?new THREE.Color(o.color):new THREE.Color(16777215),a=o.textureWidth||512,l=o.textureHeight||512,i=o.clipBias||0,f=o.flowDirection||new THREE.Vector2(1,0),c=o.flowSpeed||.03,u=o.reflectivity||.02,m=o.scale||1,v=o.shader||t.WaterShader,s=new THREE.TextureLoader,p=o.flowMap||void 0,d=o.normalMap0||s.load("textures/water/Water_1_M_Normal.jpg"),x=o.normalMap1||s.load("textures/water/Water_2_M_Normal.jpg"),g=.15,E=.5*g,w=new THREE.Matrix4,h=new THREE.Clock;if(void 0===THREE.Reflector)return void console.error("THREE.Water: Required component THREE.Reflector not found.");if(void 0===THREE.Refractor)return void console.error("THREE.Water: Required component THREE.Refractor not found.");const y=new THREE.Reflector(e,{textureWidth:a,textureHeight:l,clipBias:i}),R=new THREE.Refractor(e,{textureWidth:a,textureHeight:l,clipBias:i});function M(t){w.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),w.multiply(t.projectionMatrix),w.multiply(t.matrixWorldInverse),w.multiply(r.matrixWorld)}function T(){const t=h.getDelta(),e=r.material.uniforms["config"];e.value.x+=c*t,e.value.y=e.value.x+E,e.value.x>=g?(e.value.x=0,e.value.y=E):e.value.y>=g&&(e.value.y=e.value.y-g)}y.matrixAutoUpdate=!1,R.matrixAutoUpdate=!1,this.material=new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib["fog"],v.uniforms]),vertexShader:v.vertexShader,fragmentShader:v.fragmentShader,transparent:!0,fog:!0}),void 0!==p?(this.material.defines.USE_FLOWMAP="",this.material.uniforms["tFlowMap"]={type:"t",value:p}):this.material.uniforms["flowDirection"]={type:"v2",value:f},d.wrapS=d.wrapT=THREE.RepeatWrapping,x.wrapS=x.wrapT=THREE.RepeatWrapping,this.material.uniforms["tReflectionMap"].value=y.getRenderTarget().texture,this.material.uniforms["tRefractionMap"].value=R.getRenderTarget().texture,this.material.uniforms["tNormalMap0"].value=d,this.material.uniforms["tNormalMap1"].value=x,this.material.uniforms["color"].value=n,this.material.uniforms["reflectivity"].value=u,this.material.uniforms["textureMatrix"].value=w,this.material.uniforms["config"].value.x=0,this.material.uniforms["config"].value.y=E,this.material.uniforms["config"].value.z=E,this.material.uniforms["config"].value.w=m,this.onBeforeRender=function(t,e,o){M(o),T(),r.visible=!1,y.matrixWorld.copy(r.matrixWorld),R.matrixWorld.copy(r.matrixWorld),y.onBeforeRender(t,e,o),R.onBeforeRender(t,e,o),r.visible=!0}}}t.prototype.isWater=!0,t.WaterShader={uniforms:{color:{type:"c",value:null},reflectivity:{type:"f",value:0},tReflectionMap:{type:"t",value:null},tRefractionMap:{type:"t",value:null},tNormalMap0:{type:"t",value:null},tNormalMap1:{type:"t",value:null},textureMatrix:{type:"m4",value:null},config:{type:"v4",value:new THREE.Vector4}},vertexShader:"\n\n\t\t#include <common>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tvCoord = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvToEye = cameraPosition - worldPosition.xyz;\n\n\t\t\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\n\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}",fragmentShader:"\n\n\t\t#include <common>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tuniform sampler2D tReflectionMap;\n\t\tuniform sampler2D tRefractionMap;\n\t\tuniform sampler2D tNormalMap0;\n\t\tuniform sampler2D tNormalMap1;\n\n\t\t#ifdef USE_FLOWMAP\n\t\t\tuniform sampler2D tFlowMap;\n\t\t#else\n\t\t\tuniform vec2 flowDirection;\n\t\t#endif\n\n\t\tuniform vec3 color;\n\t\tuniform float reflectivity;\n\t\tuniform vec4 config;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tfloat flowMapOffset0 = config.x;\n\t\t\tfloat flowMapOffset1 = config.y;\n\t\t\tfloat halfCycle = config.z;\n\t\t\tfloat scale = config.w;\n\n\t\t\tvec3 toEye = normalize( vToEye );\n\n\t\t\t// determine flow direction\n\t\t\tvec2 flow;\n\t\t\t#ifdef USE_FLOWMAP\n\t\t\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n\t\t\t#else\n\t\t\t\tflow = flowDirection;\n\t\t\t#endif\n\t\t\tflow.x *= - 1.0;\n\n\t\t\t// sample normal maps (distort uvs with flowdata)\n\t\t\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\n\t\t\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\n\n\t\t\t// linear interpolate to get the final normal color\n\t\t\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\n\t\t\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\n\t\t\t// calculate normal vector\n\t\t\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\n\t\t\tfloat theta = max( dot( toEye, normal ), 0.0 );\n\t\t\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\n\n\t\t\t// calculate final uv coords\n\t\t\tvec3 coord = vCoord.xyz / vCoord.w;\n\t\t\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n\n\t\t\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n\t\t\tvec4 refractColor = texture2D( tRefractionMap, uv );\n\n\t\t\t// multiply water color with the mix of both textures\n\t\t\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}"},THREE.Water=t})();