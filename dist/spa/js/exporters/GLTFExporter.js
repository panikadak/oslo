(function(){class e{constructor(){this.pluginCallbacks=[],this.register((function(e){return new T(e)})),this.register((function(e){return new x(e)})),this.register((function(e){return new y(e)})),this.register((function(e){return new R(e)})),this.register((function(e){return new M(e)})),this.register((function(e){return new b(e)}))}register(e){return-1===this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.push(e),this}unregister(e){return-1!==this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,s,n){"object"===typeof s&&(console.warn("THREE.GLTFExporter: parse() expects options as the fourth argument now."),n=s);const r=new E,i=[];for(let a=0,o=this.pluginCallbacks.length;a<o;a++)i.push(this.pluginCallbacks[a](r));r.setPlugins(i),r.write(e,t,n).catch(s)}parseAsync(e,t){const s=this;return new Promise((function(n,r){s.parse(e,n,r,t)}))}}const t={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123,FLOAT:5126,UNSIGNED_INT:5125,ARRAY_BUFFER:34962,ELEMENT_ARRAY_BUFFER:34963,NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,LINEAR_MIPMAP_NEAREST:9985,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_LINEAR:9987,CLAMP_TO_EDGE:33071,MIRRORED_REPEAT:33648,REPEAT:10497},s={};s[THREE.NearestFilter]=t.NEAREST,s[THREE.NearestMipmapNearestFilter]=t.NEAREST_MIPMAP_NEAREST,s[THREE.NearestMipmapLinearFilter]=t.NEAREST_MIPMAP_LINEAR,s[THREE.LinearFilter]=t.LINEAR,s[THREE.LinearMipmapNearestFilter]=t.LINEAR_MIPMAP_NEAREST,s[THREE.LinearMipmapLinearFilter]=t.LINEAR_MIPMAP_LINEAR,s[THREE.ClampToEdgeWrapping]=t.CLAMP_TO_EDGE,s[THREE.RepeatWrapping]=t.REPEAT,s[THREE.MirroredRepeatWrapping]=t.MIRRORED_REPEAT;const n={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"},r=12,i=1179937895,a=2,o=8,l=1313821514,c=5130562;function u(e,t){return e.length===t.length&&e.every((function(e,s){return e===t[s]}))}function h(e){if(void 0!==window.TextEncoder)return(new TextEncoder).encode(e).buffer;const t=new Uint8Array(new ArrayBuffer(e.length));for(let s=0,n=e.length;s<n;s++){const n=e.charCodeAt(s);t[s]=n>255?32:n}return t.buffer}function p(e){return u(e.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}function m(e,t,s){const n={min:new Array(e.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(e.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let r=t;r<t+s;r++)for(let t=0;t<e.itemSize;t++){let s;e.itemSize>4?s=e.array[r*e.itemSize+t]:0===t?s=e.getX(r):1===t?s=e.getY(r):2===t?s=e.getZ(r):3===t&&(s=e.getW(r)),n.min[t]=Math.min(n.min[t],s),n.max[t]=Math.max(n.max[t],s)}return n}function f(e){return 4*Math.ceil(e/4)}function g(e,t=0){const s=f(e.byteLength);if(s!==e.byteLength){const n=new Uint8Array(s);if(n.set(new Uint8Array(e)),0!==t)for(let r=e.byteLength;r<s;r++)n[r]=t;return n.buffer}return e}let d=null;class E{constructor(){this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.buffers=[],this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"THREE.GLTFExporter"}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map}}setPlugins(e){this.plugins=e}async write(e,t,s){this.options=Object.assign({},{binary:!1,trs:!1,onlyVisible:!0,truncateDrawRange:!0,embedImages:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},s),this.options.animations.length>0&&(this.options.trs=!0),this.processInput(e),await Promise.all(this.pending);const n=this,u=n.buffers,p=n.json;s=n.options;const m=n.extensionsUsed,f=new Blob(u,{type:"application/octet-stream"}),d=Object.keys(m);if(d.length>0&&(p.extensionsUsed=d),p.buffers&&p.buffers.length>0&&(p.buffers[0].byteLength=f.size),!0===s.binary){const e=new window.FileReader;e.readAsArrayBuffer(f),e.onloadend=function(){const s=g(e.result),n=new DataView(new ArrayBuffer(o));n.setUint32(0,s.byteLength,!0),n.setUint32(4,c,!0);const u=g(h(JSON.stringify(p)),32),m=new DataView(new ArrayBuffer(o));m.setUint32(0,u.byteLength,!0),m.setUint32(4,l,!0);const f=new ArrayBuffer(r),d=new DataView(f);d.setUint32(0,i,!0),d.setUint32(4,a,!0);const E=r+m.byteLength+u.byteLength+n.byteLength+s.byteLength;d.setUint32(8,E,!0);const T=new Blob([f,m,u,n,s],{type:"application/octet-stream"}),x=new window.FileReader;x.readAsArrayBuffer(T),x.onloadend=function(){t(x.result)}}}else if(p.buffers&&p.buffers.length>0){const e=new window.FileReader;e.readAsDataURL(f),e.onloadend=function(){const s=e.result;p.buffers[0].uri=s,t(p)}}else t(p)}serializeUserData(e,t){if(0===Object.keys(e.userData).length)return;const s=this.options,n=this.extensionsUsed;try{const r=JSON.parse(JSON.stringify(e.userData));if(s.includeCustomExtensions&&r.gltfExtensions){void 0===t.extensions&&(t.extensions={});for(const e in r.gltfExtensions)t.extensions[e]=r.gltfExtensions[e],n[e]=!0;delete r.gltfExtensions}Object.keys(r).length>0&&(t.extras=r)}catch(r){console.warn("THREE.GLTFExporter: userData of '"+e.name+"' won't be serialized because of JSON.stringify error - "+r.message)}}getUID(e){return this.uids.has(e)||this.uids.set(e,this.uid++),this.uids.get(e)}isNormalizedNormalAttribute(e){const t=this.cache;if(t.attributesNormalized.has(e))return!1;const s=new THREE.Vector3;for(let n=0,r=e.count;n<r;n++)if(Math.abs(s.fromBufferAttribute(e,n).length()-1)>5e-4)return!1;return!0}createNormalizedNormalAttribute(e){const t=this.cache;if(t.attributesNormalized.has(e))return t.attributesNormalized.get(e);const s=e.clone(),n=new THREE.Vector3;for(let r=0,i=s.count;r<i;r++)n.fromBufferAttribute(s,r),0===n.x&&0===n.y&&0===n.z?n.setX(1):n.normalize(),s.setXYZ(r,n.x,n.y,n.z);return t.attributesNormalized.set(e,s),s}applyTextureTransform(e,t){let s=!1;const n={};0===t.offset.x&&0===t.offset.y||(n.offset=t.offset.toArray(),s=!0),0!==t.rotation&&(n.rotation=t.rotation,s=!0),1===t.repeat.x&&1===t.repeat.y||(n.scale=t.repeat.toArray(),s=!0),s&&(e.extensions=e.extensions||{},e.extensions["KHR_texture_transform"]=n,this.extensionsUsed["KHR_texture_transform"]=!0)}processBuffer(e){const t=this.json,s=this.buffers;return t.buffers||(t.buffers=[{byteLength:0}]),s.push(e),0}processBufferView(e,s,n,r,i){const a=this.json;let o;a.bufferViews||(a.bufferViews=[]),o=s===t.UNSIGNED_BYTE?1:s===t.UNSIGNED_SHORT?2:4;const l=f(r*e.itemSize*o),c=new DataView(new ArrayBuffer(l));let u=0;for(let m=n;m<n+r;m++)for(let n=0;n<e.itemSize;n++){let r;e.itemSize>4?r=e.array[m*e.itemSize+n]:0===n?r=e.getX(m):1===n?r=e.getY(m):2===n?r=e.getZ(m):3===n&&(r=e.getW(m)),s===t.FLOAT?c.setFloat32(u,r,!0):s===t.UNSIGNED_INT?c.setUint32(u,r,!0):s===t.UNSIGNED_SHORT?c.setUint16(u,r,!0):s===t.UNSIGNED_BYTE&&c.setUint8(u,r),u+=o}const h={buffer:this.processBuffer(c.buffer),byteOffset:this.byteOffset,byteLength:l};void 0!==i&&(h.target=i),i===t.ARRAY_BUFFER&&(h.byteStride=e.itemSize*o),this.byteOffset+=l,a.bufferViews.push(h);const p={id:a.bufferViews.length-1,byteLength:0};return p}processBufferViewImage(e){const t=this,s=t.json;return s.bufferViews||(s.bufferViews=[]),new Promise((function(n){const r=new window.FileReader;r.readAsArrayBuffer(e),r.onloadend=function(){const e=g(r.result),i={buffer:t.processBuffer(e),byteOffset:t.byteOffset,byteLength:e.byteLength};t.byteOffset+=e.byteLength,n(s.bufferViews.push(i)-1)}}))}processAccessor(e,s,n,r){const i=this.options,a=this.json,o={1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",16:"MAT4"};let l;if(e.array.constructor===Float32Array)l=t.FLOAT;else if(e.array.constructor===Uint32Array)l=t.UNSIGNED_INT;else if(e.array.constructor===Uint16Array)l=t.UNSIGNED_SHORT;else{if(e.array.constructor!==Uint8Array)throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");l=t.UNSIGNED_BYTE}if(void 0===n&&(n=0),void 0===r&&(r=e.count),i.truncateDrawRange&&void 0!==s&&null===s.index){const t=n+r,i=s.drawRange.count===1/0?e.count:s.drawRange.start+s.drawRange.count;n=Math.max(n,s.drawRange.start),r=Math.min(t,i)-n,r<0&&(r=0)}if(0===r)return null;const c=m(e,n,r);let u;void 0!==s&&(u=e===s.index?t.ELEMENT_ARRAY_BUFFER:t.ARRAY_BUFFER);const h=this.processBufferView(e,l,n,r,u),p={bufferView:h.id,byteOffset:h.byteOffset,componentType:l,count:r,max:c.max,min:c.min,type:o[e.itemSize]};return!0===e.normalized&&(p.normalized=!0),a.accessors||(a.accessors=[]),a.accessors.push(p)-1}processImage(e,t,s){const n=this,r=n.cache,i=n.json,a=n.options,o=n.pending;r.images.has(e)||r.images.set(e,{});const l=r.images.get(e),c=t===THREE.RGBAFormat?"image/png":"image/jpeg",u=c+":flipY/"+s.toString();if(void 0!==l[u])return l[u];i.images||(i.images=[]);const h={mimeType:c};if(a.embedImages){const r=d=d||document.createElement("canvas");r.width=Math.min(e.width,a.maxTextureSize),r.height=Math.min(e.height,a.maxTextureSize);const i=r.getContext("2d");if(!0===s&&(i.translate(0,r.height),i.scale(1,-1)),"undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!==typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!==typeof OffscreenCanvas&&e instanceof OffscreenCanvas||"undefined"!==typeof ImageBitmap&&e instanceof ImageBitmap)i.drawImage(e,0,0,r.width,r.height);else{t!==THREE.RGBAFormat&&t!==THREE.RGBFormat&&console.error("GLTFExporter: Only RGB and RGBA formats are supported."),(e.width>a.maxTextureSize||e.height>a.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",e);const s=new Uint8ClampedArray(e.height*e.width*4);if(t===THREE.RGBAFormat)for(let t=0;t<s.length;t+=4)s[t+0]=e.data[t+0],s[t+1]=e.data[t+1],s[t+2]=e.data[t+2],s[t+3]=e.data[t+3];else for(let t=0,n=0;t<s.length;t+=4,n+=3)s[t+0]=e.data[n+0],s[t+1]=e.data[n+1],s[t+2]=e.data[n+2],s[t+3]=255;i.putImageData(new ImageData(s,e.width,e.height),0,0)}!0===a.binary?o.push(new Promise((function(e){r.toBlob((function(t){n.processBufferViewImage(t).then((function(t){h.bufferView=t,e()}))}),c)}))):h.uri=r.toDataURL(c)}else h.uri=e.src;const p=i.images.push(h)-1;return l[u]=p,p}processSampler(e){const t=this.json;t.samplers||(t.samplers=[]);const n={magFilter:s[e.magFilter],minFilter:s[e.minFilter],wrapS:s[e.wrapS],wrapT:s[e.wrapT]};return t.samplers.push(n)-1}processTexture(e){const t=this.cache,s=this.json;if(t.textures.has(e))return t.textures.get(e);s.textures||(s.textures=[]);const n={sampler:this.processSampler(e),source:this.processImage(e.image,e.format,e.flipY)};e.name&&(n.name=e.name),this._invokeAll((function(t){t.writeTexture&&t.writeTexture(e,n)}));const r=s.textures.push(n)-1;return t.textures.set(e,r),r}processMaterial(e){const t=this.cache,s=this.json;if(t.materials.has(e))return t.materials.get(e);if(e.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;s.materials||(s.materials=[]);const n={pbrMetallicRoughness:{}};!0!==e.isMeshStandardMaterial&&!0!==e.isMeshBasicMaterial&&console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");const r=e.color.toArray().concat([e.opacity]);if(u(r,[1,1,1,1])||(n.pbrMetallicRoughness.baseColorFactor=r),e.isMeshStandardMaterial?(n.pbrMetallicRoughness.metallicFactor=e.metalness,n.pbrMetallicRoughness.roughnessFactor=e.roughness):(n.pbrMetallicRoughness.metallicFactor=.5,n.pbrMetallicRoughness.roughnessFactor=.5),e.metalnessMap||e.roughnessMap)if(e.metalnessMap===e.roughnessMap){const t={index:this.processTexture(e.metalnessMap)};this.applyTextureTransform(t,e.metalnessMap),n.pbrMetallicRoughness.metallicRoughnessTexture=t}else console.warn("THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.");if(e.map){const t={index:this.processTexture(e.map)};this.applyTextureTransform(t,e.map),n.pbrMetallicRoughness.baseColorTexture=t}if(e.emissive){const t=e.emissive.clone().multiplyScalar(e.emissiveIntensity),s=Math.max(t.r,t.g,t.b);if(s>1&&(t.multiplyScalar(1/s),console.warn("THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited")),s>0&&(n.emissiveFactor=t.toArray()),e.emissiveMap){const t={index:this.processTexture(e.emissiveMap)};this.applyTextureTransform(t,e.emissiveMap),n.emissiveTexture=t}}if(e.normalMap){const t={index:this.processTexture(e.normalMap)};e.normalScale&&1!==e.normalScale.x&&(t.scale=e.normalScale.x),this.applyTextureTransform(t,e.normalMap),n.normalTexture=t}if(e.aoMap){const t={index:this.processTexture(e.aoMap),texCoord:1};1!==e.aoMapIntensity&&(t.strength=e.aoMapIntensity),this.applyTextureTransform(t,e.aoMap),n.occlusionTexture=t}e.transparent?n.alphaMode="BLEND":e.alphaTest>0&&(n.alphaMode="MASK",n.alphaCutoff=e.alphaTest),e.side===THREE.DoubleSide&&(n.doubleSided=!0),""!==e.name&&(n.name=e.name),this.serializeUserData(e,n),this._invokeAll((function(t){t.writeMaterial&&t.writeMaterial(e,n)}));const i=s.materials.push(n)-1;return t.materials.set(e,i),i}processMesh(e){const s=this.cache,n=this.json,r=[e.geometry.uuid];if(Array.isArray(e.material))for(let t=0,x=e.material.length;t<x;t++)r.push(e.material[t].uuid);else r.push(e.material.uuid);const i=r.join(":");if(s.meshes.has(i))return s.meshes.get(i);const a=e.geometry;let o;if(o=e.isLineSegments?t.LINES:e.isLineLoop?t.LINE_LOOP:e.isLine?t.LINE_STRIP:e.isPoints?t.POINTS:e.material.wireframe?t.LINES:t.TRIANGLES,!0!==a.isBufferGeometry)throw new Error("THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.");const l={},c={},u=[],h=[],p={uv:"TEXCOORD_0",uv2:"TEXCOORD_1",color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},m=a.getAttribute("normal");void 0===m||this.isNormalizedNormalAttribute(m)||(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),a.setAttribute("normal",this.createNormalizedNormalAttribute(m)));let f=null;for(let t in a.attributes){if("morph"===t.substr(0,5))continue;const e=a.attributes[t];t=p[t]||t.toUpperCase();const n=/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/;if(n.test(t)||(t="_"+t),s.attributes.has(this.getUID(e))){c[t]=s.attributes.get(this.getUID(e));continue}f=null;const r=e.array;"JOINTS_0"!==t||r instanceof Uint16Array||r instanceof Uint8Array||(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),f=new THREE.BufferAttribute(new Uint16Array(r),e.itemSize,e.normalized));const i=this.processAccessor(f||e,a);null!==i&&(c[t]=i,s.attributes.set(this.getUID(e),i))}if(void 0!==m&&a.setAttribute("normal",m),0===Object.keys(c).length)return null;if(void 0!==e.morphTargetInfluences&&e.morphTargetInfluences.length>0){const t=[],n=[],r={};if(void 0!==e.morphTargetDictionary)for(const s in e.morphTargetDictionary)r[e.morphTargetDictionary[s]]=s;for(let i=0;i<e.morphTargetInfluences.length;++i){const o={};let l=!1;for(const e in a.morphAttributes){if("position"!==e&&"normal"!==e){l||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),l=!0);continue}const t=a.morphAttributes[e][i],n=e.toUpperCase(),r=a.attributes[e];if(s.attributes.has(this.getUID(t))){o[n]=s.attributes.get(this.getUID(t));continue}const c=t.clone();if(!a.morphTargetsRelative)for(let e=0,s=t.count;e<s;e++)c.setXYZ(e,t.getX(e)-r.getX(e),t.getY(e)-r.getY(e),t.getZ(e)-r.getZ(e));o[n]=this.processAccessor(c,a),s.attributes.set(this.getUID(r),o[n])}h.push(o),t.push(e.morphTargetInfluences[i]),void 0!==e.morphTargetDictionary&&n.push(r[i])}l.weights=t,n.length>0&&(l.extras={},l.extras.targetNames=n)}const g=Array.isArray(e.material);if(g&&0===a.groups.length)return null;const d=g?e.material:[e.material],E=g?a.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let t=0,x=E.length;t<x;t++){const e={mode:o,attributes:c};if(this.serializeUserData(a,e),h.length>0&&(e.targets=h),null!==a.index){let n=this.getUID(a.index);void 0===E[t].start&&void 0===E[t].count||(n+=":"+E[t].start+":"+E[t].count),s.attributes.has(n)?e.indices=s.attributes.get(n):(e.indices=this.processAccessor(a.index,a,E[t].start,E[t].count),s.attributes.set(n,e.indices)),null===e.indices&&delete e.indices}const n=this.processMaterial(d[E[t].materialIndex]);null!==n&&(e.material=n),u.push(e)}l.primitives=u,n.meshes||(n.meshes=[]),this._invokeAll((function(t){t.writeMesh&&t.writeMesh(e,l)}));const T=n.meshes.push(l)-1;return s.meshes.set(i,T),T}processCamera(e){const t=this.json;t.cameras||(t.cameras=[]);const s=e.isOrthographicCamera,n={type:s?"orthographic":"perspective"};return s?n.orthographic={xmag:2*e.right,ymag:2*e.top,zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near}:n.perspective={aspectRatio:e.aspect,yfov:THREE.MathUtils.degToRad(e.fov),zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near},""!==e.name&&(n.name=e.type),t.cameras.push(n)-1}processAnimation(t,s){const r=this.json,i=this.nodeMap;r.animations||(r.animations=[]),t=e.Utils.mergeMorphTargetTracks(t.clone(),s);const a=t.tracks,o=[],l=[];for(let e=0;e<a.length;++e){const t=a[e],r=THREE.PropertyBinding.parseTrackName(t.name);let c=THREE.PropertyBinding.findNode(s,r.nodeName);const u=n[r.propertyName];if("bones"===r.objectName&&(c=!0===c.isSkinnedMesh?c.skeleton.getBoneByName(r.objectIndex):void 0),!c||!u)return console.warn('THREE.GLTFExporter: Could not export animation track "%s".',t.name),null;const h=1;let p,m=t.values.length/t.times.length;u===n.morphTargetInfluences&&(m/=c.morphTargetInfluences.length),!0===t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline?(p="CUBICSPLINE",m/=3):p=t.getInterpolation()===THREE.InterpolateDiscrete?"STEP":"LINEAR",l.push({input:this.processAccessor(new THREE.BufferAttribute(t.times,h)),output:this.processAccessor(new THREE.BufferAttribute(t.values,m)),interpolation:p}),o.push({sampler:l.length-1,target:{node:i.get(c),path:u}})}return r.animations.push({name:t.name||"clip_"+r.animations.length,samplers:l,channels:o}),r.animations.length-1}processSkin(e){const t=this.json,s=this.nodeMap,n=t.nodes[s.get(e)],r=e.skeleton;if(void 0===r)return null;const i=e.skeleton.bones[0];if(void 0===i)return null;const a=[],o=new Float32Array(16*r.bones.length),l=new THREE.Matrix4;for(let u=0;u<r.bones.length;++u)a.push(s.get(r.bones[u])),l.copy(r.boneInverses[u]),l.multiply(e.bindMatrix).toArray(o,16*u);void 0===t.skins&&(t.skins=[]),t.skins.push({inverseBindMatrices:this.processAccessor(new THREE.BufferAttribute(o,16)),joints:a,skeleton:s.get(i)});const c=n.skin=t.skins.length-1;return c}processNode(e){const t=this.json,s=this.options,n=this.nodeMap;t.nodes||(t.nodes=[]);const r={};if(s.trs){const t=e.quaternion.toArray(),s=e.position.toArray(),n=e.scale.toArray();u(t,[0,0,0,1])||(r.rotation=t),u(s,[0,0,0])||(r.translation=s),u(n,[1,1,1])||(r.scale=n)}else e.matrixAutoUpdate&&e.updateMatrix(),!1===p(e.matrix)&&(r.matrix=e.matrix.elements);if(""!==e.name&&(r.name=String(e.name)),this.serializeUserData(e,r),e.isMesh||e.isLine||e.isPoints){const t=this.processMesh(e);null!==t&&(r.mesh=t)}else e.isCamera&&(r.camera=this.processCamera(e));if(e.isSkinnedMesh&&this.skins.push(e),e.children.length>0){const t=[];for(let n=0,r=e.children.length;n<r;n++){const r=e.children[n];if(r.visible||!1===s.onlyVisible){const e=this.processNode(r);null!==e&&t.push(e)}}t.length>0&&(r.children=t)}this._invokeAll((function(t){t.writeNode&&t.writeNode(e,r)}));const i=t.nodes.push(r)-1;return n.set(e,i),i}processScene(e){const t=this.json,s=this.options;t.scenes||(t.scenes=[],t.scene=0);const n={};""!==e.name&&(n.name=e.name),t.scenes.push(n);const r=[];for(let i=0,a=e.children.length;i<a;i++){const t=e.children[i];if(t.visible||!1===s.onlyVisible){const e=this.processNode(t);null!==e&&r.push(e)}}r.length>0&&(n.nodes=r),this.serializeUserData(e,n)}processObjects(e){const t=new THREE.Scene;t.name="AuxScene";for(let s=0;s<e.length;s++)t.children.push(e[s]);this.processScene(t)}processInput(e){const t=this.options;e=e instanceof Array?e:[e],this._invokeAll((function(t){t.beforeParse&&t.beforeParse(e)}));const s=[];for(let n=0;n<e.length;n++)e[n]instanceof THREE.Scene?this.processScene(e[n]):s.push(e[n]);s.length>0&&this.processObjects(s);for(let n=0;n<this.skins.length;++n)this.processSkin(this.skins[n]);for(let n=0;n<t.animations.length;++n)this.processAnimation(t.animations[n],e[0]);this._invokeAll((function(t){t.afterParse&&t.afterParse(e)}))}_invokeAll(e){for(let t=0,s=this.plugins.length;t<s;t++)e(this.plugins[t])}}class T{constructor(e){this.writer=e,this.name="KHR_lights_punctual"}writeNode(e,t){if(!e.isLight)return;if(!e.isDirectionalLight&&!e.isPointLight&&!e.isSpotLight)return void console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",e);const s=this.writer,n=s.json,r=s.extensionsUsed,i={};e.name&&(i.name=e.name),i.color=e.color.toArray(),i.intensity=e.intensity,e.isDirectionalLight?i.type="directional":e.isPointLight?(i.type="point",e.distance>0&&(i.range=e.distance)):e.isSpotLight&&(i.type="spot",e.distance>0&&(i.range=e.distance),i.spot={},i.spot.innerConeAngle=(e.penumbra-1)*e.angle*-1,i.spot.outerConeAngle=e.angle),void 0!==e.decay&&2!==e.decay&&console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),!e.target||e.target.parent===e&&0===e.target.position.x&&0===e.target.position.y&&-1===e.target.position.z||console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),r[this.name]||(n.extensions=n.extensions||{},n.extensions[this.name]={lights:[]},r[this.name]=!0);const a=n.extensions[this.name].lights;a.push(i),t.extensions=t.extensions||{},t.extensions[this.name]={light:a.length-1}}}class x{constructor(e){this.writer=e,this.name="KHR_materials_unlit"}writeMaterial(e,t){if(!e.isMeshBasicMaterial)return;const s=this.writer,n=s.extensionsUsed;t.extensions=t.extensions||{},t.extensions[this.name]={},n[this.name]=!0,t.pbrMetallicRoughness.metallicFactor=0,t.pbrMetallicRoughness.roughnessFactor=.9}}class y{constructor(e){this.writer=e,this.name="KHR_materials_pbrSpecularGlossiness"}writeMaterial(e,t){if(!e.isGLTFSpecularGlossinessMaterial)return;const s=this.writer,n=s.extensionsUsed,r={};t.pbrMetallicRoughness.baseColorFactor&&(r.diffuseFactor=t.pbrMetallicRoughness.baseColorFactor);const i=[1,1,1];if(e.specular.toArray(i,0),r.specularFactor=i,r.glossinessFactor=e.glossiness,t.pbrMetallicRoughness.baseColorTexture&&(r.diffuseTexture=t.pbrMetallicRoughness.baseColorTexture),e.specularMap){const t={index:s.processTexture(e.specularMap)};s.applyTextureTransform(t,e.specularMap),r.specularGlossinessTexture=t}t.extensions=t.extensions||{},t.extensions[this.name]=r,n[this.name]=!0}}class b{constructor(e){this.writer=e,this.name="KHR_materials_clearcoat"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial)return;const s=this.writer,n=s.extensionsUsed,r={};if(r.clearcoatFactor=e.clearcoat,e.clearcoatMap){const t={index:s.processTexture(e.clearcoatMap)};s.applyTextureTransform(t,e.clearcoatMap),r.clearcoatTexture=t}if(r.clearcoatRoughnessFactor=e.clearcoatRoughness,e.clearcoatRoughnessMap){const t={index:s.processTexture(e.clearcoatRoughnessMap)};s.applyTextureTransform(t,e.clearcoatRoughnessMap),r.clearcoatRoughnessTexture=t}if(e.clearcoatNormalMap){const t={index:s.processTexture(e.clearcoatNormalMap)};s.applyTextureTransform(t,e.clearcoatNormalMap),r.clearcoatNormalTexture=t}t.extensions=t.extensions||{},t.extensions[this.name]=r,n[this.name]=!0}}class R{constructor(e){this.writer=e,this.name="KHR_materials_transmission"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||0===e.transmission)return;const s=this.writer,n=s.extensionsUsed,r={};if(r.transmissionFactor=e.transmission,e.transmissionMap){const t={index:s.processTexture(e.transmissionMap)};s.applyTextureTransform(t,e.transmissionMap),r.transmissionTexture=t}t.extensions=t.extensions||{},t.extensions[this.name]=r,n[this.name]=!0}}class M{constructor(e){this.writer=e,this.name="KHR_materials_volume"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||0===e.transmission)return;const s=this.writer,n=s.extensionsUsed,r={};if(r.thicknessFactor=e.thickness,e.thicknessMap){const t={index:s.processTexture(e.thicknessMap)};s.applyTextureTransform(t,e.thicknessMap),r.thicknessTexture=t}r.attenuationDistance=e.attenuationDistance,r.attenuationColor=e.attenuationColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=r,n[this.name]=!0}}e.Utils={insertKeyframe:function(e,t){const s=.001,n=e.getValueSize(),r=new e.TimeBufferType(e.times.length+1),i=new e.ValueBufferType(e.values.length+n),a=e.createInterpolant(new e.ValueBufferType(n));let o;if(0===e.times.length){r[0]=t;for(let e=0;e<n;e++)i[e]=0;o=0}else if(t<e.times[0]){if(Math.abs(e.times[0]-t)<s)return 0;r[0]=t,r.set(e.times,1),i.set(a.evaluate(t),0),i.set(e.values,n),o=0}else if(t>e.times[e.times.length-1]){if(Math.abs(e.times[e.times.length-1]-t)<s)return e.times.length-1;r[r.length-1]=t,r.set(e.times,0),i.set(e.values,0),i.set(a.evaluate(t),e.values.length),o=r.length-1}else for(let l=0;l<e.times.length;l++){if(Math.abs(e.times[l]-t)<s)return l;if(e.times[l]<t&&e.times[l+1]>t){r.set(e.times.slice(0,l+1),0),r[l+1]=t,r.set(e.times.slice(l+1),l+2),i.set(e.values.slice(0,(l+1)*n),0),i.set(a.evaluate(t),(l+1)*n),i.set(e.values.slice((l+1)*n),(l+2)*n),o=l+1;break}}return e.times=r,e.values=i,o},mergeMorphTargetTracks:function(e,t){const s=[],n={},r=e.tracks;for(let i=0;i<r.length;++i){let e=r[i];const a=THREE.PropertyBinding.parseTrackName(e.name),o=THREE.PropertyBinding.findNode(t,a.nodeName);if("morphTargetInfluences"!==a.propertyName||void 0===a.propertyIndex){s.push(e);continue}if(e.createInterpolant!==e.InterpolantFactoryMethodDiscrete&&e.createInterpolant!==e.InterpolantFactoryMethodLinear){if(e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),e=e.clone(),e.setInterpolation(THREE.InterpolateLinear)}const l=o.morphTargetInfluences.length,c=o.morphTargetDictionary[a.propertyIndex];if(void 0===c)throw new Error("THREE.GLTFExporter: Morph target name not found: "+a.propertyIndex);let u;if(void 0===n[o.uuid]){u=e.clone();const t=new u.ValueBufferType(l*u.times.length);for(let e=0;e<u.times.length;e++)t[e*l+c]=u.values[e];u.name=(a.nodeName||"")+".morphTargetInfluences",u.values=t,n[o.uuid]=u,s.push(u);continue}const h=e.createInterpolant(new e.ValueBufferType(1));u=n[o.uuid];for(let t=0;t<u.times.length;t++)u.values[t*l+c]=h.evaluate(u.times[t]);for(let t=0;t<e.times.length;t++){const s=this.insertKeyframe(u,e.times[t]);u.values[s*l+c]=e.values[t]}}return e.tracks=s,e}},THREE.GLTFExporter=e})();