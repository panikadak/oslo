(function(){class e{parse(e,t,r={}){if(r=Object.assign({version:"1.4.1",author:null,textureDirectory:"",upAxis:"Y_UP",unitName:null,unitMeter:null},r),null===r.upAxis.match(/^[XYZ]_UP$/))return console.error("ColladaExporter: Invalid upAxis: valid values are X_UP, Y_UP or Z_UP."),null;if(null!==r.unitName&&null===r.unitMeter)return console.error("ColladaExporter: unitMeter needs to be specified if unitName is specified."),null;if(null!==r.unitMeter&&null===r.unitName)return console.error("ColladaExporter: unitName needs to be specified if unitMeter is specified."),null;""!==r.textureDirectory&&(r.textureDirectory=`${r.textureDirectory}/`.replace(/\\/g,"/").replace(/\/+/g,"/"));const a=r.version;if("1.4.1"!==a&&"1.5.0"!==a)return console.warn(`ColladaExporter : Version ${a} not supported for export. Only 1.4.1 and 1.5.0.`),null;function n(e){const t=/^<\//,r=/(\?>$)|(\/>$)/,a=/<[^>]+>[^<]*<\/[^<]+>/,n=(e,t)=>t>0?e+n(e,t-1):"";let i=0;return e.match(/(<[^>]+>[^<]+<\/[^<]+>)|(<[^>]+>)/g).map((e=>{a.test(e)||r.test(e)||!t.test(e)||i--;const s=`${n("  ",i)}${e}`;return a.test(e)||r.test(e)||t.test(e)||i++,s})).join("\n")}function i(e){const t=atob(e),r=new Uint8Array(t.length);for(let a=0,n=r.length;a<n;a++)r[a]=t.charCodeAt(a);return r}let s,o;function l(e,t){s=s||document.createElement("canvas"),o=o||s.getContext("2d"),s.width=e.width,s.height=e.height,o.drawImage(e,0,0);const r=s.toDataURL(`image/${t}`,1).replace(/^data:image\/(png|jpg);base64,/,"");return i(r)}const u=["getX","getY","getZ","getW"];function c(e){if(e.isInterleavedBufferAttribute){const t=new e.array.constructor(e.count*e.itemSize),r=e.itemSize;for(let a=0,n=e.count;a<n;a++)for(let i=0;i<r;i++)t[a*r+i]=e[u[i]](a);return t}return e.array}function m(e,t,r){return Array.isArray(e)?e.slice(t,t+r):new e.constructor(e.buffer,t*e.BYTES_PER_ELEMENT,r)}function p(e,t,r,a){const n=c(e),i=`<source id="${t}"><float_array id="${t}-array" count="${n.length}">`+n.join(" ")+"</float_array><technique_common>"+`<accessor source="#${t}-array" count="${Math.floor(n.length/e.itemSize)}" stride="${e.itemSize}">`+r.map((e=>`<param name="${e}" type="${a}" />`)).join("")+"</accessor></technique_common></source>";return i}let f;function d(e){return e.updateMatrix(),f=f||new THREE.Matrix4,f.copy(e.matrix),f.transpose(),`<matrix>${f.toArray().join(" ")}</matrix>`}function $(e){let t=y.get(e);if(!t){const r=e;if(!0!==r.isBufferGeometry)throw new Error("THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.");const a=`Mesh${M.length+1}`,n=r.index?r.index.count*r.index.itemSize:r.attributes.position.count,i=null!=r.groups&&0!==r.groups.length?r.groups:[{start:0,count:n,materialIndex:0}],s=e.name?` name="${e.name}"`:"";let o=`<geometry id="${a}"${s}><mesh>`;const l=`${a}-position`,u=`${a}-vertices`;o+=p(r.attributes.position,l,["X","Y","Z"],"float"),o+=`<vertices id="${u}"><input semantic="POSITION" source="#${l}" /></vertices>`;let f=`<input semantic="VERTEX" source="#${u}" offset="0" />`;if("normal"in r.attributes){const e=`${a}-normal`;o+=p(r.attributes.normal,e,["X","Y","Z"],"float"),f+=`<input semantic="NORMAL" source="#${e}" offset="0" />`}if("uv"in r.attributes){const e=`${a}-texcoord`;o+=p(r.attributes.uv,e,["S","T"],"float"),f+=`<input semantic="TEXCOORD" source="#${e}" offset="0" set="0" />`}if("uv2"in r.attributes){const e=`${a}-texcoord2`;o+=p(r.attributes.uv2,e,["S","T"],"float"),f+=`<input semantic="TEXCOORD" source="#${e}" offset="0" set="1" />`}if("color"in r.attributes){const e=`${a}-color`;o+=p(r.attributes.color,e,["X","Y","Z"],"uint8"),f+=`<input semantic="COLOR" source="#${e}" offset="0" />`}let d=null;if(r.index)d=c(r.index);else{d=new Array(n);for(let e=0,t=d.length;e<t;e++)d[e]=e}for(let e=0,t=i.length;e<t;e++){const t=i[e],r=m(d,t.start,t.count),a=r.length/3;o+=`<triangles material="MESH_MATERIAL_${t.materialIndex}" count="${a}">`,o+=f,o+=`<p>${r.join(" ")}</p>`,o+="</triangles>"}o+="</mesh></geometry>",M.push(o),t={meshid:a,bufferGeometry:r},y.set(e,t)}return t}function g(e){let t=E.get(e);if(null==t){t=`image-${w.length+1}`;const n="png",i=e.name||t;let s=`<image id="${t}" name="${i}">`;s+="1.5.0"===a?`<init_from><ref>${r.textureDirectory}${i}.${n}</ref></init_from>`:`<init_from>${r.textureDirectory}${i}.${n}</init_from>`,s+="</image>",w.push(s),E.set(e,t),b.push({directory:r.textureDirectory,name:i,ext:n,data:l(e.image,n),original:e})}return t}function h(e){let t=x.get(e);if(null==t){t=`Mat${v.length+1}`;let r="phong";!0===e.isMeshLambertMaterial?r="lambert":!0===e.isMeshBasicMaterial&&(r="constant",null!==e.map&&console.warn("ColladaExporter: Texture maps not supported with THREE.MeshBasicMaterial."));const a=e.emissive?e.emissive:new THREE.Color(0,0,0),n=e.color?e.color:new THREE.Color(0,0,0),i=e.specular?e.specular:new THREE.Color(1,1,1),s=e.shininess||0,o=e.reflectivity||0;let l="";!0===e.transparent&&(l+="<transparent>"+(e.map?'<texture texture="diffuse-sampler"></texture>':"<float>1</float>")+"</transparent>",e.opacity<1&&(l+=`<transparency><float>${e.opacity}</float></transparency>`));const u=`<technique sid="common"><${r}><emission>`+(e.emissiveMap?'<texture texture="emissive-sampler" texcoord="TEXCOORD" />':`<color sid="emission">${a.r} ${a.g} ${a.b} 1</color>`)+"</emission>"+("constant"!==r?"<diffuse>"+(e.map?'<texture texture="diffuse-sampler" texcoord="TEXCOORD" />':`<color sid="diffuse">${n.r} ${n.g} ${n.b} 1</color>`)+"</diffuse>":"")+("constant"!==r?"<bump>"+(e.normalMap?'<texture texture="bump-sampler" texcoord="TEXCOORD" />':"")+"</bump>":"")+("phong"===r?`<specular><color sid="specular">${i.r} ${i.g} ${i.b} 1</color></specular><shininess>`+(e.specularMap?'<texture texture="specular-sampler" texcoord="TEXCOORD" />':`<float sid="shininess">${s}</float>`)+"</shininess>":"")+`<reflective><color>${n.r} ${n.g} ${n.b} 1</color></reflective>`+`<reflectivity><float>${o}</float></reflectivity>`+l+`</${r}></technique>`,c=`<effect id="${t}-effect"><profile_COMMON>`+(e.map?`<newparam sid="diffuse-surface"><surface type="2D"><init_from>${g(e.map)}</init_from></surface></newparam><newparam sid="diffuse-sampler"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>`:"")+(e.specularMap?`<newparam sid="specular-surface"><surface type="2D"><init_from>${g(e.specularMap)}</init_from></surface></newparam><newparam sid="specular-sampler"><sampler2D><source>specular-surface</source></sampler2D></newparam>`:"")+(e.emissiveMap?`<newparam sid="emissive-surface"><surface type="2D"><init_from>${g(e.emissiveMap)}</init_from></surface></newparam><newparam sid="emissive-sampler"><sampler2D><source>emissive-surface</source></sampler2D></newparam>`:"")+(e.normalMap?`<newparam sid="bump-surface"><surface type="2D"><init_from>${g(e.normalMap)}</init_from></surface></newparam><newparam sid="bump-sampler"><sampler2D><source>bump-surface</source></sampler2D></newparam>`:"")+u+(e.side===THREE.DoubleSide?'<extra><technique profile="THREEJS"><double_sided sid="double_sided" type="int">1</double_sided></technique></extra>':"")+"</profile_COMMON></effect>",m=e.name?` name="${e.name}"`:"",p=`<material id="${t}"${m}><instance_effect url="#${t}-effect" /></material>`;D.push(p),v.push(c),x.set(e,t)}return t}function _(e){let t=`<node name="${e.name}">`;if(t+=d(e),!0===e.isMesh&&null!==e.geometry){const r=$(e.geometry),a=r.meshid,n=r.bufferGeometry;let i,s=null;const o=e.material||new THREE.MeshBasicMaterial,l=Array.isArray(o)?o:[o];i=n.groups.length>l.length?new Array(n.groups.length):new Array(l.length),s=i.fill().map(((e,t)=>h(l[t%l.length]))),t+=`<instance_geometry url="#${a}">`+(null!=s?"<bind_material><technique_common>"+s.map(((e,t)=>`<instance_material symbol="MESH_MATERIAL_${t}" target="#${e}" ><bind_vertex_input semantic="TEXCOORD" input_semantic="TEXCOORD" input_set="0" /></instance_material>`)).join("")+"</technique_common></bind_material>":"")+"</instance_geometry>"}return e.children.forEach((e=>t+=_(e))),t+="</node>",t}const y=new WeakMap,x=new WeakMap,E=new WeakMap,b=[],w=[],M=[],v=[],D=[],O=_(e),T="1.4.1"===a?"http://www.collada.org/2005/11/COLLADASchema":"https://www.khronos.org/collada/";let A=`<?xml version="1.0" encoding="UTF-8" standalone="no" ?><COLLADA xmlns="${T}" version="${a}"><asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>`+(null!==r.author?`<author>${r.author}</author>`:"")+"</contributor>"+`<created>${(new Date).toISOString()}</created>`+`<modified>${(new Date).toISOString()}</modified>`+(null!==r.unitName?`<unit name="${r.unitName}" meter="${r.unitMeter}" />`:"")+`<up_axis>${r.upAxis}</up_axis></asset>`;A+=`<library_images>${w.join("")}</library_images>`,A+=`<library_effects>${v.join("")}</library_effects>`,A+=`<library_materials>${D.join("")}</library_materials>`,A+=`<library_geometries>${M.join("")}</library_geometries>`,A+=`<library_visual_scenes><visual_scene id="Scene" name="scene">${O}</visual_scene></library_visual_scenes>`,A+='<scene><instance_visual_scene url="#Scene"/></scene>',A+="</COLLADA>";const C={data:n(A),textures:b};return"function"===typeof t&&requestAnimationFrame((()=>t(C))),C}}THREE.ColladaExporter=e})();