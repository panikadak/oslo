(function(){class n{async parse(n){const e={},s="model.usda";e[s]=null;let a=o();const l={},p={};n.traverseVisible((n=>{if(n.isMesh)if(n.material.isMeshStandardMaterial){const t=n.geometry,o=n.material,s="geometries/Geometry_"+t.id+".usd";if(!(s in e)){const n=u(t);e[s]=r(n)}o.uuid in l||(l[o.uuid]=o),a+=i(n,t,o)}else console.warn("THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)",n)})),a+=m(l,p),e[s]=fflate.strToU8(a),a=null;for(const o in p){const n=p[o],r=o.split("_")[1],i=1023===n.format,s=t(n.image,r),a=await new Promise((n=>s.toBlob(n,i?"image/png":"image/jpeg",1)));e[`textures/Texture_${o}.${i?"png":"jpg"}`]=new Uint8Array(await a.arrayBuffer())}let c=0;for(const t in e){const n=e[t],o=34+t.length;c+=o;const r=63&c;if(4!==r){const o=64-r,i=new Uint8Array(o);e[t]=[n,{extra:{12345:i}}]}c=n.length}return fflate.zipSync(e,{level:0})}}function t(n,t){if("undefined"!==typeof HTMLImageElement&&n instanceof HTMLImageElement||"undefined"!==typeof HTMLCanvasElement&&n instanceof HTMLCanvasElement||"undefined"!==typeof OffscreenCanvas&&n instanceof OffscreenCanvas||"undefined"!==typeof ImageBitmap&&n instanceof ImageBitmap){const e=1024/Math.max(n.width,n.height),o=document.createElement("canvas");o.width=n.width*Math.min(1,e),o.height=n.height*Math.min(1,e);const r=o.getContext("2d");if(r.drawImage(n,0,0,o.width,o.height),void 0!==t){const n=parseInt(t,16),e=(n>>16&255)/255,i=(n>>8&255)/255,s=(255&n)/255,a=r.getImageData(0,0,o.width,o.height),u=a.data;for(let t=0;t<u.length;t+=4)u[t+0]=u[t+0]*e,u[t+1]=u[t+1]*i,u[t+2]=u[t+2]*s;r.putImageData(a,0,0)}return o}}const e=7;function o(){return'#usda 1.0\n(\n    customLayerData = {\n        string creator = "Three.js USDZExporter"\n    }\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n'}function r(n){let t=o();return t+=n,fflate.strToU8(t)}function i(n,t,e){const o="Object_"+n.id,r=s(n.matrixWorld);return n.matrixWorld.determinant()<0&&console.warn("THREE.USDZExporter: USDZ does not support negative scales",n),`def Xform "${o}" (\n    prepend references = @./geometries/Geometry_${t.id}.usd@</Geometry>\n)\n{\n    matrix4d xformOp:transform = ${r}\n    uniform token[] xformOpOrder = ["xformOp:transform"]\n\n    rel material:binding = </Materials/Material_${e.id}>\n}\n\n`}function s(n){const t=n.elements;return`( ${a(t,0)}, ${a(t,4)}, ${a(t,8)}, ${a(t,12)} )`}function a(n,t){return`(${n[t+0]}, ${n[t+1]}, ${n[t+2]}, ${n[t+3]})`}function u(n){const t=l(n);return`\ndef "Geometry"\n{\n  ${t}\n}\n`}function l(n){const t="Geometry",e=n.attributes,o=e.position.count;return`\n    def Mesh "${t}"\n    {\n        int[] faceVertexCounts = [${p(n)}]\n        int[] faceVertexIndices = [${c(n)}]\n        normal3f[] normals = [${f(e.normal,o)}] (\n            interpolation = "vertex"\n        )\n        point3f[] points = [${f(e.position,o)}]\n        float2[] primvars:st = [${d(e.uv,o)}] (\n            interpolation = "vertex"\n        )\n        uniform token subdivisionScheme = "none"\n    }\n`}function p(n){const t=null!==n.index?n.index.count:n.attributes.position.count;return Array(t/3).fill(3).join(", ")}function c(n){const t=n.index,e=[];if(null!==t)for(let o=0;o<t.count;o++)e.push(t.getX(o));else{const t=n.attributes.position.count;for(let n=0;n<t;n++)e.push(n)}return e.join(", ")}function f(n,t){if(void 0===n)return console.warn("USDZExporter: Normals missing."),Array(t).fill("(0, 0, 0)").join(", ");const o=[];for(let r=0;r<n.count;r++){const t=n.getX(r),i=n.getY(r),s=n.getZ(r);o.push(`(${t.toPrecision(e)}, ${i.toPrecision(e)}, ${s.toPrecision(e)})`)}return o.join(", ")}function d(n,t){if(void 0===n)return console.warn("USDZExporter: UVs missing."),Array(t).fill("(0, 0)").join(", ");const o=[];for(let r=0;r<n.count;r++){const t=n.getX(r),i=n.getY(r);o.push(`(${t.toPrecision(e)}, ${1-i.toPrecision(e)})`)}return o.join(", ")}function m(n,t){const e=[];for(const o in n){const r=n[o];e.push($(r,t))}return`def "Materials"\n{\n${e.join("")}\n}\n\n`}function $(n,t){const e="            ",o=[],r=[];function i(e,o,r){const i=e.id+(r?"_"+r.getHexString():""),s=1023===e.format;return t[i]=e,`\n        def Shader "Transform2d_${o}" (\n            sdrMetadata = {\n                string role = "math"\n            }\n        )\n        {\n            uniform token info:id = "UsdTransform2d"\n            float2 inputs:in.connect = </Materials/Material_${n.id}/uvReader_st.outputs:result>\n            float2 inputs:scale = ${g(e.repeat)}\n            float2 inputs:translation = ${g(e.offset)}\n            float2 outputs:result\n        }\n\n        def Shader "Texture_${e.id}_${o}"\n        {\n            uniform token info:id = "UsdUVTexture"\n            asset inputs:file = @textures/Texture_${i}.${s?"png":"jpg"}@\n            float2 inputs:st.connect = </Materials/Material_${n.id}/Transform2d_${o}.outputs:result>\n            token inputs:wrapS = "repeat"\n            token inputs:wrapT = "repeat"\n            float outputs:r\n            float outputs:g\n            float outputs:b\n            float3 outputs:rgb\n        }`}return null!==n.map?(o.push(`${e}color3f inputs:diffuseColor.connect = </Materials/Material_${n.id}/Texture_${n.map.id}_diffuse.outputs:rgb>`),r.push(i(n.map,"diffuse",n.color))):o.push(`${e}color3f inputs:diffuseColor = ${h(n.color)}`),null!==n.emissiveMap?(o.push(`${e}color3f inputs:emissiveColor.connect = </Materials/Material_${n.id}/Texture_${n.emissiveMap.id}_emissive.outputs:rgb>`),r.push(i(n.emissiveMap,"emissive"))):n.emissive.getHex()>0&&o.push(`${e}color3f inputs:emissiveColor = ${h(n.emissive)}`),null!==n.normalMap&&(o.push(`${e}normal3f inputs:normal.connect = </Materials/Material_${n.id}/Texture_${n.normalMap.id}_normal.outputs:rgb>`),r.push(i(n.normalMap,"normal"))),null!==n.aoMap&&(o.push(`${e}float inputs:occlusion.connect = </Materials/Material_${n.id}/Texture_${n.aoMap.id}_occlusion.outputs:r>`),r.push(i(n.aoMap,"occlusion"))),null!==n.roughnessMap&&1===n.roughness?(o.push(`${e}float inputs:roughness.connect = </Materials/Material_${n.id}/Texture_${n.roughnessMap.id}_roughness.outputs:g>`),r.push(i(n.roughnessMap,"roughness"))):o.push(`${e}float inputs:roughness = ${n.roughness}`),null!==n.metalnessMap&&1===n.metalness?(o.push(`${e}float inputs:metallic.connect = </Materials/Material_${n.id}/Texture_${n.metalnessMap.id}_metallic.outputs:b>`),r.push(i(n.metalnessMap,"metallic"))):o.push(`${e}float inputs:metallic = ${n.metalness}`),null!==n.alphaMap?(o.push(`${e}float inputs:opacity.connect = </Materials/Material_${n.id}/Texture_${n.alphaMap.id}_opacity.outputs:r>`),o.push(`${e}float inputs:opacityThreshold = 0.0001`),r.push(i(n.alphaMap,"opacity"))):o.push(`${e}float inputs:opacity = ${n.opacity}`),n.isMeshPhysicalMaterial&&(o.push(`${e}float inputs:clearcoat = ${n.clearcoat}`),o.push(`${e}float inputs:clearcoatRoughness = ${n.clearcoatRoughness}`),o.push(`${e}float inputs:ior = ${n.ior}`)),`\n    def Material "Material_${n.id}"\n    {\n        def Shader "PreviewSurface"\n        {\n            uniform token info:id = "UsdPreviewSurface"\n${o.join("\n")}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n\n        token outputs:surface.connect = </Materials/Material_${n.id}/PreviewSurface.outputs:surface>\n        token inputs:frame:stPrimvarName = "st"\n\n        def Shader "uvReader_st"\n        {\n            uniform token info:id = "UsdPrimvarReader_float2"\n            token inputs:varname.connect = </Materials/Material_${n.id}.inputs:frame:stPrimvarName>\n            float2 inputs:fallback = (0.0, 0.0)\n            float2 outputs:result\n        }\n\n${r.join("\n")}\n\n    }\n`}function h(n){return`(${n.r}, ${n.g}, ${n.b})`}function g(n){return`(${n.x}, ${n.y})`}THREE.USDZExporter=n})();