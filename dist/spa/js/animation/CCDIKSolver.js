(function(){const t=new THREE.Quaternion,e=new THREE.Vector3,r=new THREE.Vector3,i=new THREE.Vector3,n=new THREE.Vector3,o=new THREE.Vector3,s=new THREE.Quaternion,a=new THREE.Vector3,l=new THREE.Vector3,h=new THREE.Vector3,c=new THREE.Matrix4;class E{constructor(t,e=[]){this.mesh=t,this.iks=e,this._valid()}update(){const t=this.iks;for(let e=0,r=t.length;e<r;e++)this.updateOne(t[e]);return this}updateOne(c){const E=this.mesh.skeleton.bones,d=Math,p=E[c.effector],m=E[c.target];e.setFromMatrixPosition(m.matrixWorld);const u=c.links,f=void 0!==c.iteration?c.iteration:1;for(let T=0;T<f;T++){let m=!1;for(let f=0,T=u.length;f<T;f++){const T=E[u[f].index];if(!1===u[f].enabled)break;const x=u[f].limitation,M=u[f].rotationMin,w=u[f].rotationMax;T.matrixWorld.decompose(o,s,a),s.invert(),i.setFromMatrixPosition(p.matrixWorld),n.subVectors(i,o),n.applyQuaternion(s),n.normalize(),r.subVectors(e,o),r.applyQuaternion(s),r.normalize();let H=r.dot(n);if(H>1?H=1:H<-1&&(H=-1),H=d.acos(H),!(H<1e-5)){if(void 0!==c.minAngle&&H<c.minAngle&&(H=c.minAngle),void 0!==c.maxAngle&&H>c.maxAngle&&(H=c.maxAngle),l.crossVectors(n,r),l.normalize(),t.setFromAxisAngle(l,H),T.quaternion.multiply(t),void 0!==x){let t=T.quaternion.w;t>1&&(t=1);const e=d.sqrt(1-t*t);T.quaternion.set(x.x*e,x.y*e,x.z*e,t)}void 0!==M&&T.rotation.setFromVector3(T.rotation.toVector3(h).max(M)),void 0!==w&&T.rotation.setFromVector3(T.rotation.toVector3(h).min(w)),T.updateMatrixWorld(!0),m=!0}}if(!m)break}return this}createHelper(){return new m(this.mesh,this.mesh.geometry.userData.MMD.iks)}_valid(){const t=this.iks,e=this.mesh.skeleton.bones;for(let r=0,i=t.length;r<i;r++){const i=t[r],n=e[i.effector],o=i.links;let s,a;s=n;for(let t=0,r=o.length;t<r;t++)a=e[o[t].index],s.parent!==a&&console.warn("THREE.CCDIKSolver: bone "+s.name+" is not the child of bone "+a.name),s=a}}}function d(t,e){return h.setFromMatrixPosition(t.matrixWorld).applyMatrix4(e)}function p(t,e,r,i){const n=d(r,i);t[3*e+0]=n.x,t[3*e+1]=n.y,t[3*e+2]=n.z}class m extends THREE.Object3D{constructor(t,e=[]){super(),this.root=t,this.iks=e,this.matrix.copy(t.matrixWorld),this.matrixAutoUpdate=!1,this.sphereGeometry=new THREE.SphereGeometry(.25,16,8),this.targetSphereMaterial=new THREE.MeshBasicMaterial({color:new THREE.Color(16746632),depthTest:!1,depthWrite:!1,transparent:!0}),this.effectorSphereMaterial=new THREE.MeshBasicMaterial({color:new THREE.Color(8978312),depthTest:!1,depthWrite:!1,transparent:!0}),this.linkSphereMaterial=new THREE.MeshBasicMaterial({color:new THREE.Color(8947967),depthTest:!1,depthWrite:!1,transparent:!0}),this.lineMaterial=new THREE.LineBasicMaterial({color:new THREE.Color(16711680),depthTest:!1,depthWrite:!1,transparent:!0}),this._init()}updateMatrixWorld(t){const e=this.root;if(this.visible){let t=0;const r=this.iks,i=e.skeleton.bones;c.copy(e.matrixWorld).invert();for(let e=0,n=r.length;e<n;e++){const n=r[e],o=i[n.target],s=i[n.effector],a=this.children[t++],l=this.children[t++];a.position.copy(d(o,c)),l.position.copy(d(s,c));for(let e=0,r=n.links.length;e<r;e++){const r=n.links[e],o=i[r.index],s=this.children[t++];s.position.copy(d(o,c))}const h=this.children[t++],E=h.geometry.attributes.position.array;p(E,0,o,c),p(E,1,s,c);for(let t=0,e=n.links.length;t<e;t++){const e=n.links[t],r=i[e.index];p(E,t+2,r,c)}h.geometry.attributes.position.needsUpdate=!0}}this.matrix.copy(e.matrixWorld),super.updateMatrixWorld(t)}_init(){const t=this,e=this.iks;function r(t){const e=new THREE.BufferGeometry,r=new Float32Array(3*(2+t.links.length));return e.setAttribute("position",new THREE.BufferAttribute(r,3)),e}function i(){return new THREE.Mesh(t.sphereGeometry,t.targetSphereMaterial)}function n(){return new THREE.Mesh(t.sphereGeometry,t.effectorSphereMaterial)}function o(){return new THREE.Mesh(t.sphereGeometry,t.linkSphereMaterial)}function s(e){return new THREE.Line(r(e),t.lineMaterial)}for(let a=0,l=e.length;a<l;a++){const t=e[a];this.add(i()),this.add(n());for(let e=0,r=t.links.length;e<r;e++)this.add(o());this.add(s(t))}}}THREE.CCDIKSolver=E})();